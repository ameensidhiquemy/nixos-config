This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    backport.yml
    ci.yml
    github_pages.yml
  FUNDING.yml
docs/
  manual/
    introduction.md
    manpage-urls.json
    manual.md
    options.md
    preface.md
  static/
    style.css
  default.nix
  plasma-manager-options.nix
examples/
  homeManager/
    home.nix
    README.md
  homeManagerFlake/
    flake.nix
  systemFlake/
    flake.nix
  .gitignore
  home.nix
lib/
  colorscheme.nix
  panel.nix
  qfont.nix
  types.nix
  wallpapers.nix
  writeconfig.nix
modules/
  apps/
    kate/
      check-theme-name-free.sh
      default.nix
    default.nix
    elisa.nix
    ghostwriter.nix
    konsole.nix
    okular.nix
  widgets/
    app-menu.nix
    application-title-bar.nix
    battery.nix
    default.nix
    digital-clock.nix
    icon-tasks.nix
    keyboard-layout.nix
    kicker.nix
    kickerdash.nix
    kickoff.nix
    lib.nix
    pager.nix
    panel-spacer.nix
    plasma-panel-colorizer.nix
    plasmusic-toolbar.nix
    system-monitor.nix
    system-tray.nix
  default.nix
  desktop.nix
  files.nix
  fonts.nix
  hotkeys.nix
  input.nix
  krunner.nix
  kscreenlocker.nix
  kwin.nix
  panels.nix
  powerdevil.nix
  session.nix
  shortcuts.nix
  spectacle.nix
  startup.nix
  window-rules.nix
  windows.nix
  workspace.nix
script/
  rc2nix.py
  rc2nix.rb
  write_config.py
test/
  rc2nix/
    test_data/
      kcminputrc
      kglobalshortcutsrc
      krunnerrc
      kscreenlockerrc
      kwinrc
    test_rc2nix.py
  basic.nix
  demo.nix
.envrc
.gitignore
default.nix
flake.lock
flake.nix
LICENSE
README.md
treefmt.toml
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/workflows/backport.yml">
name: Backport
on:
  pull_request_target:
    types: [closed, labeled]

# WARNING:
# When extending this action, be aware that $GITHUB_TOKEN allows write access to
# the GitHub repository. This means that it should not evaluate user input in a
# way that allows code injection.

permissions:
  contents: read

jobs:
  backport:
    permissions:
      contents: write
      pull-requests: write
    name: Backport pull request
    if: github.repository_owner == 'nix-community' && github.event.pull_request.merged == true && (github.event_name != 'labeled' || startsWith('backport', github.event.label.name))
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4.2.1
        with:
          ref: ${{ github.event.pull_request.head.sha }}
      - name: Create backport pull request
        uses: korthout/backport-action@v3.1.0
        with:
          pull_description: |-
            This is an automated backport of #${pull_number} to `${target_branch}`.

            Before merging, make sure this change is backwards compatible with the stable release branch.
</file>

<file path=".github/workflows/ci.yml">
name: "Nix Checks"
on:
  pull_request:
    paths:
    - '**/*.nix'
    - 'flake.lock'
    - 'script/**'

# cancel previous runs when pushing new changes
concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

jobs:
  checks:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - uses: cachix/install-nix-action@v22
      with:
        extra_nix_config: "system-features = kvm nixos-test"
    - run: nix flake check -L --keep-going
    - run: nix flake check -L --keep-going --override-input plasma-manager . ./examples/homeManagerFlake
    - run: nix flake check -L --keep-going --override-input plasma-manager . ./examples/systemFlake
</file>

<file path=".github/workflows/github_pages.yml">
name: GitHub Pages Docs Generation
on:
  push:
    branches:
    - trunk
    paths:
    - 'flake.nix'
    - 'flake.lock'
    - 'modules/**'
    - 'docs/**'
    
jobs:
  publish:
    strategy:
      matrix:
        os: [ubuntu-latest]
    runs-on: ${{ matrix.os }}
    steps:
    - uses: actions/checkout@v4
    - uses: cachix/install-nix-action@v27
      with:
        nix_path: nixpkgs=channel:nixos-unstable
    - uses: cachix/cachix-action@v15
      with:
        name: nix-community
        authToken: '${{ secrets.CACHIX_AUTH_TOKEN }}'
    - run: |
        nix-build -A docs.html
        cp -r result/share/doc/plasma-manager public
    - name: Deploy
      uses: peaceiris/actions-gh-pages@v4
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}
        publish_dir: ./public
</file>

<file path=".github/FUNDING.yml">
github: HeitorAugustoLN
</file>

<file path="docs/manual/introduction.md">
# Introduction {#intro}
To get started, check out the [**getting started** section in the README](https://github.com/nix-community/plasma-manager#getting-started).
There are a couple of examples on how you can get started using `plasma-manager`,
using either a flake or traditional Nix channels.

More details may be available here in the future!
</file>

<file path="docs/manual/manpage-urls.json">
{}
</file>

<file path="docs/manual/manual.md">
# Plasma-Manager manual {#plasma-manager-manual}

## Version: @VERSION@

```{=include=} preface html:into-file=//preface.xhtml
preface.md
```

```{=include=} parts html:into-file=//introduction.xhtml
introduction.md
```

```{=include=} appendix html:into-file=//options.xhtml
options.md
```
</file>

<file path="docs/manual/options.md">
# Plasma-Manager Options {#ch-options}

```{=include=} options
id-prefix: opt-
list-id: plasma-manager-options
source: @OPTIONS_JSON@
```
</file>

<file path="docs/manual/preface.md">
# Preface {#preface}
Plasma Manager is a [Home Manager](https://github.com/nix-community/home-manager)
module capable of configuring as much of KDE Plasma as
possible, using [Nix](https://nixos.org).

The project has progressed a lot lately, to the extent where
[most of the configuration options present in KDE Plasma 6 are configurable through `plasma-manager`](https://github.com/nix-community/plasma-manager#whats-supported).

The main focus of the project has been on KDE Plasma 6 for a little while now,
but it's also possible to use it to some extent on Plasma 5 as well.
</file>

<file path="docs/static/style.css">
:root {
    --nmd-color0: #0A3E68;
    --nmd-color1: #268598;
    --nmd-color2: #B8D09E;
    --nmd-color3: #F6CF5E;
    --nmd-color4: #EC733B;
    --nmd-color-info: #167cb9;
    --nmd-color-warn: #ff6700
}

html {
    -webkit-text-size-adjust: 100%
}

html:focus-within {
    scroll-behavior: smooth
}

body {
    -webkit-text-size-adjust: 100%;
    -moz-text-size-adjust: 100%;
    text-size-adjust: 100%;
    -moz-osx-font-smoothing: grayscale;
    -webkit-font-smoothing: antialiased;
    min-height: 100vh;
    position: relative;
    text-rendering: optimizeSpeed;
    width: 100%
}

*,
:after,
:before {
    box-sizing: border-box
}

a:not([class]) {
    -webkit-text-decoration-skip: ink;
    text-decoration-skip-ink: auto
}

a,
abbr,
acronym,
address,
applet,
article,
aside,
audio,
b,
big,
blockquote,
body,
canvas,
caption,
center,
cite,
code,
dd,
del,
details,
dfn,
div,
dl,
dt,
em,
embed,
fieldset,
figcaption,
figure,
footer,
form,
h1,
h2,
h3,
h4,
h5,
h6,
header,
hgroup,
html,
i,
iframe,
img,
ins,
kbd,
label,
legend,
li,
mark,
menu,
nav,
object,
ol,
output,
p,
pre,
q,
ruby,
s,
samp,
section,
small,
span,
strike,
strong,
sub,
summary,
sup,
table,
tbody,
td,
tfoot,
th,
thead,
time,
tr,
tt,
u,
ul,
var,
video {
    border: 0;
    font-size: 100%;
    font: inherit;
    margin: 0;
    padding: 0;
    vertical-align: baseline
}

:focus {
    outline: 0
}

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
menu,
nav,
section {
    display: block
}

ol,
ul {
    list-style: none
}

blockquote,
q {
    quotes: none
}

blockquote:after,
blockquote:before,
q:after,
q:before {
    content: "";
    content: none
}

input,
input:required {
    box-shadow: none
}

input:-webkit-autofill,
input:-webkit-autofill:active,
input:-webkit-autofill:focus,
input:-webkit-autofill:hover {
    -webkit-box-shadow: inset 0 0 0 30px #fff
}

input[type=search]::-webkit-search-cancel-button,
input[type=search]::-webkit-search-decoration,
input[type=search]::-webkit-search-results-button,
input[type=search]::-webkit-search-results-decoration {
    -webkit-appearance: none;
    -moz-appearance: none
}

input[type=search] {
    -webkit-appearance: none;
    -moz-appearance: none
}

input:focus {
    outline: 0
}

audio,
canvas,
video {
    display: inline-block;
    max-width: 100%
}

audio:not([controls]) {
    display: none;
    height: 0
}

[hidden] {
    display: none
}

a:active,
a:hover {
    outline: 0
}

img {
    height: auto;
    max-width: 100%;
    vertical-align: middle
}

img,
picture {
    display: inline-block
}

button,
input {
    line-height: normal
}

button,
html input[type=button],
input[type=reset],
input[type=submit] {
    -webkit-appearance: button;
    background: 0 0;
    border: 0;
    cursor: pointer
}

button[disabled],
html input[disabled] {
    cursor: default
}

[disabled] {
    pointer-events: none
}

input[type=checkbox],
input[type=radio] {
    padding: 0
}

input[type=search] {
    -webkit-appearance: textfield;
    box-sizing: content-box
}

input[type=search]::-webkit-search-cancel-button,
input[type=search]::-webkit-search-decoration {
    -webkit-appearance: none
}

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0
}

button {
    background: 0 0;
    border: 0
}

textarea {
    overflow: auto;
    resize: vertical;
    vertical-align: top
}

table {
    border-collapse: collapse;
    border-spacing: 0;
    text-indent: 0
}

hr {
    background: #000;
    border: 0;
    box-sizing: content-box;
    height: 1px;
    line-height: 0;
    margin: 0;
    overflow: visible;
    padding: 0;
    page-break-after: always;
    width: 100%
}

pre {
    font-family: monospace, monospace;
    font-size: 100%
}

a {
    background-color: transparent
}

abbr[title] {
    border-bottom: none;
    text-decoration: none
}

code,
kbd,
pre,
samp {
    font-family: monospace, monospace
}

small,
sub,
sup {
    font-size: 75%
}

sub,
sup {
    line-height: 0;
    position: relative;
    vertical-align: baseline
}

sub {
    bottom: -5px
}

sup {
    top: -5px
}

button,
input,
optgroup,
select,
textarea {
    font-family: inherit;
    font-size: 100%;
    line-height: 1;
    margin: 0;
    padding: 0
}

button,
input {
    overflow: visible
}

button,
select {
    text-transform: none
}

[type=button],
[type=reset],
[type=submit],
button {
    -webkit-appearance: button
}

[type=button]::-moz-focus-inner,
[type=reset]::-moz-focus-inner,
[type=submit]::-moz-focus-inner,
button::-moz-focus-inner {
    border-style: none;
    outline: 0;
    padding: 0
}

legend {
    border: 0;
    color: inherit;
    display: block;
    max-width: 100%;
    white-space: normal;
    width: 100%
}

fieldset {
    min-width: 0
}

body:not(:-moz-handler-blocked) fieldset {
    display: block
}

progress {
    vertical-align: baseline
}

[type=number]::-webkit-inner-spin-button,
[type=number]::-webkit-outer-spin-button {
    height: auto
}

[type=search] {
    -webkit-appearance: textfield;
    outline-offset: -2px
}

[type=search]::-webkit-search-decoration {
    -webkit-appearance: none
}

::-webkit-file-upload-button {
    -webkit-appearance: button;
    font: inherit
}

summary {
    display: list-item
}

template {
    display: none
}

body {
    background: white;
    color: #111827;
    max-width: min(100ch, 1024px);
    margin: 0 auto;
    padding: 10px;
    font-family: "Lucida Sans", Arial, sans-serif;
    font-size: 16px;
    line-height: 1.4em
}

@media (prefers-color-scheme: dark) {
    body {
        background: #111827;
        color: #F9FAFB
    }
}

h1,
h2,
h3 {
    color: var(--nmd-color0);
    font-family: "Lato", sans-serif;
    font-weight: 300;
    line-height: 1.125
}

@media (prefers-color-scheme: dark) {

    h1,
    h2,
    h3 {
        color: var(--nmd-color4)
    }
}

h1 {
    font-size: 48px;
    font-weight: 300;
    margin: 4rem 0 1.5rem
}

h2 {
    font-size: 32px;
    font-weight: 300;
    margin: 2rem 0 1rem
}

h3 {
    font-size: 20px;
    font-weight: 400;
    margin: .5rem .25rem
}

p {
    margin: .9rem 0
}

p:first-child {
    margin-top: 0
}

p:last-child {
    margin-bottom: 0
}

a {
    color: var(--nmd-color0);
    text-decoration: underline;
    text-underline-offset: 3px
}

a:visited {
    color: var(--nmd-color1)
}

a:hover {
    color: var(--nmd-color1)
}

@media (prefers-color-scheme: dark) {
    a {
        color: var(--nmd-color3)
    }

    a:visited {
        color: var(--nmd-color2)
    }

    a:hover {
        color: var(--nmd-color4)
    }
}

code {
    font-size: 90%
}

span.command {
    font-size: 90%;
    font-family: monospace
}

em {
    font-style: italic
}

strong {
    font-weight: bold
}

pre {
    background: #F9FAFB;
    margin: 2rem 16px;
    padding: 10px;
    border: 1px solid #E5E7EB;
    border-radius: 4px;
    box-shadow: 4px 4px 8px #E5E7EB;
    font-size: 90%;
    margin-bottom: 1.5rem;
    padding: 6px;
    overflow: auto
}

@media (prefers-color-scheme: dark) {
    pre {
        background: #1F2937;
        border-color: black;
        box-shadow: 4px 4px 8px black
    }
}

pre span img {
    user-select: none
}

pre:has(code) {
    padding: 0
}

td,
th {
    padding: 2px 5px
}

td:first-child,
th:first-child {
    padding-left: 0
}

td:last-child,
th:last-child {
    padding-right: 0
}

dt {
    margin: 1.2rem 0 .8rem
}

dd {
    margin-left: 2rem
}

ul {
    margin: .9rem 0;
    padding-left: 30px;
    list-style: disc
}

ul:first-child {
    margin-top: 0
}

ul:last-child {
    margin-bottom: 0
}

ol {
    margin: .9rem 0;
    padding-left: 30px;
    list-style: decimal
}

ol:first-child {
    margin-top: 0
}

ol:last-child {
    margin-bottom: 0
}

li {
    margin: .9rem 0;
    padding-left: 5px
}

li:first-child {
    margin-top: 0
}

li:last-child {
    margin-bottom: 0
}

.navheader hr,
.navfooter hr {
    margin: 1rem 0;
    background: #E5E7EB
}

@media (prefers-color-scheme: dark) {

    .navheader hr,
    .navfooter hr {
        background: #4B5563
    }
}

.navheader a,
.navfooter a {
    text-decoration: none
}

div.titlepage {
    margin: 40px 0
}

div.titlepage hr {
    display: none
}

div.toc {
    background: #F9FAFB;
    margin: 2rem 16px;
    padding: 10px;
    border: 1px solid #E5E7EB;
    border-radius: 4px;
    box-shadow: 4px 4px 8px #E5E7EB
}

@media (prefers-color-scheme: dark) {
    div.toc {
        background: #1F2937;
        border-color: black;
        box-shadow: 4px 4px 8px black
    }
}

div.toc a {
    text-decoration: none
}

div.note,
div.warning {
    background: #F9FAFB;
    margin: 2rem 16px;
    padding: 10px;
    border: 1px solid #E5E7EB;
    border-radius: 4px;
    box-shadow: 4px 4px 8px #E5E7EB;
    font-style: italic
}

@media (prefers-color-scheme: dark) {

    div.note,
    div.warning {
        background: #1F2937;
        border-color: black;
        box-shadow: 4px 4px 8px black
    }
}

div.note h3,
div.warning h3 {
    float: right;
    margin: 0 0 1rem 1rem;
    width: 42px;
    height: 42px;
    content: url()
}

div.note h3+p,
div.warning h3+p {
    margin-top: 0
}

div.note h3 {
    background-color: var(--nmd-color-info);
    mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='42' height='42' viewBox='0 0 24 24' stroke-width='2' stroke='black' fill='none' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath stroke='none' d='M0 0h24v24H0z' fill='none'%3E%3C/path%3E%3Cpath d='M12 8h.01'%3E%3C/path%3E%3Cpath d='M11 12h1v4h1'%3E%3C/path%3E%3Cpath d='M12 3c7.2 0 9 1.8 9 9s-1.8 9 -9 9s-9 -1.8 -9 -9s1.8 -9 9 -9z'%3E%3C/path%3E%3C/svg%3E");
    -webkit-mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='42' height='42' viewBox='0 0 24 24' stroke-width='2' stroke='black' fill='none' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath stroke='none' d='M0 0h24v24H0z' fill='none'%3E%3C/path%3E%3Cpath d='M12 8h.01'%3E%3C/path%3E%3Cpath d='M11 12h1v4h1'%3E%3C/path%3E%3Cpath d='M12 3c7.2 0 9 1.8 9 9s-1.8 9 -9 9s-9 -1.8 -9 -9s1.8 -9 9 -9z'%3E%3C/path%3E%3C/svg%3E")
}

div.warning h3 {
    background-color: var(--nmd-color-warn);
    mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='42' height='42' viewBox='0 0 24 24' stroke-width='2' stroke='black' fill='none' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath stroke='none' d='M0 0h24v24H0z' fill='none'%3E%3C/path%3E%3Cpath d='M12 9v2m0 4v.01'%3E%3C/path%3E%3Cpath d='M5 19h14a2 2 0 0 0 1.84 -2.75l-7.1 -12.25a2 2 0 0 0 -3.5 0l-7.1 12.25a2 2 0 0 0 1.75 2.75'%3E%3C/path%3E%3C/svg%3E");
    -webkit-mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='42' height='42' viewBox='0 0 24 24' stroke-width='2' stroke='black' fill='none' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath stroke='none' d='M0 0h24v24H0z' fill='none'%3E%3C/path%3E%3Cpath d='M12 9v2m0 4v.01'%3E%3C/path%3E%3Cpath d='M5 19h14a2 2 0 0 0 1.84 -2.75l-7.1 -12.25a2 2 0 0 0 -3.5 0l-7.1 12.25a2 2 0 0 0 1.75 2.75'%3E%3C/path%3E%3C/svg%3E")
}

.term {
    font-weight: 300
}

.docbook .xref img[src^=images\/callouts\/],
.screen img,
.programlisting img {
    width: 1em
}

.calloutlist img {
    width: 1.3em
}

.programlisting.language-shell .hljs-meta.prompt_ {
    user-select: none
}

/*!
  Theme: Tomorrow
  Author: Chris Kempson (http://chriskempson.com)
  License: ~ MIT (or more permissive) [via base16-schemes-source]
  Maintainer: @highlightjs/core-team
  Version: 2021.09.0
*/
pre code.hljs {
    display: block;
    overflow-x: auto;
    padding: 1em
}

code.hljs {
    padding: 3px 5px
}

.hljs {
    color: #4d4d4c;
    background: #fff
}

.hljs ::selection,
.hljs::selection {
    background-color: #d6d6d6;
    color: #4d4d4c
}

.hljs-comment {
    color: #8e908c
}

.hljs-tag {
    color: #969896
}

.hljs-operator,
.hljs-punctuation,
.hljs-subst {
    color: #4d4d4c
}

.hljs-operator {
    opacity: .7
}

.hljs-bullet,
.hljs-deletion,
.hljs-name,
.hljs-selector-tag,
.hljs-template-variable,
.hljs-variable {
    color: #c82829
}

.hljs-attr,
.hljs-link,
.hljs-literal,
.hljs-number,
.hljs-symbol,
.hljs-variable.constant_ {
    color: #f5871f
}

.hljs-class .hljs-title,
.hljs-title,
.hljs-title.class_ {
    color: #eab700
}

.hljs-strong {
    font-weight: 700;
    color: #eab700
}

.hljs-addition,
.hljs-code,
.hljs-string,
.hljs-title.class_.inherited__ {
    color: #718c00
}

.hljs-built_in,
.hljs-doctag,
.hljs-keyword.hljs-atrule,
.hljs-quote,
.hljs-regexp {
    color: #3e999f
}

.hljs-attribute,
.hljs-function .hljs-title,
.hljs-section,
.hljs-title.function_,
.ruby .hljs-property {
    color: #4271ae
}

.diff .hljs-meta,
.hljs-keyword,
.hljs-template-tag,
.hljs-type {
    color: #8959a8
}

.hljs-emphasis {
    color: #8959a8;
    font-style: italic
}

.hljs-meta,
.hljs-meta .hljs-keyword,
.hljs-meta .hljs-string {
    color: #a3685a
}

.hljs-meta .hljs-keyword,
.hljs-meta-keyword {
    font-weight: 700
}

@media (prefers-color-scheme: dark) {

    /*!  Theme: Tomorrow Night  Author: Chris Kempson (http://chriskempson.com)  License: ~ MIT (or more permissive) [via base16-schemes-source]  Maintainer: @highlightjs/core-team  Version: 2021.09.0*/
    pre code.hljs {
        display: block;
        overflow-x: auto;
        padding: 1em
    }

    code.hljs {
        padding: 3px 5px
    }

    .hljs {
        color: #ccc;
        background: #2d2d2d
    }

    .hljs ::selection,
    .hljs::selection {
        background-color: #515151;
        color: #ccc
    }

    .hljs-comment {
        color: #999
    }

    .hljs-tag {
        color: #b4b7b4
    }

    .hljs-operator,
    .hljs-punctuation,
    .hljs-subst {
        color: #ccc
    }

    .hljs-operator {
        opacity: .7
    }

    .hljs-bullet,
    .hljs-deletion,
    .hljs-name,
    .hljs-selector-tag,
    .hljs-template-variable,
    .hljs-variable {
        color: #f2777a
    }

    .hljs-attr,
    .hljs-link,
    .hljs-literal,
    .hljs-number,
    .hljs-symbol,
    .hljs-variable.constant_ {
        color: #f99157
    }

    .hljs-class .hljs-title,
    .hljs-title,
    .hljs-title.class_ {
        color: #fc6
    }

    .hljs-strong {
        font-weight: 700;
        color: #fc6
    }

    .hljs-addition,
    .hljs-code,
    .hljs-string,
    .hljs-title.class_.inherited__ {
        color: #9c9
    }

    .hljs-built_in,
    .hljs-doctag,
    .hljs-keyword.hljs-atrule,
    .hljs-quote,
    .hljs-regexp {
        color: #6cc
    }

    .hljs-attribute,
    .hljs-function .hljs-title,
    .hljs-section,
    .hljs-title.function_,
    .ruby .hljs-property {
        color: #69c
    }

    .diff .hljs-meta,
    .hljs-keyword,
    .hljs-template-tag,
    .hljs-type {
        color: #c9c
    }

    .hljs-emphasis {
        color: #c9c;
        font-style: italic
    }

    .hljs-meta,
    .hljs-meta .hljs-keyword,
    .hljs-meta .hljs-string {
        color: #a3685a
    }

    .hljs-meta .hljs-keyword,
    .hljs-meta-keyword {
        font-weight: 700
    }
}
</file>

<file path="docs/default.nix">
{ pkgs, lib, ... }:
let
  dontCheckModules = {
    _module.check = false;
  };
  modules = [
    ../modules
    dontCheckModules
  ];

  githubDeclaration = user: repo: branch: subpath: {
    url = "https://github.com/${user}/${repo}/blob/${branch}/${subpath}";
    name = "<${repo}/${subpath}>";
  };

  pmPath = toString ./..;
  transformOptions =
    opt:
    opt
    // {
      declarations = (
        map (
          decl:
          if (lib.hasPrefix pmPath (toString decl)) then
            (githubDeclaration "nix-community" "plasma-manager" "trunk" (
              lib.removePrefix "/" (lib.removePrefix pmPath (toString decl))
            ))
          else
            decl
        ) opt.declarations
      );
    };

  buildOptionsDocs = (
    args@{ modules, ... }:
    let
      opts =
        (lib.evalModules {
          inherit modules;
          class = "homeManager";
        }).options;
      options = builtins.removeAttrs opts [ "_module" ];
    in
    pkgs.buildPackages.nixosOptionsDoc {
      inherit options;
      inherit transformOptions;
      warningsAreErrors = false;
    }
  );

  pmOptionsDoc = buildOptionsDocs { inherit modules; };
  plasma-manager-options = pkgs.callPackage ./plasma-manager-options.nix {
    nixos-render-docs = pkgs.nixos-render-docs;
    plasma-manager-options = pmOptionsDoc.optionsJSON;
    revision = "latest";
  };
in
{
  html = plasma-manager-options;
  json = pmOptionsDoc.optionsJSON;
}
</file>

<file path="docs/plasma-manager-options.nix">
{
  stdenv,
  nixos-render-docs,
  plasma-manager-options,
  revision,
  lib,
  documentation-highlighter,
}:
let
  outputPath = "share/doc/plasma-manager";
in
stdenv.mkDerivation {
  name = "plasma-manager-options";

  nativeBuildInputs = [ nixos-render-docs ];

  src = ./manual;

  buildPhase = ''
    mkdir -p out/highlightjs

    cp -t out/highlightjs \
      ${documentation-highlighter}/highlight.pack.js \
      ${documentation-highlighter}/LICENSE \
      ${documentation-highlighter}/mono-blue.css \
      ${documentation-highlighter}/loader.js

    cp ${./static/style.css} out/style.css

    substituteInPlace options.md \
      --replace-fail \
      '@OPTIONS_JSON@' \
      ${plasma-manager-options}/share/doc/nixos/options.json

    substituteInPlace manual.md \
      --replace-fail \
      '@VERSION@' \
      ${revision}

    nixos-render-docs manual html \
      --manpage-urls ./manpage-urls.json \
      --revision ${lib.trivial.revisionWithDefault revision} \
      --style style.css \
      --script highlightjs/highlight.pack.js \
      --script highlightjs/loader.js \
      --toc-depth 1 \
      --section-toc-depth 1 \
      manual.md \
      out/index.xhtml
  '';

  installPhase = ''
    dest="$out/${outputPath}"
    mkdir -p "$(dirname "$dest")"
    mv out "$dest"
  '';
}
</file>

<file path="examples/homeManager/home.nix">
{ pkgs, ... }:

{
  imports = [ <plasma-manager/modules> ];

  programs.plasma = {
    enable = true;

    #
    # Some high-level settings:
    #
    workspace = {
      clickItemTo = "select";
      lookAndFeel = "org.kde.breezedark.desktop";
      cursor.theme = "Bibata-Modern-Ice";
      iconTheme = "Papirus-Dark";
      wallpaper = "${pkgs.kdePackages.plasma-workspace-wallpapers}/share/wallpapers/Patak/contents/images/1080x1920.png";
    };

    hotkeys.commands."launch-konsole" = {
      name = "Launch Konsole";
      key = "Meta+Alt+K";
      command = "konsole";
    };

    panels = [
      # Windows-like panel at the bottom
      {
        location = "bottom";
        widgets = [
          "org.kde.plasma.kickoff"
          "org.kde.plasma.icontasks"
          "org.kde.plasma.marginsseparator"
          "org.kde.plasma.systemtray"
          "org.kde.plasma.digitalclock"
        ];
      }
      # Global menu at the top
      {
        location = "top";
        height = 26;
        widgets = [ "org.kde.plasma.appmenu" ];
      }
    ];

    #
    # Some mid-level settings:
    #
    shortcuts = {
      ksmserver = {
        "Lock Session" = [
          "Screensaver"
          "Meta+Ctrl+Alt+L"
        ];
      };

      kwin = {
        "Expose" = "Meta+,";
        "Switch Window Down" = "Meta+J";
        "Switch Window Left" = "Meta+H";
        "Switch Window Right" = "Meta+L";
        "Switch Window Up" = "Meta+K";
      };
    };

    #
    # Some low-level settings:
    #
    configFile = {
      "baloofilerc"."Basic Settings"."Indexing-Enabled" = false;
      "kwinrc"."org.kde.kdecoration2"."ButtonsOnLeft" = "SF";
      "kwinrc"."Desktops"."Number" = {
        value = 8;
        # Forces kde to not change this value (even through the settings app).
        immutable = true;
      };
    };
  };
}
</file>

<file path="examples/homeManager/README.md">
## Getting Started

Add this repository as a channel:

```nix
$ nix-channel --add https://github.com/nix-community/plasma-manager/archive/trunk.tar.gz plasma-manager
```

Update / unpack the channel:

```nix
$ nix-channel --update plasma-manager
```

Add to your configuration file, for example `~/.config/home-manager/plasma.nix`:

```nix
{ pkgs, ...}:
{
  imports = [
    <plasma-manager/modules>
  ];

  programs = {
    plasma = {
      enable = true;
      # etc.
    };
  };
}
```
</file>

<file path="examples/homeManagerFlake/flake.nix">
{
  description = "Plasma Manager Example with standalone home-manager flake";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
    home-manager = {
      url = "github:nix-community/home-manager";
      inputs.nixpkgs.follows = "nixpkgs";
    };
    plasma-manager = {
      url = "github:nix-community/plasma-manager";
      inputs.nixpkgs.follows = "nixpkgs";
      inputs.home-manager.follows = "home-manager";
    };
  };

  outputs =
    inputs@{
      nixpkgs,
      home-manager,
      plasma-manager,
      ...
    }:
    let
      # Replace with your username
      username = "jdoe";

      # Replace with the fitting architecture
      system = "x86_64-linux";
    in
    {
      # Replace `standAloneConfig` with the name of your configuration (your `username` or `"username@hostname"`)
      homeConfigurations.standAloneConfig = home-manager.lib.homeManagerConfiguration {
        pkgs = import nixpkgs { inherit system; };

        modules = [
          inputs.plasma-manager.homeManagerModules.plasma-manager

          # Specify the path to your home configuration here:
          ../home.nix

          {
            home = {
              inherit username;
              homeDirectory = "/home/${username}";
            };
          }
        ];
      };
    };
}
</file>

<file path="examples/systemFlake/flake.nix">
{
  description = "Plasma Manager Example with system configuration flake";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
    home-manager = {
      url = "github:nix-community/home-manager";
      inputs.nixpkgs.follows = "nixpkgs";
    };
    plasma-manager = {
      url = "github:nix-community/plasma-manager";
      inputs.nixpkgs.follows = "nixpkgs";
      inputs.home-manager.follows = "home-manager";
    };
  };

  outputs =
    inputs@{
      nixpkgs,
      home-manager,
      plasma-manager,
      ...
    }:
    let
      # Replace with your username
      username = "jdoe";

      # Replace with the fitting architecture
      system = "x86_64-linux";
    in
    {
      # Replace `moduleConfig` with the name of you configuration
      nixosConfigurations.moduleConfig = nixpkgs.lib.nixosSystem {
        inherit system;

        modules = [
          # We include the system-configuration here as well. Replace this with
          # your own configuration or import your configuration.nix. The demo
          # here is just the bare minimum to get the flake to not fail.
          {
            system.stateVersion = "23.11";
            users.users."${username}".isNormalUser = true;
            fileSystems."/".device = "/dev/sda";
            boot.loader.grub.devices = [ "/dev/sda" ];
          }

          home-manager.nixosModules.home-manager
          {
            home-manager.useGlobalPkgs = true;
            home-manager.useUserPackages = true;
            home-manager.sharedModules = [ plasma-manager.homeManagerModules.plasma-manager ];

            # This should point to your home.nix path of course. For an example
            # of this see ./home.nix in this directory.
            home-manager.users."${username}" = import ../home.nix;
          }
        ];
      };
    };
}
</file>

<file path="examples/.gitignore">
*/flake.lock
</file>

<file path="examples/home.nix">
{ pkgs, ... }:
{
  home.stateVersion = "23.11";

  programs.plasma = {
    enable = true;

    #
    # Some high-level settings:
    #
    workspace = {
      clickItemTo = "open"; # If you liked the click-to-open default from plasma 5
      lookAndFeel = "org.kde.breezedark.desktop";
      cursor = {
        theme = "Bibata-Modern-Ice";
        size = 32;
      };
      iconTheme = "Papirus-Dark";
      wallpaper = "${pkgs.kdePackages.plasma-workspace-wallpapers}/share/wallpapers/Patak/contents/images/1080x1920.png";
    };

    hotkeys.commands."launch-konsole" = {
      name = "Launch Konsole";
      key = "Meta+Alt+K";
      command = "konsole";
    };

    fonts = {
      general = {
        family = "JetBrains Mono";
        pointSize = 12;
      };
    };

    desktop.widgets = [
      {
        plasmusicToolbar = {
          position = {
            horizontal = 51;
            vertical = 100;
          };
          size = {
            width = 250;
            height = 250;
          };
        };
      }
    ];

    panels = [
      # Windows-like panel at the bottom
      {
        location = "bottom";
        widgets = [
          # We can configure the widgets by adding the name and config
          # attributes. For example to add the the kickoff widget and set the
          # icon to "nix-snowflake-white" use the below configuration. This will
          # add the "icon" key to the "General" group for the widget in
          # ~/.config/plasma-org.kde.plasma.desktop-appletsrc.
          {
            name = "org.kde.plasma.kickoff";
            config = {
              General = {
                icon = "nix-snowflake-white";
                alphaSort = true;
              };
            };
          }
          # Or you can configure the widgets by adding the widget-specific options for it.
          # See modules/widgets for supported widgets and options for these widgets.
          # For example:
          {
            kickoff = {
              sortAlphabetically = true;
              icon = "nix-snowflake-white";
            };
          }
          # Adding configuration to the widgets can also for example be used to
          # pin apps to the task-manager, which this example illustrates by
          # pinning dolphin and konsole to the task-manager by default with widget-specific options.
          {
            iconTasks = {
              launchers = [
                "applications:org.kde.dolphin.desktop"
                "applications:org.kde.konsole.desktop"
              ];
            };
          }
          # Or you can do it manually, for example:
          {
            name = "org.kde.plasma.icontasks";
            config = {
              General = {
                launchers = [
                  "applications:org.kde.dolphin.desktop"
                  "applications:org.kde.konsole.desktop"
                ];
              };
            };
          }
          # If no configuration is needed, specifying only the name of the
          # widget will add them with the default configuration.
          "org.kde.plasma.marginsseparator"
          # If you need configuration for your widget, instead of specifying the
          # the keys and values directly using the config attribute as shown
          # above, plasma-manager also provides some higher-level interfaces for
          # configuring the widgets. See modules/widgets for supported widgets
          # and options for these widgets. The widgets below shows two examples
          # of usage, one where we add a digital clock, setting 12h time and
          # first day of the week to Sunday and another adding a systray with
          # some modifications in which entries to show.
          {
            digitalClock = {
              calendar.firstDayOfWeek = "sunday";
              time.format = "12h";
            };
          }
          {
            systemTray.items = {
              # We explicitly show bluetooth and battery
              shown = [
                "org.kde.plasma.battery"
                "org.kde.plasma.bluetooth"
              ];
              # And explicitly hide networkmanagement and volume
              hidden = [
                "org.kde.plasma.networkmanagement"
                "org.kde.plasma.volume"
              ];
            };
          }
        ];
        hiding = "autohide";
      }
      # Application name, Global menu and Song information and playback controls at the top
      {
        location = "top";
        height = 26;
        widgets = [
          {
            applicationTitleBar = {
              behavior = {
                activeTaskSource = "activeTask";
              };
              layout = {
                elements = [ "windowTitle" ];
                horizontalAlignment = "left";
                showDisabledElements = "deactivated";
                verticalAlignment = "center";
              };
              overrideForMaximized.enable = false;
              titleReplacements = [
                {
                  type = "regexp";
                  originalTitle = "^Brave Web Browser$";
                  newTitle = "Brave";
                }
                {
                  type = "regexp";
                  originalTitle = ''\\bDolphin\\b'';
                  newTitle = "File manager";
                }
              ];
              windowTitle = {
                font = {
                  bold = false;
                  fit = "fixedSize";
                  size = 12;
                };
                hideEmptyTitle = true;
                margins = {
                  bottom = 0;
                  left = 10;
                  right = 5;
                  top = 0;
                };
                source = "appName";
              };
            };
          }
          "org.kde.plasma.appmenu"
          "org.kde.plasma.panelspacer"
          {
            plasmusicToolbar = {
              panelIcon = {
                albumCover = {
                  useAsIcon = false;
                  radius = 8;
                };
                icon = "view-media-track";
              };
              playbackSource = "auto";
              musicControls.showPlaybackControls = true;
              songText = {
                displayInSeparateLines = true;
                maximumWidth = 640;
                scrolling = {
                  behavior = "alwaysScroll";
                  speed = 3;
                };
              };
            };
          }
        ];
      }
    ];

    window-rules = [
      {
        description = "Dolphin";
        match = {
          window-class = {
            value = "dolphin";
            type = "substring";
          };
          window-types = [ "normal" ];
        };
        apply = {
          noborder = {
            value = true;
            apply = "force";
          };
          # `apply` defaults to "apply-initially"
          maximizehoriz = true;
          maximizevert = true;
        };
      }
    ];

    powerdevil = {
      AC = {
        powerButtonAction = "lockScreen";
        autoSuspend = {
          action = "shutDown";
          idleTimeout = 1000;
        };
        turnOffDisplay = {
          idleTimeout = 1000;
          idleTimeoutWhenLocked = "immediately";
        };
      };
      battery = {
        powerButtonAction = "sleep";
        whenSleepingEnter = "standbyThenHibernate";
      };
      lowBattery = {
        whenLaptopLidClosed = "hibernate";
      };
    };

    kwin = {
      edgeBarrier = 0; # Disables the edge-barriers introduced in plasma 6.1
      cornerBarrier = false;

      scripts.polonium.enable = true;
    };

    kscreenlocker = {
      lockOnResume = true;
      timeout = 10;
    };

    #
    # Some mid-level settings:
    #
    shortcuts = {
      ksmserver = {
        "Lock Session" = [
          "Screensaver"
          "Meta+Ctrl+Alt+L"
        ];
      };

      kwin = {
        "Expose" = "Meta+,";
        "Switch Window Down" = "Meta+J";
        "Switch Window Left" = "Meta+H";
        "Switch Window Right" = "Meta+L";
        "Switch Window Up" = "Meta+K";
      };
    };

    #
    # Some low-level settings:
    #
    configFile = {
      baloofilerc."Basic Settings"."Indexing-Enabled" = false;
      kwinrc."org.kde.kdecoration2".ButtonsOnLeft = "SF";
      kwinrc.Desktops.Number = {
        value = 8;
        # Forces kde to not change this value (even through the settings app).
        immutable = true;
      };
      kscreenlockerrc = {
        Greeter.WallpaperPlugin = "org.kde.potd";
        # To use nested groups use / as a separator. In the below example,
        # Provider will be added to [Greeter][Wallpaper][org.kde.potd][General].
        "Greeter/Wallpaper/org.kde.potd/General".Provider = "bing";
      };
    };
  };
}
</file>

<file path="lib/colorscheme.nix">
{ lib, ... }:
let
  colorEffectsKeys = [
    "ChangeSelectionColor"
    "Color"
    "ColorAmount"
    "ColorEffect"
    "ContrastAmount"
    "ContrastEffect"
    "Enable"
    "IntensityAmount"
    "IntensityEffect"
  ];
  colorUIKeys = [
    "BackgroundAlternate"
    "BackgroundNormal"
    "DecorationFocus"
    "DecorationHover"
    "ForegroundActive"
    "ForegroundInactive"
    "ForegroundLink"
    "ForegroundNegative"
    "ForegroundNeutral"
    "ForegroundNormal"
    "ForegroundVisited"
    "regroundPositive"
  ];
  ignoreKeys = {
    "ColorEffects:Disabled" = colorEffectsKeys;
    "ColorEffects:Inactive" = colorEffectsKeys;
    "Colors:Button" = colorUIKeys;
    "Colors:Selection" = colorUIKeys;
    "Colors:Tooltip" = colorUIKeys;
    "Colors:View" = colorUIKeys;
    "Colors:Window" = colorUIKeys;
  };
in
(lib.mkMerge (
  lib.mapAttrsToList (group: keys: {
    "kdeglobals"."${group}" = (
      lib.mkMerge (map (key: { "${key}"."persistent" = (lib.mkDefault true); }) keys)
    );
  }) ignoreKeys
))
</file>

<file path="lib/panel.nix">
{ lib, config, ... }:
let
  widgets = (import ../modules/widgets { inherit lib; });
  panelToLayout =
    panel:
    let
      inherit (widgets.lib) addWidgetStmts stringIfNotNull;
      inherit (lib) boolToString;
      inherit (builtins) toString;

      plasma6OnlyCmd = cmd: ''
        if (isPlasma6) {
          ${cmd}
        }
      '';
    in
    ''
      ${
        if (panel.screen == "all") then
          "for (screenID = 0; screenID < screenCount; screenID++)"
        else if (builtins.isList panel.screen) then
          "for (var screenID in [${builtins.concatStringsSep "," (map builtins.toString panel.screen)}])"
        else
          ""
      }
      {
        const panel = new Panel();
        panel.height = ${toString panel.height};
        panel.floating = ${boolToString panel.floating};
        ${stringIfNotNull panel.alignment ''panel.alignment = "${panel.alignment}";''}
        ${stringIfNotNull panel.hiding ''panel.hiding = "${panel.hiding}";''}
        ${stringIfNotNull panel.location ''panel.location = "${panel.location}";''}
        ${stringIfNotNull panel.lengthMode (plasma6OnlyCmd ''panel.lengthMode = "${panel.lengthMode}";'')}
        ${stringIfNotNull panel.maxLength "panel.maximumLength = ${toString panel.maxLength};"}
        ${stringIfNotNull panel.minLength "panel.minimumLength = ${toString panel.minLength};"}
        ${stringIfNotNull panel.offset "panel.offset = ${toString panel.offset};"}
        ${stringIfNotNull panel.opacity ''panel.opacity = "${panel.opacity}";''}
        ${stringIfNotNull panel.screen ''panel.writeConfig("lastScreen[$i]", ${if ((panel.screen == "all") || (builtins.isList panel.screen)) then "screenID" else toString panel.screen});''}

        ${addWidgetStmts "panel" "panelWidgets" panel.widgets}
        ${stringIfNotNull panel.extraSettings panel.extraSettings}
      }
    '';
in
''
  // Removes all existing panels
  panels().forEach((panel) => panel.remove());

  const isPlasma6 = applicationVersion.split(".")[0] == 6;

  // Adds the panels
  ${lib.concatMapStringsSep "\n" panelToLayout config.programs.plasma.panels}
''
</file>

<file path="lib/qfont.nix">
{ lib, ... }:
let
  #=== ENUMS ===
  enums = {
    # QFont::StyleHint
    styleHint = rec {
      anyStyle = 5;
      sansSerif = helvetica;
      helvetica = 0;
      serif = times;
      times = 1;
      typewriter = courier;
      courier = 2;
      oldEnglish = 3;
      decorative = oldEnglish;
      monospace = 7;
      fantasy = 8;
      cursive = 6;
      system = 4;
    };

    # QFont::Weight
    weight = {
      thin = 100;
      extraLight = 200;
      light = 300;
      normal = 400;
      medium = 500;
      demiBold = 600;
      bold = 700;
      extraBold = 800;
      black = 900;
    };

    # QFont::Style
    style = {
      normal = 0;
      italic = 1;
      oblique = 2;
    };

    # QFont::Capitalization
    capitalization = {
      mixedCase = 0;
      allUppercase = 1;
      allLowercase = 2;
      smallCaps = 3;
      capitalize = 4;
    };

    # QFont::SpacingType
    spacingType = {
      percentage = 0;
      absolute = 1;
    };

    # QFont::Stretch
    stretch = {
      anyStretch = 0;
      ultraCondensed = 50;
      extraCondensed = 62;
      condensed = 75;
      semiCondensed = 87;
      unstretched = 100;
      semiExpanded = 112;
      expanded = 125;
      extraExpanded = 150;
      ultraExpanded = 200;
    };

    # QFont::StyleStrategy
    # This one's... special.
    styleStrategy = {
      prefer = {
        default = 1;
        bitmap = 2;
        device = 4;
        outline = 8;
        forceOutline = 16;
      };
      matchingPrefer = {
        default = 0;
        exact = 32;
        quality = 64;
      };
      antialiasing = {
        default = 0;
        prefer = 128;
        disable = 256;
      };
      noSubpixelAntialias = 2048;
      preferNoShaping = 4096;
      noFontMerging = 32768;
    };
  };

  inherit (builtins)
    attrNames
    mapAttrs
    removeAttrs
    isAttrs
    ;
  inherit (lib) filterAttrs;

  toEnums = v: lib.types.enum (attrNames v);
in
mapAttrs (_: toEnums) (removeAttrs enums [ "styleStrategy" ])
// {
  styleStrategy = mapAttrs (_: toEnums) (filterAttrs (_: isAttrs) enums.styleStrategy);

  # Converts a font specified by the given attrset to a string representation compatible with
  # QFont::fromString and QFont::toString.
  fontToString =
    {
      family,
      pointSize ? null,
      pixelSize ? null,
      styleHint ? "anyStyle",
      weight ? "normal",
      style ? "normal",
      underline ? false,
      strikeOut ? false,
      fixedPitch ? false,
      capitalization ? "mixedCase",
      letterSpacingType ? "percentage",
      letterSpacing ? 0,
      wordSpacing ? 0,
      stretch ? "anyStretch",
      styleStrategy ? { },
      styleName ? null,
    }:
    let
      inherit (builtins)
        isString
        toString
        foldl'
        bitOr
        ;

      styleStrategy' =
        let
          match = s: enums.styleStrategy.${s}.${styleStrategy.${s} or "default"};
          ifSet = k: if styleStrategy.${k} or false then enums.styleStrategy.${k} else 0;
        in
        foldl' bitOr 0 [
          (match "prefer")
          (match "matchingPrefer")
          (match "antialiasing")
          (ifSet "noSubpixelAntialias")
          (ifSet "preferNoShaping")
          (ifSet "noFontMerging")
        ];

      sizeToString = s: if s == null then "-1" else toString s;

      numOrEnum = attrs: s: if isString s then toString attrs.${s} else toString s;

      zeroOrOne = b: if b then "1" else "0";
    in
    assert lib.assertMsg (lib.xor (pointSize != null) (
      pixelSize != null
    )) "Exactly one of `pointSize` and `pixelSize` has to be set.";
    builtins.concatStringsSep "," (
      [
        family
        (sizeToString pointSize)
        (sizeToString pixelSize)
        (toString enums.styleHint.${styleHint})
        (numOrEnum enums.weight weight)
        (numOrEnum enums.style style)
        (zeroOrOne underline)
        (zeroOrOne strikeOut)
        (zeroOrOne fixedPitch)
        "0"
        (toString enums.capitalization.${capitalization})
        (toString enums.spacingType.${letterSpacingType})
        (toString letterSpacing)
        (toString wordSpacing)
        (numOrEnum enums.stretch stretch)
        (toString styleStrategy')
      ]
      ++ lib.optional (styleName != null) styleName
    );
}
</file>

<file path="lib/types.nix">
{ lib, config, ... }:
let
  ##############################################################################
  # Types for storing settings.
  basicSettingsType = (
    with lib.types;
    nullOr (oneOf [
      bool
      float
      int
      str
    ])
  );
  advancedSettingsType = (
    with lib.types;
    submodule {
      options = {
        value = lib.mkOption {
          type = basicSettingsType;
          default = null;
          description = "The value for some key.";
        };
        immutable = lib.mkOption {
          type = bool;
          default = config.programs.plasma.immutableByDefault;
          description = ''
            Whether to make the key immutable. This corresponds to adding [$i] to
            the end of the key.
          '';
        };
        shellExpand = lib.mkOption {
          type = bool;
          default = false;
          description = ''
            Whether to mark the key for shell expansion. This corresponds to
            adding [$e] to the end of the key.
          '';
        };
        persistent = lib.mkOption {
          type = bool;
          default = false;
          description = ''
            When overrideConfig is enabled and the key is persistent,
            plasma-manager will leave it unchanged after activation.
          '';
        };
        escapeValue = lib.mkOption {
          type = bool;
          default = true;
          description = ''
            Whether to escape the value according to kde's escape-format. See:
            https://invent.kde.org/frameworks/kconfig/-/blob/v6.7.0/src/core/kconfigini.cpp?ref_type=tags#L880-945
            for info about this format.
          '';
        };
      };
    }
  );
  coercedSettingsType =
    with lib.types;
    coercedTo basicSettingsType (value: { inherit value; }) advancedSettingsType;
in
{
  inherit basicSettingsType;
  inherit advancedSettingsType;
  inherit coercedSettingsType;
}
</file>

<file path="lib/wallpapers.nix">
{ lib, ... }:
{
  wallpaperPictureOfTheDayType =
    with lib.types;
    submodule {
      options = {
        provider = lib.mkOption {
          type = nullOr (enum [
            "apod"
            "bing"
            "flickr"
            "natgeo"
            "noaa"
            "wcpotd"
            "epod"
            "simonstalenhag"
          ]);
          description = "The provider for the Picture of the Day plugin.";
        };
        updateOverMeteredConnection = lib.mkOption {
          type = bool;
          default = false;
          description = "Whether to update the wallpaper on a metered connection.";
        };
      };
    };

  wallpaperSlideShowType =
    with lib.types;
    submodule {
      options = {
        path = lib.mkOption {
          type = either path (listOf path);
          description = "The path(s) where the wallpapers are located.";
        };
        interval = lib.mkOption {
          type = int;
          default = 300;
          description = "The length between wallpaper switches.";
        };
      };
    };

  # Values are taken from
  #  https://invent.kde.org/plasma/kdeplasma-addons/-/blob/bc53d651cf60709396c9229f8c582ec8a9d2ee53/applets/mediaframe/package/contents/ui/ConfigGeneral.qml#L148-170
  wallpaperFillModeTypes = {
    "stretch" = 0; # a.k.a. Scaled
    "preserveAspectFit" = 1; # a.k.a. Scaled Keep Proportions
    "preserveAspectCrop" = 2; # a.k.a. Scaled And Cropped
    "tile" = 3;
    "tileVertically" = 4;
    "tileHorizontally" = 5;
    "pad" = 6; # a.k.a. Centered
  };
}
</file>

<file path="lib/writeconfig.nix">
{ pkgs, config, ... }:

let
  writeConfigScript = pkgs.writeShellApplication {
    name = "write_config";
    runtimeInputs = with pkgs; [ python3 ];
    text = ''python ${../script/write_config.py} "$@"'';
  };

  ##############################################################################
  # Generate a command to run the config-writer script by first sending in the
  # attribute-set as json. Here a is the attribute-set.
  #
  # Type: AttrSet -> string
  writeConfig =
    json: overrideConfig: resetFilesList:
    let
      jsonStr = builtins.toJSON json;
      # Writing to file handles special characters better than passing it in as
      # an argument to the script.
      jsonFile = pkgs.writeText "data.json" jsonStr;
      resetFilesStr = builtins.toString (
        if overrideConfig then
          resetFilesList ++ [ "${config.xdg.dataHome}/plasma-manager/last_run_*" ]
        else
          resetFilesList
      );
      immutableByDefault = (builtins.toString config.programs.plasma.immutableByDefault);
    in
    ''
      ${writeConfigScript}/bin/write_config ${jsonFile} "${resetFilesStr}" "${immutableByDefault}"
    '';
in
{
  inherit writeConfig;
}
</file>

<file path="modules/apps/kate/check-theme-name-free.sh">
# there could be a bash shebang to ${pkgs.bash}/bin/bash here

# https://stackoverflow.com/questions/5947742/how-to-change-the-output-color-of-echo-in-linux/5947802#5947802
RED='\033[0;31m'

# https://stackoverflow.com/questions/2924697/how-does-one-output-bold-text-in-bash/2924755#2924755
BOLD=$(tput bold)
NORMAL=$(tput sgr0)


# # =====================================
# #     CHECK THE NUMBER OF ARGS
# #
# # https://www.baeldung.com/linux/bash-check-script-arguments

if [[ "$#" -ne 1 ]]; then
  # https://stackoverflow.com/questions/3005963/how-can-i-have-a-newline-in-a-string-in-sh/3182519#3182519
  >&2 printf "%sIncorrect number of arguments.%s Expected one: The name of the theme that should not already be in use" "${RED}${BOLD}" "${NORMAL}${RED}"
  exit 1
fi

THEMENAME=$1


# =====================================
#      GO THROUGH THE THEMES
#
# reference the XDG dir as proposed in https://github.com/nix-community/home-manager/pull/4594#issuecomment-1774024207

THEME_DIR="${XDG_DATA_HOME:-$HOME/.local/share}/org.kde.syntax-highlighting/themes/"

# TODO and symlinks! (or: skip over dirs)
find "${THEME_DIR}" \( -type f -o -type l \) | while read -r themefile; do
  THIS_THEMENAME=$(jq -r .metadata.name "${themefile}")

  if [[ "${THIS_THEMENAME}" == "${themefile}" ]]; then
    # make sure to not look at symbolic links to the nix store
    # https://stackoverflow.com/questions/17918367/linux-shell-verify-whether-a-file-exists-and-is-a-soft-link/17918442#17918442
    # https://stackoverflow.com/questions/2172352/in-bash-how-can-i-check-if-a-string-begins-with-some-value/2172367#2172367
    if [[ ! ( -L "${themefile}"  &&  $(readlink -f "${themefile}") == /nix/store/* ) ]]; then
      >&2 printf "%s In %s there is already a theme with the name %s (%s).%s You could rename the theme given in config.programs.kate.editor.theme.src by changing the value for metadata.name inside the theme." "${RED}${BOLD}" "${THEME_DIR}" "${THEMENAME}" "${themefile}" "${NORMAL}${RED}"
      exit 1 # even on dryrun
     fi
  fi
done
</file>

<file path="modules/apps/kate/default.nix">
{
  config,
  lib,
  pkgs,
  ...
}:

let
  cfg = config.programs.kate;

  # compute kate's magic TabHandlingMode
  # 0 is not tab & not undoByShiftTab
  # 1 is tab & undoByShiftTab
  # 2 is not tab & undoByShiftTab
  tabHandlingMode =
    indentSettings:
    if (!indentSettings.undoByShiftTab && !indentSettings.tabFromEverywhere) then
      0
    else
      (if (indentSettings.undoByShiftTab && indentSettings.tabFromEverywhere) then 1 else 2);

  checkThemeNameScript = pkgs.writeShellApplication {
    name = "checkThemeName";
    runtimeInputs = with pkgs; [ jq ];
    text = builtins.readFile ./check-theme-name-free.sh;
  };

  checkThemeName = name: ''
    ${checkThemeNameScript}/bin/checkThemeName ${name}
  '';

  script = pkgs.writeScript "kate-check" (checkThemeName cfg.editor.theme.name);

  getIndexFromEnum =
    enum: value:
    if value == null then
      null
    else
      lib.lists.findFirstIndex (
        x: x == value
      ) (throw "getIndexFromEnum (kate): Value ${value} isn't present in the enum. This is a bug.") enum;

  qfont = import ../../../lib/qfont.nix { inherit lib; };

  styleStrategyType = lib.types.submodule {
    options = with qfont.styleStrategy; {
      prefer = lib.mkOption {
        type = prefer;
        default = "default";
        description = ''
          Which type of font is preferred by the font when finding an appropriate default family.

          `default`, `bitmap`, `device`, `outline`, `forceOutline` correspond to the
          `PreferDefault`, `PreferBitmap`, `PreferDevice`, `PreferOutline`, `ForceOutline` enum flags
          respectively.
        '';
      };
      matchingPrefer = lib.mkOption {
        type = matchingPrefer;
        default = "default";
        description = ''
          Whether the font matching process prefers exact matches, or best quality matches.

          `default` corresponds to not setting any enum flag, and `exact` and `quality`
          correspond to `PreferMatch` and `PreferQuality` enum flags respectively.
        '';
      };
      antialiasing = lib.mkOption {
        type = antialiasing;
        default = "default";
        description = ''
          Whether antialiasing is preferred for this font.

          `default` corresponds to not setting any enum flag, and `prefer` and `disable`
          correspond to `PreferAntialias` and `NoAntialias` enum flags respectively.
        '';
      };
      noSubpixelAntialias = lib.mkOption {
        type = lib.types.bool;
        default = false;
        description = ''
          If set to `true`, this font will try to avoid subpixel antialiasing.

          Corresponds to the `NoSubpixelAntialias` enum flag.
        '';
      };
      noFontMerging = lib.mkOption {
        type = lib.types.bool;
        default = false;
        description = ''
          If set to `true`, this font will not try to find a substitute font when encountering missing glyphs.

          Corresponds to the `NoFontMerging` enum flag.
        '';
      };
      preferNoShaping = lib.mkOption {
        type = lib.types.bool;
        default = false;
        description = ''
          If set to `true`, this font will not try to apply shaping rules that may be required for some scripts
          (e.g. Indic scripts), increasing performance if these rules are not required.

          Corresponds to the `PreferNoShaping` enum flag.
        '';
      };
    };
  };

  fontType = lib.types.submodule {
    options = {
      family = lib.mkOption {
        type = lib.types.str;
        description = "The font family of this font.";
        example = "Noto Sans";
      };
      pointSize = lib.mkOption {
        type = lib.types.nullOr lib.types.numbers.positive;
        default = null;
        description = ''
          The point size of this font.

          Could be a decimal, but usually an integer. Mutually exclusive with pixel size.
        '';
      };
      pixelSize = lib.mkOption {
        type = lib.types.nullOr lib.types.ints.u16;
        default = null;
        description = ''
          The pixel size of this font.

          Mutually exclusive with point size.
        '';
      };
      styleHint = lib.mkOption {
        type = qfont.styleHint;
        default = "anyStyle";
        description = ''
          The style hint of this font.

          See https://doc.qt.io/qt-6/qfont.html#StyleHint-enum for more.
        '';
      };
      weight = lib.mkOption {
        type = lib.types.either (lib.types.ints.between 1 1000) qfont.weight;
        default = "normal";
        description = ''
          The weight of the font, either as a number between 1 to 1000 or as a pre-defined weight string.

          See https://doc.qt.io/qt-6/qfont.html#Weight-enum for more.
        '';
      };
      style = lib.mkOption {
        type = qfont.style;
        default = "normal";
        description = "The style of the font.";
      };
      underline = lib.mkOption {
        type = lib.types.bool;
        default = false;
        description = "Whether the font is underlined.";
      };
      strikeOut = lib.mkOption {
        type = lib.types.bool;
        default = false;
        description = "Whether the font is struck out.";
      };
      fixedPitch = lib.mkOption {
        type = lib.types.bool;
        default = false;
        description = "Whether the font has a fixed pitch.";
      };
      capitalization = lib.mkOption {
        type = qfont.capitalization;
        default = "mixedCase";
        description = ''
          The capitalization settings for this font.

          See https://doc.qt.io/qt-6/qfont.html#Capitalization-enum for more.
        '';
      };
      letterSpacingType = lib.mkOption {
        type = qfont.spacingType;
        default = "percentage";
        description = ''
          Whether to use percentage or absolute spacing for this font.

          See https://doc.qt.io/qt-6/qfont.html#SpacingType-enum for more.
        '';
      };
      letterSpacing = lib.mkOption {
        type = lib.types.number;
        default = 0;
        description = ''
          The amount of letter spacing for this font.

          Could be a percentage or an absolute spacing change (positive increases spacing, negative decreases spacing),
          based on the selected `letterSpacingType`.
        '';
      };
      wordSpacing = lib.mkOption {
        type = lib.types.number;
        default = 0;
        description = ''
          The amount of word spacing for this font, in pixels.

          Positive values increase spacing while negative ones decrease spacing.
        '';
      };
      stretch = lib.mkOption {
        type = lib.types.either (lib.types.ints.between 1 4000) qfont.stretch;
        default = "anyStretch";
        description = ''
          The stretch factor for this font, as an integral percentage (i.e. 150 means a 150% stretch),
          or as a pre-defined stretch factor string.
        '';
      };
      styleStrategy = lib.mkOption {
        type = styleStrategyType;
        default = { };
        description = ''
          The strategy for matching similar fonts to this font.

          See https://doc.qt.io/qt-6/qfont.html#StyleStrategy-enum for more.
        '';
      };
      styleName = lib.mkOption {
        type = lib.types.nullOr lib.types.str;
        default = null;
        description = ''
          The style name of this font, overriding the `style` and `weight` parameters when set.
          Used for special fonts that have styles beyond traditional settings.
        '';
      };
    };
  };
in
{
  options.programs.kate = {
    enable = lib.mkEnableOption ''
      configuration management for Kate, the KDE Advanced Text Editor.
    '';

    package =
      lib.mkPackageOption pkgs
        [
          "kdePackages"
          "kate"
        ]
        {
          nullable = true;
          example = "pkgs.libsForQt5.kate";
          extraDescription = ''
            Which Kate package to be installed by `home-manager`. Use `pkgs.libsForQt5.kate` for Plasma 5 and
            `pkgs.kdePackages.kate` for Plasma 6. Use `null` if `home-manager` should not install Kate.
          '';
        };

    # ==================================
    #     INDENTATION
    editor = {
      tabWidth = lib.mkOption {
        description = "The width of a single tab (`\t`) sign (in number of spaces).";
        default = 4;
        type = lib.types.int;
      };

      indent.showLines = lib.mkOption {
        description = "Whether to show the vertical lines that mark each indentation level.";
        default = true;
        type = lib.types.bool;
      };

      indent.width = lib.mkOption {
        description = "The width of each indent level (in number of spaces).";
        default = cfg.editor.tabWidth;
        type = lib.types.int;
      };

      indent.autodetect = lib.mkOption {
        description = ''
          Whether Kate should try to detect indentation for each given file and not impose default indentation settings.
        '';
        default = true;
        type = lib.types.bool;
      };

      indent.keepExtraSpaces = lib.mkOption {
        description = "Whether additional spaces that do not match the indent should be kept when adding/removing indentation level. If these are kept (option to true) then indenting 1 space further (with a default of 4 spaces) will be set to 5 spaces.";
        default = false;
        type = lib.types.bool;
      };

      indent.replaceWithSpaces = lib.mkOption {
        description = "Whether all indentation should be automatically converted to spaces.";
        default = false;
        type = lib.types.bool;
      };

      indent.backspaceDecreaseIndent = lib.mkOption {
        description = "Whether the backspace key in the indentation should decrease indentation by a full level always.";
        default = true;
        type = lib.types.bool;
      };

      indent.tabFromEverywhere = lib.mkOption {
        description = "Whether the tabulator key increases intendation independent from the current cursor position.";
        default = false;
        type = lib.types.bool;
      };

      indent.undoByShiftTab = lib.mkOption {
        description = "Whether to unindent the current line by one level with the shortcut Shift+Tab.";
        default = true;
        type = lib.types.bool;
      };

      inputMode =
        let
          enumVals = [
            "normal"
            "vi"
          ];
        in
        lib.mkOption {
          type = lib.types.enum enumVals;
          description = "The input mode for the editor.";
          default = "normal";
          example = "vi";
          apply = getIndexFromEnum enumVals;
        };

      font = lib.mkOption {
        type = fontType;
        default = {
          family = "Hack";
          pointSize = 10;
        };
        example = {
          family = "Fira Code";
          pointSize = 11;
        };
        description = "The font settings for the editor.";
        apply = qfont.fontToString;
      };
    };
  };

  config.assertions = [
    {
      assertion = cfg.editor.indent.undoByShiftTab || (!cfg.editor.indent.tabFromEverywhere);
      message = "Kate does not support both 'undoByShiftTab' to be disabled and 'tabFromEverywhere' to be enabled at the same time.";
    }
  ];

  # ==================================
  #     COLORTHEME
  options.programs.kate.editor.theme = {
    src = lib.mkOption {
      description = ''
        The path of a theme file for the KDE editor (not the window color scheme).
        Obtain a custom one by using the GUI settings in Kate. If you want to use a system-wide
        editor color scheme set this path to null. If you set the metadata.name entry in the file
        to a value that matches the name of a system-wide color scheme undesired behaviour may
        occur. The activation will fail if a theme with the filename `<name of your theme>.theme`
        already exists.
      '';
      type = lib.types.nullOr lib.types.path;
      default = null;
    };

    name = lib.mkOption {
      description = ''
        The name of the theme in use. May be a system theme.
        If a theme file was submitted this setting will be set automatically.
      '';
      type = lib.types.str;
      default = "";
    };
  };

  config.programs.kate.editor.theme = {
    # kate's naming scheme is ${themename}.theme
    # which is why we use the same naming scheme here
    name = lib.mkIf (cfg.enable && null != cfg.editor.theme.src) (
      lib.mkForce (builtins.fromJSON (builtins.readFile cfg.editor.theme.src))."metadata"."name"
    );
  };

  # This won't override existing files since the home-manager activation fails in that case
  config.xdg.dataFile."${cfg.editor.theme.name}.theme" =
    lib.mkIf (cfg.enable && null != cfg.editor.theme.src)
      {
        source = cfg.editor.theme.src;
        target = "org.kde.syntax-highlighting/themes/${cfg.editor.theme.name}.theme";
      };

  config = {
    home.packages = lib.mkIf (cfg.enable && cfg.package != null) [ cfg.package ];

    # In case of using a custom theme, check that there is no name collision
    home.activation.checkKateTheme = lib.mkIf (cfg.enable && cfg.editor.theme.src != null) (
      lib.hm.dag.entryBefore [ "writeBoundary" ]
        # No `$DRY_RUN_CMD`, since even a dryrun should fail if checks fail
        ''
          ${script}
        ''
    );

    # In case of using a system theme, there should be a check that there exists such a theme
    # but I could not figure out where to find them
    # That's why there is no check for now
    # See also [the original PR](https://github.com/nix-community/plasma-manager/pull/95#issue-2206192839)
  };

  # ==================================
  #     LSP Servers
  options.programs.kate.lsp.customServers = lib.mkOption {
    default = null;
    type = lib.types.nullOr lib.types.attrs;
    description = ''
      Add more LSP server settings here. Check out the format on the
      [Kate Documentation](https://docs.kde.org/stable5/en/kate/kate/kate-application-plugin-lspclient.html).
      Note that these are only the settings; the appropriate packages have to be installed separately.
    '';
  };

  config.xdg.configFile."kate/lspclient/settings.json" = lib.mkIf (cfg.lsp.customServers != null) {
    text = builtins.toJSON { servers = cfg.lsp.customServers; };
  };

  # ==================================
  #     UI
  options.programs.kate.ui.colorScheme = lib.mkOption {
    type = lib.types.nullOr lib.types.str;
    default = null;

    example = "Krita dark orange";
    description = ''
      The colour scheme of the UI. Leave this setting at `null` in order to
      not override the systems default scheme for for this application.
    '';
  };

  # ==================================
  #     BRACKETS
  options.programs.kate.editor.brackets = {
    characters = lib.mkOption {
      type = lib.types.str;
      default = "<>(){}[]'\"\`";
      example = "<>(){}[]'\"\`*_~";
      description = "This options determines which characters kate will treat as brackets.";
    };
    automaticallyAddClosing = lib.mkEnableOption "" // {
      description = ''
        When enabled, a closing bracket is automatically inserted upon typing the opening.
      '';
    };
    highlightRangeBetween = lib.mkEnableOption "" // {
      description = ''
        This option enables automatch highlighting of the lines between an opening and a
        closing bracket when the cursor is adjacent to either.
      '';
    };
    highlightMatching = lib.mkEnableOption "" // {
      description = ''
        When enabled, and the cursor is adjacent to a closing bracket, and the corresponding
        closing bracket is outside of the currently visible area, then the line of the opening
        bracket and the line directly after will be shown in a small, floating window
        at the top of the text area.
      '';
    };
    flashMatching = lib.mkEnableOption "" // {
      description = ''
        When this option is enabled, then a bracket will quickly flash whenever the cursor
        moves adjacent to the corresponding bracket.
      '';
    };
  };

  # ==================================
  #     WRITING THE KATERC
  config.programs.plasma.configFile."katerc" = lib.mkIf cfg.enable {
    "KTextEditor Document" = {
      "Auto Detect Indent" = cfg.editor.indent.autodetect;
      "Indentation Width" = cfg.editor.indent.width;
      "Tab Handling" = (tabHandlingMode cfg.editor.indent);
      "Tab Width" = cfg.editor.tabWidth;
      "Keep Extra Spaces" = cfg.editor.indent.keepExtraSpaces;
      "ReplaceTabsDyn" = cfg.editor.indent.replaceWithSpaces;
    };

    "KTextEditor Renderer" = {
      "Show Indentation Lines" = cfg.editor.indent.showLines;

      "Animate Bracket Matching" = cfg.editor.brackets.flashMatching;

      # Do pick the theme if the user chose one,
      # Do not touch the theme settings otherwise
      "Auto Color Theme Selection" = lib.mkIf (cfg.editor.theme.name != "") false;
      "Color Theme" = lib.mkIf (cfg.editor.theme.name != "") cfg.editor.theme.name;
      "Text Font" = cfg.editor.font;
    };

    "KTextEditor View" = {
      "Chars To Enclose Selection" = {
        value = cfg.editor.brackets.characters;
        escapeValue = false;
      };
      "Bracket Match Preview" = cfg.editor.brackets.highlightMatching;
      "Auto Brackets" = cfg.editor.brackets.automaticallyAddClosing;
      "Input Mode" = cfg.editor.inputMode;
    };

    "UiSettings"."ColorScheme" = lib.mkIf (cfg.ui.colorScheme != null) cfg.ui.colorScheme;
  };
}
</file>

<file path="modules/apps/default.nix">
{ ... }:

{
  imports = [
    ./elisa.nix
    ./ghostwriter.nix
    ./konsole.nix
    ./kate
    ./okular.nix
  ];
}
</file>

<file path="modules/apps/elisa.nix">
{
  config,
  lib,
  pkgs,
  ...
}:
let
  cfg = config.programs.elisa;

  capitalizeWord =
    word:
    if word == null then
      null
    else
      lib.concatImapStrings (pos: char: if pos == 1 then lib.toUpper char else char) (
        lib.stringToCharacters word
      );
in
{
  options.programs.elisa = {
    enable = lib.mkEnableOption "the configuration module for Elisa, KDE's music player";
    package =
      lib.mkPackageOption pkgs
        [
          "kdePackages"
          "elisa"
        ]
        {
          nullable = true;
          example = "pkgs.libsForQt5.elisa";
          extraDescription = ''
            Use `pkgs.libsForQt5.elisa` for Plasma 5 or `pkgs.kdePackages.elisa` for Plasma 6.
            You can also set this to `null` if you're using a system-wide installation of Elisa on NixOS.
          '';
        };

    appearance = {
      colorScheme = lib.mkOption {
        type = lib.types.nullOr lib.types.str;
        default = null;
        example = "Krita dark orange";
        description = ''
          The colour scheme of the UI. Leave this setting at `null` in order to
          not override the systems default scheme for for this application.
        '';
      };
      showNowPlayingBackground = lib.mkOption {
        description = ''
          Set to `true` in order to use a blurred version of the album artwork as the background for the 'Now Playing' section in Elisa.
          Set to `false` in order to use a solid colour inherited from the Plasma theme.
        '';
        default = null;
        type = lib.types.nullOr lib.types.bool;
      };
      showProgressOnTaskBar = lib.mkOption {
        description = ''
          Whether to present the current track progress in the task manager widgets in panels.
        '';
        default = null;
        type = lib.types.nullOr lib.types.bool;
      };
      embeddedView = lib.mkOption {
        description = ''
          Select the sidebar-embedded view for Elisa. The selected view will
          be omitted from the sidebar, and its contents will instead be individually
          displayed after the main view buttons.
        '';
        default = null;
        type = lib.types.nullOr (
          lib.types.enum [
            "albums"
            "artists"
            "genres"
          ]
        );
        apply = capitalizeWord;
      };
      defaultView = lib.mkOption {
        description = ''
          The default view which will be opened when Elisa is started.
        '';
        default = null;
        type = lib.types.nullOr (
          lib.types.enum [
            "nowPlaying"
            "recentlyPlayed"
            "frequentlyPlayed"
            "allAlbums"
            "allArtists"
            "allTracks"
            "allGenres"
            "files"
            "radios"
          ]
        );
        apply = capitalizeWord;
      };
      defaultFilesViewPath = lib.mkOption {
        description = ''
          The default path which will be opened in the Files view.
          Unlike the index paths, shell variables cannot be used here.
        '';
        default = null;
        example = "/home/username/Music";
        type = lib.types.nullOr lib.types.str;
      };
    };

    indexer = {
      paths = lib.mkOption {
        description = ''
          Stateful, persistent paths to be indexed by the Elisa Indexer.
          The Indexer will recursively search for valid music files along the given paths.
          Shell variables, such as `$HOME`, may be used freely.
        '';
        default = null;
        example = ''
          [
            "$HOME/Music"
            "/ExternalDisk/more-music"
          ]
        '';
        type = lib.types.nullOr (lib.types.listOf lib.types.str);
      };
      scanAtStartup = lib.mkOption {
        description = "Whether to automatically scan the configured index paths for new tracks when Elisa is started.";
        default = null;
        example = true;
        type = lib.types.nullOr lib.types.bool;
      };
      ratingsStyle = lib.mkOption {
        description = ''
          The Elisa music database can attach user-defined ratings to each track.
          This option defines if the rating is a `0-5 stars` rating, or a binary `Favourite/Not Favourite` rating.
        '';
        default = null;
        type = lib.types.nullOr (
          lib.types.enum [
            "stars"
            "favourites"
          ]
        );
      };
    };

    player = {
      playAtStartup = lib.mkOption {
        description = "Whether to automatically play the previous track when Elisa is started.";
        default = null;
        type = lib.types.nullOr lib.types.bool;
      };
      minimiseToSystemTray = lib.mkOption {
        description = ''
          Set to `true` in order to make Elisa continue playing in the System Tray after being closed.
          Set to `false` in order to make Elisa quit after being closed.

          By default, the system tray icon is the symbolic variant of the Elisa icon.
        '';
        default = null;
        type = lib.types.nullOr lib.types.bool;
      };
      useAbsolutePlaylistPaths = lib.mkOption {
        description = ''
          Set to `true` in order to make Elisa write `.m3u8` playlist files using the absolute paths to each track.
          Setting to `false` will make Elisa intelligently pick between relative or absolute paths.
        '';
        default = null;
        type = lib.types.nullOr lib.types.bool;
      };
    };
  };

  config = lib.mkIf cfg.enable {
    home.packages = lib.mkIf (cfg.package != null) [ cfg.package ];
    programs.plasma.configFile."elisarc" =
      let
        concatenatedPaths = builtins.concatStringsSep "," cfg.indexer.paths;
      in
      lib.mkMerge [
        (lib.mkIf (cfg.indexer.paths != null) {
          ElisaFileIndexer.RootPath = {
            shellExpand = true;
            value = concatenatedPaths;
          };
        })
        (lib.mkMerge [
          (lib.mkIf (cfg.player.playAtStartup != null) {
            PlayerSettings.PlayAtStartup.value = cfg.player.playAtStartup;
          })
          (lib.mkIf (cfg.indexer.scanAtStartup != null) {
            PlayerSettings.ScanAtStartup.value = cfg.indexer.scanAtStartup;
          })
          (lib.mkIf (cfg.appearance.showNowPlayingBackground != null) {
            PlayerSettings.ShowNowPlayingBackground.value = cfg.appearance.showNowPlayingBackground;
          })
          (lib.mkIf (cfg.appearance.showProgressOnTaskBar != null) {
            PlayerSettings.ShowProgressOnTaskBar.value = cfg.appearance.showProgressOnTaskBar;
          })
          (lib.mkIf (cfg.player.minimiseToSystemTray != null) {
            PlayerSettings.ShowSystemTrayIcon.value = cfg.player.minimiseToSystemTray;
          })
          (lib.mkIf (cfg.indexer.ratingsStyle != null) {
            PlayerSettings.UseFavoriteStyleRatings.value =
              if (cfg.indexer.ratingsStyle == "Stars") then false else true;
          })
        ])
        (lib.mkIf (cfg.player.useAbsolutePlaylistPaths != null) {
          Playlist.AlwaysUseAbsolutePlaylistPaths.value = cfg.player.useAbsolutePlaylistPaths;
        })
        (lib.mkIf (cfg.appearance.colorScheme != null) {
          UiSettings.ColorScheme.value = cfg.appearance.colorScheme;
        })
        (lib.mkMerge [
          (lib.mkIf (cfg.appearance.embeddedView != null) {
            Views.EmbeddedView.value = "All" + cfg.appearance.embeddedView;
          })
          (lib.mkIf (cfg.appearance.defaultFilesViewPath != null) {
            Views.InitialFilesViewPath.value = cfg.appearance.defaultFilesViewPath;
          })
          (lib.mkIf (cfg.appearance.defaultView != null) {
            Views.InitialView.value = cfg.appearance.defaultView;
          })
        ])
      ];
  };
}
</file>

<file path="modules/apps/ghostwriter.nix">
{
  config,
  lib,
  pkgs,
  ...
}:
let
  cfg = config.programs.ghostwriter;

  qfont = import ../../lib/qfont.nix { inherit lib; };

  createThemes = lib.attrsets.mapAttrs' (
    name: value:
    lib.attrsets.nameValuePair "ghostwriter/themes/${name}.json" {
      enable = true;
      source = value;
    }
  );

  getIndexFromEnum =
    enum: value:
    if value == null then
      null
    else
      lib.lists.findFirstIndex (x: x == value)
        (throw "getIndexFromEnum (ghostwriter): Value ${value} isn't present in the enum. This is a bug")
        enum;

  getBoolFromEnum =
    enum: value:
    if value == null then
      null
    else if (getIndexFromEnum enum value) == 0 then
      false
    else
      true;

  styleStrategyType = lib.types.submodule {
    options = with qfont.styleStrategy; {
      prefer = lib.mkOption {
        type = prefer;
        default = "default";
        description = ''
          Which type of font is preferred by the font when finding an appropriate default family.

          `default`, `bitmap`, `device`, `outline`, `forceOutline` correspond to the
          `PreferDefault`, `PreferBitmap`, `PreferDevice`, `PreferOutline`, `ForceOutline` enum flags
          respectively.
        '';
      };
      matchingPrefer = lib.mkOption {
        type = matchingPrefer;
        default = "default";
        description = ''
          Whether the font matching process prefers exact matches, or best quality matches.

          `default` corresponds to not setting any enum flag, and `exact` and `quality`
          correspond to `PreferMatch` and `PreferQuality` enum flags respectively.
        '';
      };
      antialiasing = lib.mkOption {
        type = antialiasing;
        default = "default";
        description = ''
          Whether antialiasing is preferred for this font.

          `default` corresponds to not setting any enum flag, and `prefer` and `disable`
          correspond to `PreferAntialias` and `NoAntialias` enum flags respectively.
        '';
      };
      noSubpixelAntialias = lib.mkOption {
        type = lib.types.bool;
        default = false;
        description = ''
          If set to `true`, this font will try to avoid subpixel antialiasing.

          Corresponds to the `NoSubpixelAntialias` enum flag.
        '';
      };
      noFontMerging = lib.mkOption {
        type = lib.types.bool;
        default = false;
        description = ''
          If set to `true`, this font will not try to find a substitute font when encountering missing glyphs.

          Corresponds to the `NoFontMerging` enum flag.
        '';
      };
      preferNoShaping = lib.mkOption {
        type = lib.types.bool;
        default = false;
        description = ''
          If set to `true`, this font will not try to apply shaping rules that may be required for some scripts
          (e.g. Indic scripts), increasing performance if these rules are not required.

          Corresponds to the `PreferNoShaping` enum flag.
        '';
      };
    };
  };

  fontType = lib.types.submodule {
    options = {
      family = lib.mkOption {
        type = lib.types.str;
        description = "The font family of this font.";
        example = "Noto Sans";
      };
      pointSize = lib.mkOption {
        type = lib.types.nullOr lib.types.numbers.positive;
        default = null;
        description = ''
          The point size of this font.

          Could be a decimal, but usually an integer. Mutually exclusive with pixel size.
        '';
      };
      pixelSize = lib.mkOption {
        type = lib.types.nullOr lib.types.ints.u16;
        default = null;
        description = ''
          The pixel size of this font.

          Mutually exclusive with point size.
        '';
      };
      styleHint = lib.mkOption {
        type = qfont.styleHint;
        default = "anyStyle";
        description = ''
          The style hint of this font.

          See https://doc.qt.io/qt-6/qfont.html#StyleHint-enum for more information.
        '';
      };
      weight = lib.mkOption {
        type = lib.types.either (lib.types.ints.between 1 1000) qfont.weight;
        default = "normal";
        description = ''
          The weight of the font, either as a number between 1 to 1000 or as a pre-defined weight string.

          See https://doc.qt.io/qt-6/qfont.html#Weight-enum for more information.
        '';
      };
      style = lib.mkOption {
        type = qfont.style;
        default = "normal";
        description = "The style of the font.";
      };
      underline = lib.mkOption {
        type = lib.types.bool;
        default = false;
        description = "Whether the font is underlined.";
      };
      strikeOut = lib.mkOption {
        type = lib.types.bool;
        default = false;
        description = "Whether the font is struck out.";
      };
      fixedPitch = lib.mkOption {
        type = lib.types.bool;
        default = false;
        description = "Whether the font has a fixed pitch.";
      };
      capitalization = lib.mkOption {
        type = qfont.capitalization;
        default = "mixedCase";
        description = ''
          The capitalization settings for this font.

          See https://doc.qt.io/qt-6/qfont.html#Capitalization-enum for more.
        '';
      };
      letterSpacingType = lib.mkOption {
        type = qfont.spacingType;
        default = "percentage";
        description = ''
          Whether to use percentage or absolute spacing for this font.

          See https://doc.qt.io/qt-6/qfont.html#SpacingType-enum for more.
        '';
      };
      letterSpacing = lib.mkOption {
        type = lib.types.number;
        default = 0;
        description = ''
          The amount of letter spacing for this font.

          Could be a percentage or an absolute spacing change (positive increases spacing, negative decreases spacing),
          based on the selected `letterSpacingType`.
        '';
      };
      wordSpacing = lib.mkOption {
        type = lib.types.number;
        default = 0;
        description = ''
          The amount of word spacing for this font, in pixels.

          Positive values increase spacing while negative ones decrease spacing.
        '';
      };
      stretch = lib.mkOption {
        type = lib.types.either (lib.types.ints.between 1 4000) qfont.stretch;
        default = "anyStretch";
        description = ''
          The stretch factor for this font, as an integral percentage (i.e. 150 means a 150% stretch),
          or as a pre-defined stretch factor string.
        '';
      };
      styleStrategy = lib.mkOption {
        type = styleStrategyType;
        default = { };
        description = ''
          The strategy for matching similar fonts to this font.

          See https://doc.qt.io/qt-6/qfont.html#StyleStrategy-enum for more.
        '';
      };
      styleName = lib.mkOption {
        type = lib.types.nullOr lib.types.str;
        default = null;
        description = ''
          The style name of this font, overriding the `style` and `weight` parameters when set.
          Used for special fonts that have styles beyond traditional settings.
        '';
      };
    };
  };
in
{
  options.programs.ghostwriter = {
    enable = lib.mkEnableOption ''
      configuration management for Ghostwriter.
    '';

    font = lib.mkOption {
      type = lib.types.nullOr fontType;
      default = null;
      example = {
        family = "Noto Sans";
        pointSize = 12;
      };
      description = ''
        The font to use for Ghostwriter.
      '';
      apply = font: if font == null then null else ''"${qfont.fontToString font}"'';
    };

    locale = lib.mkOption {
      type = lib.types.nullOr lib.types.str;
      default = null;
      example = "en_US";
      description = ''
        The locale to use for Ghostwriter.
      '';
    };

    package =
      lib.mkPackageOption pkgs
        [
          "kdePackages"
          "ghostwriter"
        ]
        {
          nullable = true;
          example = "pkgs.kdePackages.ghostwriter";
          extraDescription = ''
            Use `pkgs.libsForQt5.ghostwriter` for Plasma 5 and
            `pkgs.kdePackages.ghostwriter` for Plasma 6. Use
            `null` if `home-manager` should not install Ghostwriter.
          '';
        };

    editor = {
      styling = {
        blockquoteStyle =
          let
            enumVals = [
              "simple"
              "italic"
            ];
          in
          lib.mkOption {
            type = lib.types.nullOr (lib.types.enum enumVals);
            default = null;
            example = "simple";
            description = "The style of blockquotes.";
            apply = getBoolFromEnum enumVals;
          };
        editorWidth =
          let
            enumVals = [
              "narrow"
              "medium"
              "wide"
              "full"
            ];
          in
          lib.mkOption {
            type = lib.types.nullOr (lib.types.enum enumVals);
            default = null;
            example = "medium";
            description = "The width of the editor.";
            apply = getIndexFromEnum enumVals;
          };
        emphasisStyle =
          let
            enumVals = [
              "italic"
              "underline"
            ];
          in
          lib.mkOption {
            type = lib.types.nullOr (lib.types.enum enumVals);
            default = null;
            example = "bold";
            description = "The style of emphasis.";
            apply = getBoolFromEnum enumVals;
          };
        focusMode =
          let
            enumVals = [
              "sentence"
              "currentLine"
              "threeLines"
              "paragraph"
              "typewriter"
            ];
          in
          lib.mkOption {
            type = lib.types.nullOr (lib.types.enum enumVals);
            default = null;
            example = "sentence";
            description = "The focus mode to use.";
            apply =
              focusMode:
              if focusMode == null then
                null
              else
                builtins.elemAt
                  [
                    1
                    2
                    3
                    4
                    5
                  ]
                  (
                    lib.lists.findFirstIndex (x: x == focusMode)
                      (throw "editor.styling.focusMode: Value ${focusMode} isn't present in the enum. This is a bug.")
                      enumVals
                  );
          };
        useLargeHeadings = lib.mkOption {
          type = lib.types.nullOr lib.types.bool;
          default = null;
          example = true;
          description = "Whether to use large headings.";
        };
      };
      tabulation = {
        insertSpacesForTabs = lib.mkOption {
          type = lib.types.nullOr lib.types.bool;
          default = null;
          description = ''
            Whether to insert spaces for tabs.
          '';
        };
        tabWidth = lib.mkOption {
          type = lib.types.nullOr lib.types.ints.positive;
          default = null;
          description = ''
            The width of a tab.
          '';
        };
      };
      typing = {
        automaticallyMatchCharacters = {
          enable = lib.mkOption {
            type = lib.types.nullOr lib.types.bool;
            default = null;
            example = true;
            description = "Whether to automatically match characters.";
          };
          characters = lib.mkOption {
            type = lib.types.nullOr lib.types.str;
            default = null;
            example = ''\"'([{*_`<'';
            description = "The characters to automatically match.";
            apply = chars: if chars == null then null else ''"${chars}"'';
          };
        };
        bulletPointCycling = lib.mkOption {
          type = lib.types.nullOr lib.types.bool;
          default = null;
          example = true;
          description = "Whether to cycle through bullet points.";
        };
      };
    };

    general = {
      display = {
        hideMenubarInFullscreen = lib.mkOption {
          type = lib.types.nullOr lib.types.bool;
          default = null;
          example = true;
          description = "Whether to hide the menubar in fullscreen mode.";
        };
        interfaceStyle =
          let
            enumVals = [
              "rounded"
              "square"
            ];
          in
          lib.mkOption {
            type = lib.types.nullOr (lib.types.enum enumVals);
            default = null;
            example = "rounded";
            description = "The interface style to use for Ghostwriter.";
            apply = getIndexFromEnum enumVals;
          };
        showCurrentTimeInFullscreen = lib.mkOption {
          type = lib.types.nullOr lib.types.bool;
          default = null;
          example = true;
          description = "Whether to show the current time in fullscreen mode.";
        };
        showUnbreakableSpace = lib.mkOption {
          type = lib.types.nullOr lib.types.bool;
          default = null;
          example = true;
          description = "Whether to show unbreakable space.";
        };
      };
      fileSaving = {
        autoSave = lib.mkOption {
          type = lib.types.nullOr lib.types.bool;
          default = null;
          example = true;
          description = "Whether to enable auto-save.";
        };
        backupFileOnSave = lib.mkOption {
          type = lib.types.nullOr lib.types.bool;
          default = null;
          example = true;
          description = "Whether to backup the file on save.";
        };
        backupLocation = lib.mkOption {
          type = lib.types.nullOr lib.types.path;
          default = null;
          example = "/home/user/.local/share/ghostwriter/backups";
          description = ''
            The location to store backups of the Ghostwriter configuration.
          '';
        };
      };
      session = {
        openLastFileOnStartup = lib.mkOption {
          type = lib.types.nullOr lib.types.bool;
          default = null;
          example = true;
          description = "Whether to open the last file on startup.";
        };
        rememberRecentFiles = lib.mkOption {
          type = lib.types.nullOr lib.types.bool;
          default = null;
          example = true;
          description = "Whether to remember recent files.";
        };
      };
    };

    preview = {
      codeFont = lib.mkOption {
        type = lib.types.nullOr fontType;
        default = null;
        example = {
          family = "Hack";
          pointSize = 12;
        };
        description = ''
          The code font to use for the preview.
        '';
        apply = font: if font == null then null else ''"${qfont.fontToString font}"'';
      };
      commandLineOptions = lib.mkOption {
        type = with lib.types; nullOr str;
        default = null;
        description = ''
          Additional command line options to pass to the preview command.
        '';
      };
      markdownVariant = lib.mkOption {
        type = with lib.types; nullOr str;
        default = null;
        example = "cmark-gfm";
        description = ''
          The markdown variant to use for the preview.
        '';
      };
      openByDefault = lib.mkOption {
        type = lib.types.nullOr lib.types.bool;
        default = null;
        example = true;
        description = ''
          Whether to open the preview by default.
        '';
      };
      textFont = lib.mkOption {
        type = lib.types.nullOr fontType;
        default = null;
        example = {
          family = "Inter";
          pointSize = 12;
        };
        description = ''
          The text font to use for the preview.
        '';
        apply = font: if font == null then null else ''"${qfont.fontToString font}"'';
      };
    };

    spelling = {
      autoDetectLanguage = lib.mkOption {
        type = lib.types.nullOr lib.types.bool;
        default = null;
        example = true;
        description = "Whether to auto-detect the language.";
      };
      checkerEnabledByDefault = lib.mkOption {
        type = lib.types.nullOr lib.types.bool;
        default = null;
        example = true;
        description = "Whether the checker is enabled by default.";
      };
      ignoreUppercase = lib.mkOption {
        type = lib.types.nullOr lib.types.bool;
        default = null;
        example = true;
        description = "Whether to ignore uppercase words.";
      };
      ignoredWords = lib.mkOption {
        type = lib.types.nullOr (lib.types.listOf lib.types.str);
        default = null;
        example = [
          "Amarok"
          "KHTML"
          "NixOS"
        ];
        description = "Words to ignore in the spell checker.";
        apply =
          ignoredWords: if ignoredWords == null then null else builtins.concatStringsSep ", " ignoredWords;
      };
      liveSpellCheck = lib.mkOption {
        type = lib.types.nullOr lib.types.bool;
        default = null;
        example = true;
        description = "Whether to enable live spell checking.";
      };
      skipRunTogether = lib.mkOption {
        type = lib.types.nullOr lib.types.bool;
        default = null;
        example = true;
        description = "Whether to skip run-together words.";
      };
    };

    theme = {
      name = lib.mkOption {
        type = with lib.types; nullOr str;
        default = null;
        example = "Ghostwriter";
        description = ''
          The name of the theme to use.
        '';
      };
      customThemes = lib.mkOption {
        type = with lib.types; attrsOf path;
        default = { };
        description = ''
          Custom themes to be added to the installation. The attribute key is mapped to their name.
          Choose them from `programs.ghostwriter.theme.name`.
        '';
      };
    };

    window.sidebarOpen = lib.mkOption {
      type = lib.types.nullOr lib.types.bool;
      default = null;
      example = true;
      description = "Whether the sidebar is open by default.";
    };
  };

  config = (
    lib.mkIf cfg.enable {
      assertions = [
        {
          assertion = cfg.spelling.ignoredWords == null || cfg.locale != null;
          message = "ghostwriter: Ignored words can only be set if a locale is set.";
        }
      ];

      home.packages = lib.mkIf (cfg.package != null) [ cfg.package ];

      programs.plasma.configFile = {
        "kde.org/ghostwriter.conf" = (
          lib.mkMerge [
            # Font
            (lib.mkIf (cfg.font != null) { Style.editorFont = cfg.font; })

            # Locale
            (lib.mkIf (cfg.locale != null) { Application.locale = cfg.locale; })

            # Editor > Styling
            (lib.mkIf (cfg.editor.styling.blockquoteStyle != null) {
              Style.blockquoteStyle = cfg.editor.styling.blockquoteStyle;
            })
            (lib.mkIf (cfg.editor.styling.emphasisStyle != null) {
              Style.underlineInsteadOfItalics = cfg.editor.styling.emphasisStyle;
            })
            (lib.mkIf (cfg.editor.styling.editorWidth != null) {
              Style.editorWidth = cfg.editor.styling.editorWidth;
            })
            (lib.mkIf (cfg.editor.styling.focusMode != null) {
              Style.focusMode = cfg.editor.styling.focusMode;
            })
            (lib.mkIf (cfg.editor.styling.useLargeHeadings != null) {
              Style.largeHeadings = cfg.editor.styling.useLargeHeadings;
            })

            # Editor > Tabulation
            (lib.mkIf (cfg.editor.tabulation.insertSpacesForTabs != null) {
              Tabs.insertSpacesForTabs = cfg.editor.tabulation.insertSpacesForTabs;
            })
            (lib.mkIf (cfg.editor.tabulation.tabWidth != null) {
              Tabs.tabWidth = cfg.editor.tabulation.tabWidth;
            })

            # Editor > Typing
            (lib.mkIf (cfg.editor.typing.automaticallyMatchCharacters.enable != null) {
              Typing.autoMatchEnabled = cfg.editor.typing.automaticallyMatchCharacters.enable;
            })
            (lib.mkIf (cfg.editor.typing.automaticallyMatchCharacters.characters != null) {
              Typing.autoMatchFilter = {
                value = cfg.editor.typing.automaticallyMatchCharacters.characters;
                escapeValue = false;
              };
            })
            (lib.mkIf (cfg.editor.typing.bulletPointCycling != null) {
              Typing.bulletPointCyclingEnabled = cfg.editor.typing.bulletPointCycling;
            })

            # General > Display
            (lib.mkIf (cfg.general.display.hideMenubarInFullscreen != null) {
              Style.hideMenuBarInFullscreen = cfg.general.display.hideMenubarInFullscreen;
            })
            (lib.mkIf (cfg.general.display.interfaceStyle != null) {
              Style.interfaceStyle = cfg.general.display.interfaceStyle;
            })
            (lib.mkIf (cfg.general.display.showCurrentTimeInFullscreen != null) {
              Style.displayTimeInFullScreen = cfg.general.display.showCurrentTimeInFullscreen;
            })
            (lib.mkIf (cfg.general.display.showUnbreakableSpace != null) {
              style.showUnbreakableSpace = cfg.general.display.showUnbreakableSpace;
            })

            # General > File Saving
            (lib.mkIf (cfg.general.fileSaving.autoSave != null) {
              Save.autoSave = cfg.general.fileSaving.autoSave;
            })
            (lib.mkIf (cfg.general.fileSaving.backupFileOnSave != null) {
              Save.backupFile = cfg.general.fileSaving.backupFileOnSave;
            })
            (lib.mkIf (cfg.general.fileSaving.backupLocation != null) {
              Backup.location = cfg.general.fileSaving.backupLocation;
            })

            # General > Session
            (lib.mkIf (cfg.general.session.openLastFileOnStartup != null) {
              Session.restoreSession = cfg.general.session.openLastFileOnStartup;
            })
            (lib.mkIf (cfg.general.session.rememberRecentFiles != null) {
              Session.rememberFileHistory = cfg.general.session.rememberRecentFiles;
            })

            # Spelling
            (lib.mkIf (cfg.spelling.liveSpellCheck != null) {
              Spelling = {
                liveSpellCheck = cfg.spelling.liveSpellCheck;
              };
            })

            # Preview options
            (lib.mkIf (cfg.preview.codeFont != null) { Preview.codeFont = cfg.preview.codeFont; })
            (lib.mkIf (cfg.preview.commandLineOptions != null) {
              Preview.lastUsedExporterParams = cfg.preview.commandLineOptions;
            })
            (lib.mkIf (cfg.preview.markdownVariant != null) {
              Preview.lastUsedExporter = cfg.preview.markdownVariant;
            })
            (lib.mkIf (cfg.preview.openByDefault != null) {
              Preview.htmlPreviewOpen = cfg.preview.openByDefault;
            })
            (lib.mkIf (cfg.preview.textFont != null) { Preview.textFont = cfg.preview.textFont; })

            # Theme
            (lib.mkIf (cfg.theme.name != null) { Style.theme = cfg.theme.name; })

            # Window
            (lib.mkIf (cfg.window.sidebarOpen != null) { Window.sidebarOpen = cfg.window.sidebarOpen; })
          ]
        );

        "KDE/Sonnet.conf".General = (
          lib.mkMerge [
            (lib.mkIf (cfg.spelling.autoDetectLanguage != null) {
              autodetectLanguage = cfg.spelling.autoDetectLanguage;
            })
            (lib.mkIf (cfg.spelling.checkerEnabledByDefault != null) {
              checkerEnabledByDefault = cfg.spelling.checkerEnabledByDefault;
            })
            (lib.mkIf (cfg.spelling.ignoreUppercase != null) {
              checkUppercase = !cfg.spelling.ignoreUppercase;
            })
            (lib.mkIf (cfg.spelling.ignoredWords != null && cfg.locale != null) {
              "ignore_${cfg.locale}" = cfg.spelling.ignoredWords;
            })
            (lib.mkIf (cfg.locale != null) { defaultLanguage = cfg.locale; })
          ]
        );
      };

      xdg.dataFile = (createThemes cfg.theme.customThemes);
    }
  );
}
</file>

<file path="modules/apps/konsole.nix">
{ config, lib, ... }:
let
  inherit
    (import ../../lib/types.nix {
      inherit lib;
      inherit config;
    })
    basicSettingsType
    ;

  # used as shown in the example in the library docs:
  # https://noogle.dev/f/lib/attrsets/mapAttrs'
  createColorSchemes = lib.attrsets.mapAttrs' (
    name: value:
    lib.attrsets.nameValuePair "konsole/${name}.colorscheme" {
      enable = true;
      source = value;
    }
  );

  cfg = config.programs.konsole;
  profilesSubmodule = {
    options = {
      name = lib.mkOption {
        type = with lib.types; nullOr str;
        default = null;
        description = ''
          Name of the profile. Defaults to the attribute name.
        '';
      };
      colorScheme = lib.mkOption {
        type = with lib.types; nullOr str;
        default = null;
        example = "Catppuccin-Mocha";
        description = ''
          Color scheme the profile will use. You can check the files you can
          use in `$HOME/.local/share/konsole` or `/run/current-system/sw/share/konsole`.
          You might also add a custom color scheme using
          `programs.konsole.customColorSchemes`.
        '';
      };
      command = lib.mkOption {
        type = with lib.types; nullOr str;
        default = null;
        example = lib.literalExpression ''"''${pkgs.zsh}/bin/zsh"'';
        description = ''
          The command to run on new sessions.
        '';
      };
      font = {
        name = lib.mkOption {
          type = lib.types.str;
          /*
            TODO: Set default to null after adding an assertion
            Konsole needs to have a font set to be able to change font size
            Since I couldn't get that to work I'll just set a default font
            Not ideal since IMO we should only write things that are set explicitly
            by the user but ehh it is what it is
          */
          default = "Hack";
          example = "Hack";
          description = ''
            Name of the font the profile should use.
          '';
        };
        size = lib.mkOption {
          # The konsole ui gives you a limited range
          type = (lib.types.ints.between 4 128);
          default = 10;
          example = 12;
          description = ''
            Size of the font.
            Due to Konsole limitations, only a limited range of sizes is possible.
          '';
        };
      };
      extraConfig = lib.mkOption {
        type = with lib.types; attrsOf (attrsOf basicSettingsType);
        default = { };
        example = { };
        description = ''
          Extra keys to manually add to the profile.
        '';
      };
    };
  };
in

{
  options.programs.konsole = {
    enable = lib.mkEnableOption ''
      configuration management for Konsole, the KDE Terminal.
    '';

    defaultProfile = lib.mkOption {
      type = with lib.types; nullOr str;
      default = null;
      example = "Catppuccin";
      description = ''
        The name of the Konsole profile file to use by default.
        To see what options you have, take a look at `$HOME/.local/share/konsole`
      '';
    };

    profiles = lib.mkOption {
      type = with lib.types; nullOr (attrsOf (submodule profilesSubmodule));
      default = { };
      description = ''
        Plasma profiles to generate.
      '';
    };

    customColorSchemes = lib.mkOption {
      type = with lib.types; attrsOf path;
      default = { };
      description = ''
        Custom color schemes to be added to the installation. The attribute key maps to their name.
        Choose them in any profile with `profiles.<profile>.colorScheme = <name>`;
      '';
    };

    ui.colorScheme = lib.mkOption {
      type = with lib.types; nullOr str;
      default = null;
      example = "Krita dark orange";
      description = ''
        The color scheme of the UI. Leave this setting at `null` in order to
        not override the system's default scheme for for this application.
      '';
    };

    extraConfig = lib.mkOption {
      type = with lib.types; attrsOf (attrsOf basicSettingsType);
      default = { };
      description = ''
        Extra config to add to the `konsolerc`.
      '';
    };
  };

  config = lib.mkIf (cfg.enable) {
    programs.plasma.configFile."konsolerc" = lib.mkMerge [
      (lib.mkIf (cfg.defaultProfile != null) {
        "Desktop Entry"."DefaultProfile" = "${cfg.defaultProfile}.profile";
      })
      (lib.mapAttrs (
        groupName: (lib.mapAttrs (keyName: keyAttrs: { value = keyAttrs; }))
      ) cfg.extraConfig)
      {
        "UiSettings"."ColorScheme" = lib.mkIf (cfg.ui.colorScheme != null) {
          value = cfg.ui.colorScheme;
          # The key needs to be immutable to work properly when using overrideConfig.
          # See discussion at: https://github.com/nix-community/plasma-manager/pull/186
          immutable = lib.mkIf config.programs.plasma.overrideConfig (lib.mkDefault true);
        };
      }
    ];

    xdg.dataFile = lib.mkMerge [
      (lib.mkIf (cfg.profiles != { }) (
        lib.mkMerge (
          lib.mapAttrsToList (
            attrName: profile:
            let
              # Use the name from the name option if it's set
              profileName = if builtins.isString profile.name then profile.name else attrName;
              fontString = lib.mkIf (
                profile.font.name != null
              ) "${profile.font.name},${builtins.toString profile.font.size}";
            in
            {
              "konsole/${profileName}.profile".text = lib.generators.toINI { } (
                lib.recursiveUpdate {
                  "General" = (
                    {
                      "Name" = profileName;
                      # Konsole generated profiles seem to always have this
                      "Parent" = "FALLBACK/";
                    }
                    // (lib.optionalAttrs (profile.command != null) { "Command" = profile.command; })
                  );
                  "Appearance" = (
                    {
                      # If the font size is not set we leave a comma at the end after the name
                      # We should fix this probs but konsole doesn't seem to care \_()_/
                      "Font" = fontString.content;
                    }
                    // (lib.optionalAttrs (profile.colorScheme != null) { "ColorScheme" = profile.colorScheme; })
                  );
                } profile.extraConfig
              );
            }
          ) cfg.profiles
        )
      ))
      (createColorSchemes cfg.customColorSchemes)
    ];
  };
}
</file>

<file path="modules/apps/okular.nix">
{
  config,
  lib,
  pkgs,
  ...
}:

let
  cfg = config.programs.okular;
  getIndexFromEnum =
    enum: value:
    if value == null then
      null
    else
      lib.lists.findFirstIndex (x: x == value)
        (throw "getIndexFromEnum (okular): Value ${value} isn't present in the enum. This is a bug.")
        enum;
in
with lib.types;
{
  options.programs.okular = {
    enable = lib.mkEnableOption ''
      configuration management for okular.
    '';

    package =
      lib.mkPackageOption pkgs
        [
          "kdePackages"
          "okular"
        ]
        {
          nullable = true;
          example = "pkgs.libsForQt5.okular";
          extraDescription = ''
            Which okular package to install. Use `pkgs.libsForQt5.okular` in Plasma5 and
            `pkgs.kdePackages.okular` in Plasma6. Use `null` if home-manager should not install Okular.
          '';
        };

    # ==================================
    #     GENERAL
    general = {
      smoothScrolling = lib.mkOption {
        description = "Whether to use smooth scrolling.";
        default = null;
        type = nullOr bool;
      };

      showScrollbars = lib.mkOption {
        description = "Whether to show scrollbars in the document viewer.";
        default = null;
        type = nullOr bool;
      };

      openFileInTabs = lib.mkOption {
        description = "Whether to open files in tabs.";
        default = null;
        type = nullOr bool;
      };

      viewContinuous = lib.mkOption {
        description = "Whether to open in continous mode by default.";
        default = null;
        type = nullOr bool;
      };

      viewMode = lib.mkOption {
        description = "The view mode for the pages.";
        default = null;
        type = nullOr (enum [
          "Single"
          "Facing"
          "FacingFirstCentered"
          "Summary"
        ]);
      };

      zoomMode =
        let
          enumVals = [
            "100%"
            "fitWidth"
            "fitPage"
            "autoFit"
          ];
        in
        lib.mkOption {
          description = ''
            Specifies the default zoom mode for file which were never opened before.
            For those files which were opened before the previous zoom mode is applied.
          '';
          default = null;
          type = nullOr (enum enumVals);
          apply = getIndexFromEnum enumVals;
        };

      obeyDrm = lib.mkOption {
        description = ''
          Whether Okular should obey DRM (Digital Rights Management) restrictions.
          DRM limitations are used to make it impossible to perform certain actions with PDF documents, such as copying content to the clipboard.
          Note that in some configurations of Okular, this option is not available.
        '';
        default = null;
        type = nullOr bool;
      };

      mouseMode = lib.mkOption {
        description = ''
          Changes what the mouse does.
          See the [Okular Documentation](https://docs.kde.org/stable5/en/okular/okular/menutools.html) for the full description.

          - `Browse`: Click-and-drag with left mouse button.
          - `Zoom`: Zoom in with left mouse button. Reset zoom with right mouse button.
          - `RectSelect`: Draw area selection with left mouse button. Display options with right mouse button.
          - `TextSelect`: Select text with left mouse button. Display options with right mouse button.
          - `TableSelect`: Similar to text selection but allows for transforming the document into a table.
          - `Magnifier`: Activates the magnifier with left mouse button.
        '';
        default = null;
        type = nullOr (enum [
          "Browse"
          "Zoom"
          "RectSelect"
          "TextSelect"
          "TableSelect"
          "Magnifier"
          "TrimSelect"
        ]);
      };
    };

    # ==================================
    #     ACCESSIBILITY
    accessibility = {
      highlightLinks = lib.mkOption {
        description = "Whether to draw borders around links.";
        default = null;
        type = nullOr bool;
      };

      changeColors = {
        enable = lib.mkEnableOption "" // {
          description = "Whether to change the colors of the documents.";
        };
        mode = lib.mkOption {
          description = "Mode used to change the colors.";
          default = null;
          type = nullOr (enum [
            # Inverts colors, including hue
            "Inverted"
            # Change background color (see option below)
            "Paper"
            # Change light and dark colors (see options below)
            "Recolor"
            # Change to black & white colors (see options below)
            "BlackWhite"
            # Invert lightness but leave hue and saturation
            "InvertLightness"
            # Like InvertLightness, but slightly more contrast
            "InvertLumaSymmetric"
            # Like InvertLightness, but much more contrast
            "InvertLuma"
            # Shift hue of all colors by 120 degrees
            "HueShiftPositive"
            # Shift hue of all colors by 240 degrees
            "HueShiftNegative"
          ]);
        };
        paperColor = lib.mkOption {
          description = "Paper color in RGB. Used for the `Paper` mode.";
          default = null;
          example = "255,255,255";
          type = nullOr str;
        };
        recolorBackground = lib.mkOption {
          description = "New background color in RGB. Used for the `Recolor` mode.";
          default = null;
          example = "0,0,0";
          type = nullOr str;
        };
        recolorForeground = lib.mkOption {
          description = "New foreground color in RGB. Used for the `Recolor` mode.";
          default = null;
          example = "255,255,255";
          type = nullOr str;
        };
        blackWhiteContrast = lib.mkOption {
          description = "New contrast strength. Used for the `BlackWhite` mode.";
          default = null;
          example = 4;
          type = nullOr (ints.between 2 6);
        };
        blackWhiteThreshold = lib.mkOption {
          description = ''
            A threshold for deciding between black and white.
            Higher values lead to brighter grays.
            Used for the `BlackWhite` mode.
          '';
          default = null;
          example = 127;
          type = nullOr (numbers.between 2 253);
        };
      };
    };

    # ==================================
    #     PERFORMANCE
    performance = {
      enableTransparencyEffects = lib.mkOption {
        description = "Whether to enable transparancy effects. This may increase CPU usage.";
        default = null;
        type = nullOr bool;
      };

      memoryUsage = lib.mkOption {
        description = "Memory usage profile for Okular. This may impact the speed performance of Okular, as it determines how many computation results are kept in memory.";
        default = null;
        type = nullOr (enum [
          "Low"
          "Normal"
          "Aggressive"
          "Greedy"
        ]);
      };
    };
  };

  config = {
    home.packages = lib.mkIf (cfg.enable && cfg.package != null) [ cfg.package ];
  };

  # ==================================
  #     WRITING THE OKULARPARTRC
  config.programs.plasma.configFile."okularpartrc" = lib.mkIf cfg.enable (
    let
      gen = cfg.general;
      acc = cfg.accessibility;
      perf = cfg.performance;
      applyIfSet = opt: lib.mkIf (opt != null) opt;
    in
    {
      "PageView" = {
        "SmoothScrolling" = applyIfSet gen.smoothScrolling;
        "ShowScrollBars" = applyIfSet gen.showScrollbars;
        "ViewContinuous" = applyIfSet gen.viewContinuous;
        "ViewMode" = applyIfSet gen.viewMode;
        "MouseMode" = applyIfSet gen.mouseMode;
      };

      "Zoom" = {
        "ZoomMode" = applyIfSet gen.zoomMode;
      };
      "Core General" = {
        "ObeyDRM" = applyIfSet gen.obeyDrm;
      };

      "General" = {
        "ShellOpenFileInTabs" = applyIfSet gen.openFileInTabs;
      };

      "Document" = {
        "ChangeColors" = applyIfSet acc.changeColors.enable;
        "RenderMode" = applyIfSet acc.changeColors.mode;
        "PaperColor" = applyIfSet acc.changeColors.paperColor;
      };

      "Dlg Accessibility" = {
        "HighlightLinks" = applyIfSet acc.highlightLinks;
        "RecolorBackground" = applyIfSet acc.changeColors.recolorBackground;
        "RecolorForeground" = applyIfSet acc.changeColors.recolorForeground;
        "BWContrast" = applyIfSet acc.changeColors.blackWhiteContrast;
        "BWThreshold" = applyIfSet acc.changeColors.blackWhiteThreshold;
      };

      "Core Performance" = {
        "MemoryLevel" = applyIfSet perf.memoryUsage;
      };

      "Dlg Performance" = {
        "EnableCompositing" = applyIfSet perf.enableTransparencyEffects;
      };
    }
  );
}
</file>

<file path="modules/widgets/app-menu.nix">
{ lib, ... }:
let
  inherit (import ./lib.nix { inherit lib; }) configValueType;
  inherit (import ./default.nix { inherit lib; }) positionType sizeType;

  mkBoolOption =
    description:
    lib.mkOption {
      type = with lib.types; nullOr bool;
      default = null;
      example = true;
      inherit description;
    };
in
{
  appMenu = {
    opts = {
      position = lib.mkOption {
        type = positionType;
        example = {
          horizontal = 100;
          vertical = 300;
        };
        description = "The position of the widget. (Only for desktop widget)";
      };
      size = lib.mkOption {
        type = sizeType;
        example = {
          width = 500;
          height = 50;
        };
        description = "The size of the widget. (Only for desktop widget)";
      };
      compactView = mkBoolOption "Whether to show the app menu in a compact view";
      settings = lib.mkOption {
        type = configValueType;
        default = null;
        example = {
          Appearance = {
            compactView = true;
          };
        };
        description = ''
          Extra configuration for the widget
        '';
        apply = settings: if settings == null then { } else settings;
      };
    };

    convert =
      { compactView, settings, ... }:
      {
        name = "org.kde.plasma.appmenu";
        config = lib.recursiveUpdate {
          General = lib.filterAttrs (_: v: v != null) { inherit compactView; };
        } settings;
      };
  };
}
</file>

<file path="modules/widgets/application-title-bar.nix">
{ lib, ... }:
let
  inherit (import ./lib.nix { inherit lib; }) configValueType;
  inherit (import ./default.nix { inherit lib; }) positionType sizeType;

  elements = [
    "windowCloseButton"
    "windowMinimizeButton"
    "windowMaximizeButton"
    "windowKeepAboveButton"
    "windowKeepBelowButton"
    "windowShadeButton"
    "windowTitle"
    "windowIcon"
    "spacer"
  ];

  horizontalAlignment = [
    "left"
    "right"
    "center"
    "justify"
  ];

  windowTitleSources = [
    "appName"
    "decoration"
    "genericAppName"
    "alwaysUndefined"
  ];

  mkBoolOption =
    description:
    lib.mkOption {
      type = with lib.types; nullOr bool;
      default = null;
      inherit description;
    };

  convertHorizontalAlignment =
    horizontalAlignment:
    let
      mappings = {
        left = 1;
        right = 2;
        center = 4;
        justify = 8;
      };
    in
    if horizontalAlignment == null then
      null
    else
      mappings.${horizontalAlignment} or (throw "Invalid enum value: ${horizontalAlignment}");

  convertVerticalAlignment =
    verticalAlignment:
    let
      mappings = {
        top = 1;
        center = 128;
        bottom = 64;
        baseline = 256;
      };
    in
    if verticalAlignment == null then
      null
    else
      mappings.${verticalAlignment} or (throw "Invalid enum value: ${verticalAlignment}");

  getIndexFromEnum =
    enum: value:
    if value == null then
      null
    else
      lib.lists.findFirstIndex (x: x == value)
        (throw "getIndexFromEnum (application-title-bar widget): Value ${value} isn't present in the enum. This is a bug")
        enum;

  capitalizeWord =
    word:
    let
      firstLetter = builtins.substring 0 1 word;
      rest = builtins.substring 1 (builtins.stringLength word - 1) word;
    in
    if word == null then null else "${lib.toUpper firstLetter}${rest}";

  fontType = lib.types.submodule {
    options = {
      bold = mkBoolOption "Enable bold text.";
      fit =
        let
          enumVals = [
            "fixedSize"
            "horizontalFit"
            "verticalFit"
            "fit"
          ];
        in
        lib.mkOption {
          type = with lib.types; nullOr (enum enumVals);
          default = null;
          example = "fixedSize";
          description = "The mode of the size of the font.";
          apply = getIndexFromEnum enumVals;
        };
      size = lib.mkOption {
        type = lib.types.ints.positive;
        default = 10;
        description = "The size of the font.";
      };
    };
  };

  marginType = lib.types.submodule {
    options = {
      left = lib.mkOption {
        type = lib.types.ints.unsigned;
        default = 10;
        description = "The left margin.";
      };
      right = lib.mkOption {
        type = lib.types.ints.unsigned;
        default = 10;
        description = "The right margin.";
      };
      top = lib.mkOption {
        type = lib.types.ints.unsigned;
        default = 0;
        description = "The top margin.";
      };
      bottom = lib.mkOption {
        type = lib.types.ints.unsigned;
        default = 0;
        description = "The bottom margin.";
      };
    };
  };

  titleReplacementType = lib.types.submodule {
    options = {
      type =
        let
          enumVals = [
            "string"
            "regexp"
          ];
        in
        lib.mkOption {
          type = lib.types.enum enumVals;
          default = null;
          example = "string";
          description = "The type of the replacement.";
          apply = getIndexFromEnum enumVals;
        };
      originalTitle = lib.mkOption {
        type = lib.types.str;
        example = "Brave Web Browser";
        description = "The original text to replace.";
      };
      newTitle = lib.mkOption {
        type = lib.types.str;
        example = "Brave";
        description = "The new text to replace with.";
      };
    };
  };
in
{
  applicationTitleBar = {
    description = "KDE plasmoid with window title and buttons";

    opts = {
      position = lib.mkOption {
        type = positionType;
        example = {
          horizontal = 100;
          vertical = 300;
        };
        description = "The position of the widget. (Only for desktop widget)";
      };
      size = lib.mkOption {
        type = sizeType;
        example = {
          width = 500;
          height = 50;
        };
        description = "The size of the widget. (Only for desktop widget)";
      };
      layout = {
        widgetMargins = lib.mkOption {
          type = with lib.types; nullOr ints.unsigned;
          default = null;
          description = "The margins around the widget.";
        };
        spacingBetweenElements = lib.mkOption {
          type = with lib.types; nullOr ints.unsigned;
          default = null;
          description = "The spacing between elements.";
        };
        horizontalAlignment = lib.mkOption {
          type = with lib.types; nullOr (enum horizontalAlignment);
          default = null;
          example = "left";
          description = "The horizontal alignment of the widget.";
          apply = convertHorizontalAlignment;
        };
        verticalAlignment = lib.mkOption {
          type =
            with lib.types;
            nullOr (enum [
              "top"
              "center"
              "bottom"
              "baseline"
            ]);
          default = null;
          example = "center";
          description = "The vertical alignment of the widget.";
          apply = convertVerticalAlignment;
        };
        showDisabledElements =
          let
            enumVals = [
              "deactivated"
              "hideKeepSpace"
              "hide"
            ];
          in
          lib.mkOption {
            type = with lib.types; nullOr (enum enumVals);
            default = null;
            example = "deactivated";
            description = "How to show the elements when the widget is disabled.";
            apply = getIndexFromEnum enumVals;
          };
        fillFreeSpace = mkBoolOption "Whether the widget should fill the free space on the panel.";
        elements = lib.mkOption {
          type = with lib.types; nullOr (listOf (enum elements));
          default = null;
          example = [ "windowTitle" ];
          description = ''
            The elements to show in the widget.
          '';
        };
      };
      windowControlButtons = {
        iconSource =
          let
            enumVals = [
              "plasma"
              "breeze"
              "aurorae"
              "oxygen"
            ];
          in
          lib.mkOption {
            type = with lib.types; nullOr (enum enumVals);
            default = null;
            example = "plasma";
            description = ''
              The icon source for the control buttons.

              - Plasma: Global icon theme
              - Breeze: Implicit Breeze icons
              - Aurorae: Window decorations theme
              - Oxygen: Implicit Oxygen icons
            '';
            apply = getIndexFromEnum enumVals;
          };
        auroraeTheme = lib.mkOption {
          type = with lib.types; nullOr str;
          default = null;
          description = "The Aurorae theme to use for the control buttons.";
        };
        buttonsMargin = lib.mkOption {
          type = with lib.types; nullOr ints.unsigned;
          default = null;
          description = "The margin around the buttons.";
        };
        buttonsAspectRatio = lib.mkOption {
          type = with lib.types; nullOr ints.unsigned;
          default = null;
          description = "The ratio of button width in percent to 100% of its height. If you need wider buttons, the value should be >100, otherwise less.";
        };
        buttonsAnimationSpeed = lib.mkOption {
          type = with lib.types; nullOr ints.unsigned;
          default = null;
          description = "The speed of the buttons animation in milliseconds.";
        };
      };
      windowTitle = {
        minimumWidth = lib.mkOption {
          type = with lib.types; nullOr ints.unsigned;
          default = null;
          description = "The minimum width of the window title.";
        };
        maximumWidth = lib.mkOption {
          type = with lib.types; nullOr ints.unsigned;
          default = null;
          description = "The maximum width of the window title.";
        };
        font = lib.mkOption {
          type = lib.types.nullOr fontType;
          default = null;
          example = {
            bold = false;
            fit = "FixedSize";
            size = 11;
          };
          description = "The font settings of the window title.";
          apply =
            font:
            lib.optionalAttrs (font != null) {
              windowTitleFontBold = font.bold;
              windowTitleFontSize = font.size;
              windowTitleFontSizeMode = font.fit;
            };
        };
        hideEmptyTitle = mkBoolOption "Whether to hide the window title when it's empty.";
        undefinedWindowTitle = lib.mkOption {
          type = with lib.types; nullOr str;
          default = null;
          example = "Plasma";
          description = "The text to show when the window title is undefined.";
        };
        source = lib.mkOption {
          type = with lib.types; nullOr (enum windowTitleSources);
          default = null;
          example = "appName";
          description = ''
            The source of the window title.

            - appName: The name of the application
            - decoration: The title of the window decoration
            - genericAppName: The generic name of the application
            - alwaysUndefined: Always show the undefined title
          '';
          apply = getIndexFromEnum windowTitleSources;
        };
        margins = lib.mkOption {
          type = lib.types.nullOr marginType;
          default = null;
          example = {
            left = 10;
            right = 10;
            top = 0;
            bottom = 0;
          };
          description = "The margins around the window title.";
          apply =
            margins:
            lib.optionalAttrs (margins != null) {
              windowTitleMarginsLeft = margins.left;
              windowTitleMarginsRight = margins.right;
              windowTitleMarginsTop = margins.top;
              windowTitleMarginsBottom = margins.bottom;
            };
        };
        horizontalAlignment = lib.mkOption {
          type = with lib.types; nullOr (enum horizontalAlignment);
          default = null;
          example = "left";
          description = "The horizontal alignment of the window title.";
          apply = capitalizeWord;
        };
        verticalAlignment =
          let
            enumVals = [
              "top"
              "bottom"
              "center"
            ];
          in
          lib.mkOption {
            type = with lib.types; nullOr (enum enumVals);
            default = null;
            example = "center";
            description = "The vertical alignment of the window title.";
            apply = capitalizeWord;
          };
      };
      overrideForMaximized = {
        enable = mkBoolOption "Whether to override the settings for maximized windows.";
        elements = lib.mkOption {
          type = with lib.types; nullOr (types.listOf (types.enum elements));
          default = null;
          example = [ "windowTitle" ];
          description = ''
            The elements to show in the widget for maximized windows.
          '';
        };
        source = lib.mkOption {
          type = with lib.types; nullOr (enum windowTitleSources);
          default = null;
          example = "appName";
          description = ''
            The source of the window title for maximized windows.

            - appName: The name of the application
            - decoration: The title of the window decoration
            - genericAppName: The generic name of the application
            - alwaysUndefined: Always show the undefined title
          '';
          apply = getIndexFromEnum windowTitleSources;
        };
      };
      behavior = {
        activeTaskSource =
          let
            enumVals = [
              "activeTask"
              "lastActiveTask"
              "lastActiveMaximized"
            ];
          in
          lib.mkOption {
            type = with lib.types; nullOr (enum enumVals);
            default = null;
            example = "activeTask";
            description = ''
              The source of the active task.

              - activeTask: The active task
              - lastActiveTask: The last active task
              - lastActiveMaximized: The last active maximized task
            '';
            apply = getIndexFromEnum enumVals;
          };
        filterByActivity = mkBoolOption "Whether to filter the tasks by activity.";
        filterByScreen = mkBoolOption "Whether to filter the tasks by screen.";
        filterByVirtualDesktop = mkBoolOption "Whether to filter the tasks by virtual desktop.";
        disableForNotMaximized = mkBoolOption "Whether to disable the tasks that are not maximized.";
        disableButtonsForNotHovered = mkBoolOption "Whether to disable the buttons for not hovered tasks.";
      };
      mouseAreaDrag = {
        enable = mkBoolOption "Whether to enable dragging the widget by the mouse area.";
        onlyMaximized = mkBoolOption "Whether to allow dragging the widget only for maximized windows.";
        threshold = lib.mkOption {
          type = with lib.types; nullOr ints.unsigned;
          default = null;
          description = "The threshold for dragging the widget.";
        };
        leftDragAction = lib.mkOption {
          type = with lib.types; nullOr str;
          default = null;
          description = "The action to perform on left click drag.";
        };
        middleDragAction = lib.mkOption {
          type = with lib.types; nullOr str;
          default = null;
          description = "The action to perform on middle click drag.";
        };
      };
      mouseAreaClick = {
        enable = mkBoolOption "Whether to enable clicking the widget by the mouse area.";
        leftButtonClick = lib.mkOption {
          type = with lib.types; nullOr str;
          default = null;
          description = "The action to perform on left click.";
        };
        leftButtonDoubleClick = lib.mkOption {
          type = with lib.types; nullOr str;
          default = null;
          description = "The action to perform on left double click.";
        };
        leftButtonLongClick = lib.mkOption {
          type = with lib.types; nullOr str;
          default = null;
          description = "The action to perform on left long press.";
        };
        middleButtonClick = lib.mkOption {
          type = with lib.types; nullOr str;
          default = null;
          description = "The action to perform on middle click.";
        };
        middleButtonDoubleClick = lib.mkOption {
          type = with lib.types; nullOr str;
          default = null;
          description = "The action to perform on middle double click.";
        };
        middleButtonLongClick = lib.mkOption {
          type = with lib.types; nullOr str;
          default = null;
          description = "The action to perform on middle long press.";
        };
      };
      mouseAreaWheel = {
        enable = mkBoolOption "Whether to enable scrolling the widget by the mouse area.";
        firstEventDistance = lib.mkOption {
          type = with lib.types; nullOr ints.unsigned;
          default = null;
          description = "The distance of the first event.";
        };
        nextEventDistance = lib.mkOption {
          type = with lib.types; nullOr ints.unsigned;
          default = null;
          description = "The distance of the next event.";
        };
        wheelUp = lib.mkOption {
          type = with lib.types; nullOr str;
          default = null;
          description = "The action to perform on wheel up.";
        };
        wheelDown = lib.mkOption {
          type = with lib.types; nullOr str;
          default = null;
          description = "The action to perform on wheel down.";
        };
        wheelLeft = lib.mkOption {
          type = with lib.types; nullOr str;
          default = null;
          description = "The action to perform on wheel left.";
        };
        wheelRight = lib.mkOption {
          type = with lib.types; nullOr str;
          default = null;
          description = "The action to perform on wheel right.";
        };
      };
      titleReplacements = lib.mkOption {
        type = with lib.types; nullOr (listOf titleReplacementType);
        default = null;
        example = [
          {
            type = "string";
            originalTitle = "Brave Web Browser";
            newTitle = "Brave";
          }
          {
            type = "regexp";
            originalTitle = ''\\bDolphin\\b'';
            newTitle = "File manager";
          }
        ];
        description = "The replacements for the window title.";
        apply =
          replacements:
          lib.optionalAttrs (replacements != null) {
            titleReplacementsPatterns = map (r: r.originalTitle) replacements;
            titleReplacementsTemplates = map (r: r.newTitle) replacements;
            titleReplacementsTypes = map (r: r.type) replacements;
          };
      };
      settings = lib.mkOption {
        type = configValueType;
        default = null;
        example = {
          Appearance = {
            windowTitleUndefined = "Plasma";
          };
        };
        description = ''
          Extra configuration for the widget

          See available options at https://github.com/antroids/application-title-bar/blob/main/package/contents/config/main.xml
        '';
        apply = settings: if settings == null then { } else settings;
      };
    };
    convert =
      {
        layout,
        windowControlButtons,
        windowTitle,
        overrideForMaximized,
        behavior,
        mouseAreaDrag,
        mouseAreaClick,
        mouseAreaWheel,
        titleReplacements,
        settings,
        ...
      }:
      {
        name = "com.github.antroids.application-title-bar";
        config = lib.recursiveUpdate {
          Appearance = lib.filterAttrs (_: v: v != null) (
            {
              # Widget layout
              widgetMargins = layout.widgetMargins;
              widgetSpacing = layout.spacingBetweenElements;
              widgetHorizontalAlignment = layout.horizontalAlignment;
              widgetVerticalAlignment = layout.verticalAlignment;
              widgetElementsDisabledMode = layout.showDisabledElements;
              widgetFillWidth = layout.fillFreeSpace;
              widgetElements = layout.elements;

              # Window control buttons
              widgetButtonsIconsTheme = windowControlButtons.iconSource;
              widgetButtonsAuroraeTheme = windowControlButtons.auroraeTheme;
              widgetButtonsMargins = windowControlButtons.buttonsMargin;
              widgetButtonsAspectRatio = windowControlButtons.buttonsAspectRatio;
              widgetButtonsAnimation = windowControlButtons.buttonsAnimationSpeed;

              # Window title
              windowTitleMinimumWidth = windowTitle.minimumWidth;
              windowTitleMaximumWidth = windowTitle.maximumWidth;
              windowTitleHideEmpty = windowTitle.hideEmptyTitle;
              windowTitleUndefined = windowTitle.undefinedWindowTitle;
              windowTitleSource = windowTitle.source;
              windowTitleHorizontalAlignment = windowTitle.horizontalAlignment;
              windowTitleVerticalAlignment = windowTitle.verticalAlignment;

              # Override for maximized windows
              overrideElementsMaximized = overrideForMaximized.enable;
              widgetElementsMaximized = overrideForMaximized.elements;
              windowTitleSourceMaximized = overrideForMaximized.source;
            }
            // windowTitle.font
            // windowTitle.margins
          );
          Behavior = lib.filterAttrs (_: v: v != null) {
            # Behavior
            widgetActiveTaskSource = behavior.activeTaskSource;
            widgetActiveTaskFilterByActivity = behavior.filterByActivity;
            widgetActiveTaskFilterByScreen = behavior.filterByScreen;
            widgetActiveTaskFilterByVirtualDesktop = behavior.filterByVirtualDesktop;
            widgetActiveTaskFilterNotMaximized = behavior.disableForNotMaximized;
            disableButtonsForNotHoveredWidget = behavior.disableButtonsForNotHovered;

            # Mouse area drag
            windowTitleDragEnabled = mouseAreaDrag.enable;
            windowTitleDragOnlyMaximized = mouseAreaDrag.onlyMaximized;
            windowTitleDragThreshold = mouseAreaDrag.threshold;
            widgetMouseAreaLeftDragAction = mouseAreaDrag.leftDragAction;
            widgetMouseAreaMiddleDragAction = mouseAreaDrag.middleDragAction;

            # Mouse area click
            widgetMouseAreaClickEnabled = mouseAreaClick.enable;
            widgetMouseAreaLeftClickAction = mouseAreaClick.leftButtonClick;
            widgetMouseAreaLeftDoubleClickAction = mouseAreaClick.leftButtonDoubleClick;
            widgetMouseAreaLeftLongPressAction = mouseAreaClick.leftButtonLongClick;
            widgetMouseAreaMiddleClickAction = mouseAreaClick.middleButtonClick;
            widgetMouseAreaMiddleDoubleClickAction = mouseAreaClick.middleButtonDoubleClick;
            widgetMouseAreaMiddleLongPressAction = mouseAreaClick.middleButtonLongClick;

            # Mouse area wheel
            widgetMouseAreaWheelEnabled = mouseAreaWheel.enable;
            widgetMouseAreaWheelFirstEventDistance = mouseAreaWheel.firstEventDistance;
            widgetMouseAreaWheelNextEventDistance = mouseAreaWheel.nextEventDistance;
            widgetMouseAreaWheelUpAction = mouseAreaWheel.wheelUp;
            widgetMouseAreaWheelDownAction = mouseAreaWheel.wheelDown;
            widgetMouseAreaWheelLeftAction = mouseAreaWheel.wheelLeft;
            widgetMouseAreaWheelRightAction = mouseAreaWheel.wheelRight;
          };
          TitleReplacements = titleReplacements;
        } settings;
      };
  };
}
</file>

<file path="modules/widgets/battery.nix">
{ lib, ... }:
let
  inherit (import ./lib.nix { inherit lib; }) configValueType;
  inherit (import ./default.nix { inherit lib; }) positionType sizeType;
in
{
  battery = {
    description = "The battery indicator widget.";

    # See https://invent.kde.org/plasma/plasma-workspace/-/blob/master/applets/batterymonitor/package/contents/config/main.xml for the accepted raw options
    opts = {
      position = lib.mkOption {
        type = positionType;
        example = {
          horizontal = 250;
          vertical = 50;
        };
        description = "The position of the widget. (Only for desktop widget)";
      };
      size = lib.mkOption {
        type = sizeType;
        example = {
          width = 500;
          height = 500;
        };
        description = "The size of the widget. (Only for desktop widget)";
      };
      showPercentage = lib.mkOption {
        type = with lib.types; nullOr bool;
        default = null;
        example = true;
        description = "Enable to show the battery percentage as a small label over the battery icon.";
      };
      settings = lib.mkOption {
        type = configValueType;
        default = null;
        example = {
          General = {
            showPercentage = true;
          };
        };
        apply = settings: if settings == null then { } else settings;
      };
    };

    convert =
      { showPercentage, settings, ... }:
      {
        name = "org.kde.plasma.battery";
        config = lib.recursiveUpdate {
          General = lib.filterAttrs (_: v: v != null) { inherit showPercentage; };
        } settings;
      };
  };
}
</file>

<file path="modules/widgets/default.nix">
{ lib, ... }@args:
let
  args' = args // {
    widgets = self;
  };

  sources = lib.attrsets.mergeAttrsList (
    map (s: import s args') [
      ./app-menu.nix
      ./application-title-bar.nix
      ./battery.nix
      ./digital-clock.nix
      ./icon-tasks.nix
      ./keyboard-layout.nix
      ./kicker.nix
      ./kickerdash.nix
      ./kickoff.nix
      ./pager.nix
      ./panel-spacer.nix
      ./plasma-panel-colorizer.nix
      ./plasmusic-toolbar.nix
      ./system-monitor.nix
      ./system-tray.nix
    ]
  );

  positionType = lib.types.submodule {
    options = {
      horizontal = lib.mkOption {
        type = lib.types.ints.unsigned;
        example = 500;
        description = "The horizontal position of the widget.";
      };
      vertical = lib.mkOption {
        type = lib.types.ints.unsigned;
        example = 500;
        description = "The vertical position of the widget.";
      };
    };
  };

  sizeType = lib.types.submodule {
    options = {
      width = lib.mkOption {
        type = lib.types.ints.unsigned;
        example = 500;
        description = "The width of the widget.";
      };
      height = lib.mkOption {
        type = lib.types.ints.unsigned;
        example = 500;
        description = "The height of the widget.";
      };
    };
  };

  compositeWidgetType = lib.pipe sources [
    (builtins.mapAttrs (
      _: s:
      lib.mkOption {
        inherit (s) description;
        type = lib.types.submodule (submoduleArgs: {
          options = if builtins.isFunction s.opts then s.opts submoduleArgs else s.opts;
        });
      }
    ))
    lib.types.attrTag
  ];

  simpleWidgetType = lib.types.submodule {
    options = {
      name = lib.mkOption {
        type = lib.types.str;
        example = "org.kde.plasma.kickoff";
        description = "The name of the widget to add.";
      };
      config = lib.mkOption {
        type = (import ./lib.nix (args // { widgets = self; })).configValueType;
        default = null;
        example = {
          General.icon = "nix-snowflake-white";
        };
        description = ''
          Configuration options for the widget.

          See https://develop.kde.org/docs/plasma/scripting/keys/ for an (incomplete) list of options
          that can be set here.
        '';
      };
      extraConfig = lib.mkOption {
        type = lib.types.lines;
        default = "";
        example = ''
          (widget) => {
            widget.currentConfigGroup = ["General"];
            widget.writeConfig("title", "My widget");
          }
        '';
        description = ''
          Extra configuration for the widget in JavaScript.

          Should be a lambda/anonymous function that takes the widget as its sole argument,
          which can then be called by the script.
        '';
      };
    };
  };

  desktopSimpleWidgetType = lib.types.submodule {
    options = {
      name = lib.mkOption {
        type = lib.types.str;
        example = "org.kde.plasma.kickoff";
        description = "The name of the widget to add.";
      };
      position = lib.mkOption {
        type = positionType;
        example = {
          horizontal = 500;
          vertical = 500;
        };
        description = "The position of the widget.";
      };
      size = lib.mkOption {
        type = sizeType;
        example = {
          width = 500;
          height = 500;
        };
        description = "The size of the widget.";
      };
      config = lib.mkOption {
        type = (import ./lib.nix (args // { widgets = self; })).configValueType;
        default = null;
        example = {
          General.icon = "nix-snowflake-white";
        };
        description = ''
          Configuration options for the widget.

          See https://develop.kde.org/docs/plasma/scripting/keys/ for an (incomplete) list of options
          that can be set here.
        '';
      };
      extraConfig = lib.mkOption {
        type = lib.types.lines;
        default = "";
        example = ''
          (widget) => {
            widget.currentConfigGroup = ["General"];
            widget.writeConfig("title", "My widget");
          }
        '';
        description = ''
          Extra configuration for the widget in JavaScript.

          Should be a lambda/anonymous function that takes the widget as its sole argument,
          which can then be called by the script.
        '';
      };
    };
  };

  isKnownWidget = lib.flip builtins.hasAttr sources;

  self = {
    inherit isKnownWidget positionType sizeType;

    type = lib.types.oneOf [
      lib.types.str
      compositeWidgetType
      simpleWidgetType
    ];
    desktopType = lib.types.oneOf [
      compositeWidgetType
      desktopSimpleWidgetType
    ];

    lib = import ./lib.nix (args // { widgets = self; });

    desktopConvert =
      widget:
      let
        inherit (builtins)
          length
          head
          attrNames
          mapAttrs
          isAttrs
          ;
        keys = attrNames widget;
        type = head keys;

        base = {
          config = null;
          extraConfig = "";
        };
        converters = mapAttrs (_: s: s.convert) sources;
      in
      if isAttrs widget && length keys == 1 && isKnownWidget type then
        let
          convertedWidget = converters.${type} widget.${type};
        in
        base
        // convertedWidget
        // {
          position =
            if isAttrs widget.${type}.position then
              widget.${type}.position
            else
              (throw "Desktop widget requires a position");
          size =
            if isAttrs widget.${type}.size then
              widget.${type}.size
            else
              (throw "Desktop widget requires a size");
        }
      else
        widget; # not a known composite type

    convert =
      widget:
      let
        inherit (builtins)
          length
          head
          attrNames
          mapAttrs
          isAttrs
          isString
          ;
        keys = attrNames widget;
        type = head keys;

        base = {
          config = null;
          extraConfig = "";
        };
        converters = mapAttrs (_: s: s.convert) sources;
      in
      if isString widget then
        base // { name = widget; }
      else if isAttrs widget && length keys == 1 && isKnownWidget type then
        base // converters.${type} widget.${type}
      else
        widget; # not a known composite type
  };
in
self
</file>

<file path="modules/widgets/digital-clock.nix">
{ lib, ... }:
let
  inherit (lib) mkOption types;
  inherit (import ./lib.nix { inherit lib; }) configValueType;
  inherit (import ./default.nix { inherit lib; }) positionType sizeType;

  mkBoolOption =
    description:
    mkOption {
      type = with types; nullOr bool;
      default = null;
      inherit description;
    };

  getIndexFromEnum =
    enum: value:
    if value == null then
      null
    else
      lib.lists.findFirstIndex (x: x == value)
        (throw "getIndexFromEnum (digital-clock widget): Value ${value} isn't present in the enum. This is a bug")
        enum;

  fontType = types.submodule {
    options = {
      family = mkOption {
        type = types.str;
        example = "Noto Sans";
        description = "The family of the font.";
      };
      bold = mkBoolOption "Enable bold text.";
      italic = mkBoolOption "Enable italic text.";
      weight = mkOption {
        type = types.ints.between 1 1000;
        default = 50;
        description = "The weight of the font.";
      };
      style = mkOption {
        type = types.nullOr types.str;
        default = null;
        description = "The custom style of the font.";
      };
      size = mkOption {
        type = types.ints.positive;
        default = 10;
        description = "The size of the font.";
      };
    };
  };
in
{
  digitalClock = {
    description = "A digital clock widget.";

    opts = {
      # See https://invent.kde.org/plasma/plasma-workspace/-/blob/master/applets/digital-clock/package/contents/config/main.xml for the accepted raw options

      position = mkOption {
        type = positionType;
        example = {
          horizontal = 250;
          vertical = 50;
        };
        description = "The position of the widget. (Only for desktop widget)";
      };
      size = mkOption {
        type = sizeType;
        example = {
          width = 500;
          height = 500;
        };
        description = "The size of the widget. (Only for desktop widget)";
      };
      date = {
        enable = mkBoolOption "Enable showing the current date.";

        format =
          let
            enumVals = [
              "shortDate"
              "longDate"
              "isoDate"
            ];
          in
          mkOption {
            type =
              with types;
              nullOr (
                either (enum enumVals) (submodule {
                  options.custom = mkOption {
                    type = str;
                    example = "ddd d";
                    description = "The custom date format to use.";
                  };
                })
              );
            default = null;
            example = {
              custom = "d.MM.yyyy";
            };
            description = ''
              The date format used for this clock.

              Could be as a short date, long date, a ISO 8601 date (yyyy-mm-dd), or a custom date format.
              Short and long date formats are locale-dependent.
            '';
            apply =
              f:
              if f == null then
                { }
              else if f ? custom then
                {
                  dateFormat = "custom";
                  customDateFormat = f.custom;
                }
              else
                { dateFormat = f; };
          };

        position =
          let
            enumVals = [
              "adaptive"
              "besideTime"
              "belowTime"
            ];
          in
          mkOption {
            type = with types; nullOr (enum enumVals);
            default = null;
            example = "belowTime";
            description = ''
              The position where the date is displayed.

              Could be adaptive, always beside the displayed time, or below the displayed time.
            '';
            apply = getIndexFromEnum enumVals;
          };
      };

      time = {
        showSeconds =
          let
            enumVals = [
              "never"
              "onlyInTooltip"
              "always"
            ];
          in
          mkOption {
            type = with types; nullOr (enum enumVals);
            default = null;
            example = "always";
            description = ''
              When and where the seconds should be shown on the clock.

              Could be never, only in the tooltip on hover, or always.
            '';
            apply = getIndexFromEnum enumVals;
          };
        format =
          let
            enumVals = [
              "12h"
              "default"
              "24h"
            ];
          in
          mkOption {
            type = with types; nullOr (enum enumVals);
            default = null;
            example = "24h";
            description = ''
              The time format used for this clock.

              Could be 12-hour, the default for your locale, or 24-hour.
            '';
            apply = getIndexFromEnum enumVals;
          };
      };

      timeZone = {
        selected = mkOption {
          type = with types; nullOr (listOf str);
          default = null;
          example = [
            "Europe/Berlin"
            "Asia/Shanghai"
          ];
          description = ''
            The timezones that are configured for this clock.

            The special value "Local" indicates the system's current timezone.
          '';
        };
        lastSelected = mkOption {
          type = with types; nullOr str;
          default = null;
          description = ''
            The timezone to show upon widget restore.

            The special value "Local" indicates the system's current timezone.
          '';
        };
        changeOnScroll = mkBoolOption "Allow changing the displayed timezone by scrolling on the widget with the mouse wheel.";
        format =
          let
            enumVals = [
              "code"
              "city"
              "offset"
            ];
          in
          mkOption {
            type = with types; nullOr (enum enumVals);
            default = null;
            example = "code";
            description = ''
              The format of the timezone displayed, whether as a
              code, full name of the city that the timezone belongs to,
              or as an UTC offset.

              For example, for the timezone Asia/Shanghai, the three formats
              listed above would display "CST", "Shanghai" and "+8" respectively.
            '';
            apply = getIndexFromEnum enumVals;
          };
        alwaysShow = mkBoolOption "Always show the selected timezone, when it's the same with the system timezone";
      };

      calendar = {
        firstDayOfWeek =
          let
            enumVals = [
              "sunday"
              "monday"
              "tuesday"
              "wednesday"
              "thursday"
              "friday"
              "saturday"
            ];
          in
          mkOption {
            type = with types; nullOr (enum enumVals);
            default = null;
            example = "monday";
            description = ''
              The first day of the week that the calendar uses.

              If null, then the default for the user locale is used.
            '';
            apply = getIndexFromEnum enumVals;
          };
        plugins = mkOption {
          type = types.nullOr (types.listOf types.str);
          default = null;
          description = "List of enabled calendar plugins, where additional event data can be sourced from.";
        };
        showWeekNumbers = mkBoolOption "Enable showing week numbers in the calendar";
      };

      font = mkOption {
        type = types.nullOr fontType;
        default = null;
        example = {
          family = "Noto Sans";
          bold = true;
          size = 16;
        };
        description = ''
          The font used for this clock.

          If null, then it will use the system font and automatically expand to fill available space.
        '';
        apply =
          font:
          {
            autoFontAndSize = (font == null);
          }
          // lib.optionalAttrs (font != null) {
            fontFamily = font.family;
            boldText = font.bold;
            italicText = font.italic;
            fontWeight = font.weight;
            fontStyleName = font.style;
            fontSize = font.size;
          };
      };
      settings = mkOption {
        type = configValueType;
        default = null;
        example = {
          Appearance = {
            showDate = true;
          };
        };
        description = ''
          Extra configuration options for the widget.

          See https://develop.kde.org/docs/plasma/scripting/keys/ for an list of options
        '';
        apply = settings: if settings == null then { } else settings;
      };
    };

    convert =
      {
        date,
        time,
        timeZone,
        calendar,
        font,
        settings,
        ...
      }:
      {
        name = "org.kde.plasma.digitalclock";
        config = lib.recursiveUpdate {
          Appearance = lib.filterAttrs (_: v: v != null) (
            {
              showDate = date.enable;
              dateDisplayFormat = date.position;

              showSeconds = time.showSeconds;
              use24hFormat = time.format;

              selectedTimeZones = timeZone.selected;
              lastSelectedTimezone = timeZone.lastSelected;
              wheelChangesTimezone = timeZone.changeOnScroll;
              displayTimezoneFormat = timeZone.format;
              showLocalTimezone = timeZone.alwaysShow;

              firstDayOfWeek = calendar.firstDayOfWeek;
              enabledCalendarPlugins = calendar.plugins;
              showWeekNumbers = calendar.showWeekNumbers;
            }
            // date.format
            // font
          );
        } settings;
      };
  };
}
</file>

<file path="modules/widgets/icon-tasks.nix">
{ lib, ... }:
let
  inherit (lib) mkOption types;
  inherit (import ./lib.nix { inherit lib; }) configValueType;
  inherit (import ./default.nix { inherit lib; }) positionType sizeType;

  mkBoolOption =
    description:
    mkOption {
      type = with types; nullOr bool;
      default = null;
      inherit description;
    };

  convertSpacing =
    spacing:
    let
      mappings = {
        small = 0;
        medium = 1;
        large = 3;
      };
    in
    if spacing == null then
      null
    else if builtins.isString spacing then
      mappings.${spacing} or (throw "Invalid spacing: ${spacing}")
    else
      spacing;

  getIndexFromEnum =
    enum: value:
    if value == null then
      null
    else
      lib.lists.findFirstIndex (x: x == value)
        (throw "getIndexFromEnum (icon-tasks widget): Value ${value} isn't present in the enum. This is a bug")
        enum;

  positionToReverse =
    position:
    let
      mappings = {
        left = true;
        right = false;
      };
    in
    if position == null then null else mappings.${position} or (throw "Invalid position: ${position}");
in
{
  iconTasks = {
    description = "Icons Only Task Manager shows tasks only by their icon and not by icon and title of the window opened.";

    opts = {
      position = mkOption {
        type = positionType;
        example = {
          horizontal = 250;
          vertical = 50;
        };
        description = "The position of the widget. (Only for desktop widget)";
      };
      size = mkOption {
        type = sizeType;
        example = {
          width = 500;
          height = 500;
        };
        description = "The size of the widget. (Only for desktop widget)";
      };
      launchers = mkOption {
        type = types.nullOr (types.listOf types.str);
        default = null;
        example = [
          "applications:org.kde.dolphin.desktop"
          "applications:org.kde.konsole.desktop"
        ];
        description = "The list of launcher tasks on the widget. Usually .desktop file or executable URLs. Special URLs such as preferred://browser that expand to default applications are supported.";
      };
      iconsOnly = mkOption {
        type = types.bool;
        default = true;
        example = false;
        description = "Whether to show icons only.";
      };
      appearance = {
        showTooltips = mkBoolOption "Whether to show tooltips when hovering task buttons.";
        highlightWindows = mkBoolOption "Whether to request the window manager highlight windows when hovering corresponding task tooltips.";
        indicateAudioStreams = mkBoolOption "Whether to indicate applications that are playing audio including an option to mute them.";
        fill = mkBoolOption "Whether task manager should occupy all available space.";
        rows = {
          multirowView = mkOption {
            type = types.enum [
              "never"
              "lowSpace"
              "always"
            ];
            default = "never";
            example = "lowSpace";
            description = "When to use multi-row view.";
            apply =
              multirowView:
              if multirowView == "never" then false else (if multirowView == "always" then true else null);
          };
          maximum = mkOption {
            type = types.nullOr types.ints.positive;
            default = null;
            example = 5;
            description = "The maximum number of rows (in a horizontal-orientation containment, i.e. panel) or columns (in a vertical-orientation containment) to layout task buttons in.";
          };
        };
        iconSpacing = mkOption {
          type = types.nullOr (
            types.oneOf [
              (types.enum [
                "small"
                "medium"
                "large"
              ])
              types.ints.positive
            ]
          );
          default = null;
          example = "small";
          description = "The spacing between icons.";
          apply = convertSpacing;
        };
      };
      behavior = {
        grouping = {
          method =
            let
              enumVals = [
                "none"
                "byProgramName"
              ];
            in
            mkOption {
              type = with types; nullOr (enum enumVals);
              default = null;
              example = "none";
              description = "How tasks are grouped";
              apply = getIndexFromEnum enumVals;
            };
          clickAction =
            let
              enumVals = [
                "cycle"
                "showTooltips"
                "showPresentWindowsEffect"
                "showTextualList"
              ];
            in
            mkOption {
              type = with types; nullOr (enum enumVals);
              default = null;
              example = "cycle";
              description = "What happens when clicking on a grouped task";
              apply = getIndexFromEnum enumVals;
            };
        };
        sortingMethod =
          let
            enumVals = [
              "none"
              "manually"
              "alphabetically"
              "byDesktop"
              "byActivity"
            ];
          in
          mkOption {
            type = with types; nullOr (enum enumVals);
            default = null;
            example = "manually";
            description = "How to sort tasks";
            apply = getIndexFromEnum enumVals;
          };
        minimizeActiveTaskOnClick = mkBoolOption "Whether to minimize the currently-active task when clicked. If false, clicking on the currently-active task will do nothing.";
        middleClickAction =
          let
            enumVals = [
              "none"
              "close"
              "newInstance"
              "toggleMinimized"
              "toggleGrouping"
              "bringToCurrentDesktop"
            ];
          in
          mkOption {
            type = with types; nullOr (enum enumVals);
            default = null;
            example = "bringToCurrentDesktop";
            description = "What to do on middle-mouse click on a task button.";
            apply = getIndexFromEnum enumVals;
          };
        wheel = {
          switchBetweenTasks = mkBoolOption "Whether using the mouse wheel with the mouse pointer above the widget should switch between tasks.";
          ignoreMinimizedTasks = mkBoolOption "Whether to skip minimized tasks when switching between them using the mouse wheel.";
        };
        showTasks = {
          onlyInCurrentScreen = mkBoolOption "Whether to show only window tasks that are on the same screen as the widget.";
          onlyInCurrentDesktop = mkBoolOption "Whether to only show tasks that are on the current virtual desktop.";
          onlyInCurrentActivity = mkBoolOption "Whether to show only tasks that are on the current activity.";
          onlyMinimized = mkBoolOption "Whether to show only window tasks that are minimized.";
        };
        unhideOnAttentionNeeded = mkBoolOption "Whether to unhide if a window wants attention.";
        newTasksAppearOn = mkOption {
          type = types.nullOr (
            types.enum [
              "left"
              "right"
            ]
          );
          default = null;
          example = "right";
          description = "Whether new tasks should appear in the left or right.";
          apply = positionToReverse;
        };
      };
      settings = mkOption {
        type = configValueType;
        default = null;
        example = {
          General = {
            launchers = [
              "applications:org.kde.dolphin.desktop"
              "applications:org.kde.konsole.desktop"
            ];
          };
        };
        description = "Extra configuration options for the widget.";
        apply = settings: if settings == null then { } else settings;
      };
    };
    convert =
      {
        appearance,
        behavior,
        launchers,
        settings,
        iconsOnly,
        ...
      }:
      {
        name = if iconsOnly then "org.kde.plasma.icontasks" else "org.kde.plasma.taskmanager";
        config = lib.recursiveUpdate {
          General = lib.filterAttrs (_: v: v != null) {
            launchers = launchers;

            # Appearance
            showToolTips = appearance.showTooltips;
            highlightWindows = appearance.highlightWindows;
            indicateAudioStreams = appearance.indicateAudioStreams;
            fill = appearance.fill;

            forceStripes = appearance.rows.multirowView;
            maxStripes = appearance.rows.maximum;

            iconSpacing = appearance.iconSpacing;

            # Behavior
            groupingStrategy = behavior.grouping.method;
            groupedTaskVisualization = behavior.grouping.clickAction;
            sortingStrategy = behavior.sortingMethod;
            minimizeActiveTaskOnClick = behavior.minimizeActiveTaskOnClick;
            middleClickAction = behavior.middleClickAction;

            wheelEnabled = behavior.wheel.switchBetweenTasks;
            wheelSkipMinimized = behavior.wheel.ignoreMinimizedTasks;

            showOnlyCurrentScreen = behavior.showTasks.onlyInCurrentScreen;
            showOnlyCurrentDesktop = behavior.showTasks.onlyInCurrentDesktop;
            showOnlyCurrentActivity = behavior.showTasks.onlyInCurrentActivity;
            showOnlyMinimized = behavior.showTasks.onlyMinimized;

            unhideOnAttention = behavior.unhideOnAttentionNeeded;
            reverseMode = behavior.newTasksAppearOn;
          };
        } settings;
      };
  };
}
</file>

<file path="modules/widgets/keyboard-layout.nix">
{ lib, ... }:
let
  inherit (import ./lib.nix { inherit lib; }) configValueType;
  inherit (import ./default.nix { inherit lib; }) positionType sizeType;

  getIndexFromEnum =
    enum: value:
    if value == null then
      null
    else
      lib.lists.findFirstIndex (x: x == value)
        (throw "getIndexFromEnum (keyboard-layout widget): Value ${value} isn't present in the enum. This is a bug")
        enum;
in
{
  keyboardLayout = {
    description = "The keyboard layout indicator widget.";

    opts = {
      position = lib.mkOption {
        type = positionType;
        example = {
          horizontal = 250;
          vertical = 50;
        };
        description = "The position of the widget. (Only for desktop widget)";
      };
      size = lib.mkOption {
        type = sizeType;
        example = {
          width = 500;
          height = 500;
        };
        description = "The size of the widget. (Only for desktop widget)";
      };
      displayStyle =
        let
          enumVals = [
            "label"
            "flag"
            "labelOverFlag"
          ];
        in
        lib.mkOption {
          type = with lib.types; nullOr (enum enumVals);
          default = null;
          example = "labelOverFlag";
          description = "Keyboard layout indicator display style.";
          apply = getIndexFromEnum enumVals;
        };
      settings = lib.mkOption {
        type = configValueType;
        default = null;
        example = {
          General = {
            displayStyle = 1;
          };
        };
        apply = settings: if settings == null then { } else settings;
      };
    };

    convert =
      { displayStyle, settings, ... }:
      {
        name = "org.kde.plasma.keyboardlayout";
        config = lib.recursiveUpdate {
          General = lib.filterAttrs (_: v: v != null) { inherit displayStyle; };
        } settings;
      };
  };
}
</file>

<file path="modules/widgets/kicker.nix">
{ lib, ... }:
let
  inherit (lib) mkOption types;
  inherit (import ./lib.nix { inherit lib; }) configValueType;
  inherit (import ./default.nix { inherit lib; }) positionType sizeType;

  mkBoolOption =
    description:
    mkOption {
      type = with types; nullOr bool;
      default = null;
      example = true;
      inherit description;
    };

  getIndexFromEnum =
    enum: value:
    if value == null then
      null
    else
      lib.lists.findFirstIndex (x: x == value)
        (throw "getIndexFromEnum (kicker widget): Value ${value} isn't present in the enum. This is a bug")
        enum;

  checkPath =
    path:
    if path == null then
      null
    else if lib.strings.hasPrefix "/" path then
      path
    else
      throw "checkPath (kicker widget): Path ${path} is not an absolute path.";
in
{
  kicker = {
    description = ''
      Kicker is a launcher, which is also known as Application Menu.
      Kicker does not have fancy features, like the other launchers,
      but provides a tightly arranged interface.
    '';

    opts = {
      position = mkOption {
        type = positionType;
        example = {
          horizontal = 250;
          vertical = 50;
        };
        description = "The position of the widget. (Only for desktop widget)";
      };
      size = mkOption {
        type = sizeType;
        example = {
          width = 500;
          height = 500;
        };
        description = "The size of the widget. (Only for desktop widget)";
      };
      icon = mkOption {
        type = types.nullOr types.str;
        default = null;
        example = "start-here-kde-symbolic";
        description = "The icon to use for the kickoff button.";
      };
      customButtonImage = mkOption {
        type = types.nullOr types.str;
        default = null;
        example = "/home/user/pictures/custom-button.png";
        description = "The absolute path image to use for the custom button.";
        apply = checkPath;
      };
      applicationNameFormat =
        let
          enumVals = [
            "nameOnly"
            "genericNameOnly"
            "nameAndGenericName"
            "genericNameAndName"
          ];
        in
        mkOption {
          type = with types; nullOr (enum enumVals);
          default = null;
          example = "nameOnly";
          description = "The format of the application name to display.";
          apply = getIndexFromEnum enumVals;
        };
      behavior = {
        sortAlphabetically = mkBoolOption "Whether to sort the applications alphabetically.";
        flattenCategories = mkBoolOption "Whether to flatten top-level menu categories to a single level instead of displaying sub-categories.";
        showIconsOnRootLevel = mkBoolOption "Whether to show icons on the root level of the menu.";
      };
      categories = {
        show = {
          recentApplications = mkBoolOption "Whether to show recent applications.";
          recentFiles = mkBoolOption "Whether to show recent files.";
        };
        order =
          let
            enumVals = [
              "recentFirst"
              "popularFirst"
            ];
          in
          mkOption {
            type = with types; nullOr (enum enumVals);
            default = null;
            example = "recentFirst";
            description = "The order in which to show the categories.";
            apply = getIndexFromEnum enumVals;
          };
      };
      search = {
        alignResultsToBottom = mkBoolOption "Whether to align the search results to the bottom of the screen.";
        expandSearchResults = mkBoolOption "Whether to expand the search results to bookmarks, files and emails.";
      };
      settings = mkOption {
        type = configValueType;
        default = null;
        example = {
          General = {
            icon = "nix-snowflake-white";
          };
        };
        description = "Extra configuration options for the widget.";
        apply = settings: if settings == null then { } else settings;
      };
    };
    convert =
      {
        icon,
        customButtonImage,
        applicationNameFormat,
        behavior,
        categories,
        search,
        settings,
        ...
      }:
      {
        name = "org.kde.plasma.kicker";
        config = lib.recursiveUpdate {
          General = lib.filterAttrs (_: v: v != null) {
            inherit icon customButtonImage;
            inherit (search) alignResultsToBottom;

            useCustomButtonImage = (customButtonImage != null);

            appNameFormat = applicationNameFormat;

            alphaSort = behavior.sortAlphabetically;
            limitDepth = behavior.flattenCategories;
            showIconsRootLevel = behavior.showIconsOnRootLevel;

            showRecentApps = categories.show.recentApplications;
            showRecentDocs = categories.show.recentFiles;
            recentOrdering = categories.order;

            useExtraRunners = search.expandSearchResults;
          };
        } settings;
      };
  };
}
</file>

<file path="modules/widgets/kickerdash.nix">
{ lib, ... }:
let
  inherit (lib) mkOption types;
  inherit (import ./lib.nix { inherit lib; }) configValueType;
  inherit (import ./default.nix { inherit lib; }) positionType sizeType;

  mkBoolOption =
    description:
    mkOption {
      type = with types; nullOr bool;
      default = null;
      example = true;
      inherit description;
    };

  getIndexFromEnum =
    enum: value:
    if value == null then
      null
    else
      lib.lists.findFirstIndex (x: x == value)
        (throw "getIndexFromEnum (kickerdash widget): Value ${value} isn't present in the enum. This is a bug")
        enum;

  checkPath =
    path:
    if path == null then
      null
    else if lib.strings.hasPrefix "/" path then
      path
    else
      throw "checkPath (kickerdash widget): Path ${path} is not an absolute path.";
in
{
  kickerdash = {
    description = "Application Dashboard (kickerdash) is an alternative launcher which fills the whole desktop.";

    opts = {
      position = mkOption {
        type = positionType;
        example = {
          horizontal = 250;
          vertical = 50;
        };
        description = "The position of the widget. (Only for desktop widget)";
      };
      size = mkOption {
        type = sizeType;
        example = {
          width = 500;
          height = 500;
        };
        description = "The size of the widget. (Only for desktop widget)";
      };
      icon = mkOption {
        type = types.nullOr types.str;
        default = null;
        example = "start-here-kde-symbolic";
        description = "The icon to use for the kickoff button.";
      };
      customButtonImage = mkOption {
        type = types.nullOr types.str;
        default = null;
        example = "/home/user/pictures/custom-button.png";
        description = "The absolute path image to use for the custom button.";
        apply = checkPath;
      };
      applicationNameFormat =
        let
          enumVals = [
            "nameOnly"
            "genericNameOnly"
            "nameAndGenericName"
            "genericNameAndName"
          ];
        in
        mkOption {
          type = with types; nullOr (enum enumVals);
          default = null;
          example = "nameOnly";
          description = "The format of the application name to display.";
          apply = getIndexFromEnum enumVals;
        };
      behavior = {
        sortAlphabetically = mkBoolOption "Whether to sort the applications alphabetically.";
      };
      categories = {
        show = {
          recentApplications = mkBoolOption "Whether to show recent applications.";
          recentFiles = mkBoolOption "Whether to show recent files.";
        };
        order =
          let
            enumVals = [
              "recentFirst"
              "popularFirst"
            ];
          in
          mkOption {
            type = with types; nullOr (enum enumVals);
            default = null;
            example = "recentFirst";
            description = "The order in which to show the categories.";
            apply = getIndexFromEnum enumVals;
          };
      };
      search = {
        expandSearchResults = mkBoolOption "Whether to expand the search results to bookmarks, files and emails.";
      };
      settings = mkOption {
        type = configValueType;
        default = null;
        example = {
          General = {
            icon = "nix-snowflake-white";
          };
        };
        description = "Extra configuration options for the widget.";
        apply = settings: if settings == null then { } else settings;
      };
    };
    convert =
      {
        icon,
        customButtonImage,
        applicationNameFormat,
        behavior,
        categories,
        search,
        settings,
        ...
      }:
      {
        name = "org.kde.plasma.kickerdash";
        config = lib.recursiveUpdate {
          General = lib.filterAttrs (_: v: v != null) {
            inherit icon customButtonImage;
            useCustomButtonImage = (customButtonImage != null);

            appNameFormat = applicationNameFormat;

            alphaSort = behavior.sortAlphabetically;

            showRecentApps = categories.show.recentApplications;
            showRecentDocs = categories.show.recentFiles;
            recentOrdering = categories.order;

            useExtraRunners = search.expandSearchResults;
          };
        } settings;
      };
  };
}
</file>

<file path="modules/widgets/kickoff.nix">
{ lib, ... }:
let
  inherit (import ./lib.nix { inherit lib; }) configValueType;
  inherit (import ./default.nix { inherit lib; }) positionType sizeType;

  mkBoolOption =
    description:
    lib.mkOption {
      type = with lib.types; nullOr bool;
      default = null;
      example = true;
      inherit description;
    };

  getIndexFromEnum =
    enum: value:
    if value == null then
      null
    else
      lib.lists.findFirstIndex (x: x == value)
        (throw "getIndexFromEnum (kickoff widget): Value ${value} isn't present in the enum. This is a bug")
        enum;

  convertSidebarPosition =
    sidebarPosition:
    let
      mappings = {
        left = false;
        right = true;
      };
    in
    if sidebarPosition == null then
      null
    else
      mappings.${sidebarPosition} or (throw "Invalid sidebar position: ${sidebarPosition}");
in
{
  kickoff = {
    description = "Kickoff is the default application launcher of the Plasma desktop.";

    opts = {
      position = lib.mkOption {
        type = positionType;
        example = {
          horizontal = 250;
          vertical = 50;
        };
        description = "The position of the widget. (Only for desktop widget)";
      };
      size = lib.mkOption {
        type = sizeType;
        example = {
          width = 500;
          height = 500;
        };
        description = "The size of the widget. (Only for desktop widget)";
      };
      icon = lib.mkOption {
        type = with lib.types; nullOr str;
        default = null;
        example = "start-here-kde-symbolic";
        description = ''
          The icon to use for the kickoff button.

          This can also be used to specify a custom image for the kickoff button.
          To do this, set the value to a absolute path to the image file.
        '';
      };
      label = lib.mkOption {
        type = with lib.types; nullOr str;
        default = null;
        example = "Menu";
        description = "The label to use for the kickoff button.";
      };
      sortAlphabetically = mkBoolOption "Whether to sort menu contents alphabetically or use manual/system sort order.";
      compactDisplayStyle = mkBoolOption "Whether to use a compact display style for list items.";
      sidebarPosition = lib.mkOption {
        type =
          with lib.types;
          nullOr (enum [
            "left"
            "right"
          ]);
        default = null;
        example = "left";
        description = "The position of the sidebar.";
        apply = convertSidebarPosition;
      };
      favoritesDisplayMode =
        let
          enumVals = [
            "grid"
            "list"
          ];
        in
        lib.mkOption {
          type = with lib.types; nullOr (enum enumVals);
          default = null;
          example = "list";
          description = "How to display favorites.";
          apply = getIndexFromEnum enumVals;
        };
      applicationsDisplayMode =
        let
          enumVals = [
            "grid"
            "list"
          ];
        in
        lib.mkOption {
          type = with lib.types; nullOr (enum enumVals);
          default = null;
          example = "grid";
          description = "How to display applications.";
          apply = getIndexFromEnum enumVals;
        };
      showButtonsFor =
        let
          enumVals = [
            "power"
            "session"
            "powerAndSession"
          ];
          buttonsEnum = [
            "lock-screen"
            "logout"
            "save-session"
            "switch-user"
            "suspend"
            "hibernate"
            "reboot"
            "shutdown"
          ];
        in
        lib.mkOption {
          type =
            with lib.types;
            nullOr (
              either (enum enumVals) (submodule {
                options.custom = lib.mkOption {
                  type = listOf (enum buttonsEnum);
                  example = [
                    "shutdown"
                    "reboot"
                  ];
                  description = "The custom buttons to show";
                };
              })
            );
          default = null;
          example = {
            custom = [
              "shutdown"
              "reboot"
              "logout"
            ];
          };
          description = "Which actions should be displayed in the footer.";
          apply =
            value:
            if value == null then
              { }
            else if value ? custom then
              {
                primaryActions = 2;
                systemFavorites = builtins.concatStringsSep ''\\,'' value.custom;
              }
            else
              {
                primaryActions =
                  builtins.elemAt
                    [
                      0
                      1
                      3
                    ]
                    (
                      lib.lists.findFirstIndex (
                        x: x == value
                      ) (throw "kickoff: non-existent value ${value}! This is a bug!") enumVals
                    );
                systemFavorites =
                  if value == "session" then
                    builtins.concatStringsSep ''\\,'' (
                      builtins.filter (v: v != null) (lib.imap0 (i: v: if i < 4 then v else null) buttonsEnum)
                    )
                  else if value == "power" then
                    builtins.concatStringsSep ''\\,'' (
                      builtins.filter (v: v != null) (lib.imap0 (i: v: if i > 3 then v else null) buttonsEnum)
                    )
                  else
                    builtins.concatStringsSep ''\\,'' buttonsEnum;
              };
        };
      showActionButtonCaptions = mkBoolOption "Whether to display captions ('shut down', 'log out', etc.) for the footer action buttons";
      pin = mkBoolOption "Whether the popup should remain open when another window is activated.";
      popupHeight = lib.mkOption {
        type = with lib.types; nullOr ints.positive;
        default = null;
        example = 500;
      };
      popupWidth = lib.mkOption {
        type = with lib.types; nullOr ints.positive;
        default = null;
        example = 700;
      };
      settings = lib.mkOption {
        type = configValueType;
        default = null;
        example = {
          General = {
            icon = "nix-snowflake-white";
          };
          popupHeight = 500;
        };
        description = "Extra configuration options for the widget.";
        apply = settings: if settings == null then { } else settings;
      };
    };
    convert =
      {
        icon,
        label,
        sortAlphabetically,
        compactDisplayStyle,
        sidebarPosition,
        favoritesDisplayMode,
        applicationsDisplayMode,
        showButtonsFor,
        showActionButtonCaptions,
        pin,
        popupHeight,
        popupWidth,
        settings,
        ...
      }:
      {
        name = "org.kde.plasma.kickoff";
        config = lib.recursiveUpdate (lib.filterAttrsRecursive (_: v: v != null) {
          popupHeight = popupHeight;
          popupWidth = popupWidth;

          General = {
            inherit icon pin showActionButtonCaptions;

            menuLabel = label;
            alphaSort = sortAlphabetically;
            compactMode = compactDisplayStyle;
            paneSwap = sidebarPosition;
            favoritesDisplay = favoritesDisplayMode;
            applicationsDisplay = applicationsDisplayMode;
          } // showButtonsFor;
        }) settings;
      };
  };
}
</file>

<file path="modules/widgets/lib.nix">
{ lib, ... }:
let
  inherit (lib)
    optionalString
    concatMapStringsSep
    concatStringsSep
    mapAttrsToList
    filterAttrs
    splitString
    ;

  configValueTypes =
    with lib.types;
    oneOf [
      bool
      float
      int
      str
    ];
  configValueTypeInner = with lib.types; either configValueTypes (listOf configValueTypes);
  configValueType =
    with lib.types;
    nullOr (attrsOf (either configValueTypeInner (attrsOf configValueTypeInner)));

  # any value or null -> string -> string
  # If value is null, returns the empty string, otherwise returns the provided string
  stringIfNotNull = v: optionalString (v != null);

  # Converts each datatype into an expression which can be parsed in JavaScript
  valToJS =
    v:
    if (builtins.isString v) then
      ''"${v}"''
    else if (builtins.isBool v) then
      (lib.boolToString v)
    else
      (builtins.toString v);

  # Converts a list of  to a single string, that can be parsed as a string list in JavaScript
  toJSList = values: ''[${concatMapStringsSep ", " valToJS values}]'';

  setWidgetSettings =
    var: settings:
    let
      perConfig =
        key: value:
        ''${var}.writeConfig("${key}", ${
          if builtins.isList value then toJSList value else valToJS value
        });'';

      perGroup = group: configs: ''
        ${var}.currentConfigGroup = ${toJSList (splitString "/" group)};
        ${concatStringsSep "\n" (mapAttrsToList perConfig configs)}
      '';

      groups = (filterAttrs (_: value: builtins.isAttrs value) settings);
      topLevel = (filterAttrs (_: value: !builtins.isAttrs value) settings);
    in
    concatStringsSep "\n" (
      (lib.optional (topLevel != { }) "${var}.currentConfigGroup = [];")
      ++ (mapAttrsToList perConfig topLevel)
      ++

        (mapAttrsToList perGroup groups)
    );

  addWidgetStmts =
    containment: var: ws:
    let
      widgetConfigsToStmts =
        { name, config, ... }:
        ''
          var w = ${var}["${name}"];
          ${setWidgetSettings "w" config}
        '';

      addStmt =
        {
          name,
          config,
          extraConfig,
        }@widget:
        ''
          ${var}["${name}"] = ${containment}.addWidget("${name}");
          ${stringIfNotNull config (widgetConfigsToStmts widget)}
          ${lib.optionalString (extraConfig != "") ''
            (${extraConfig})(${var}["${name}"]);
          ''}
        '';
    in
    ''
      const ${var} = {};
      ${lib.concatMapStringsSep "\n" addStmt ws}
    '';

  addDesktopWidgetStmts =
    containment: var: ws:
    let
      widgetConfigsToStmts =
        { name, config, ... }:
        ''
          var w = ${var}["${name}"];
          ${setWidgetSettings "w" config}
        '';

      addStmt =
        {
          name,
          position,
          size,
          config,
          extraConfig,
        }@widget:
        ''
          ${var}["${name}"] = ${containment}.addWidget("${name}", ${toString position.horizontal}, ${toString position.vertical}, ${toString size.width}, ${toString size.height});
          ${stringIfNotNull config (widgetConfigsToStmts widget)}
          ${lib.optionalString (extraConfig != "") ''
            (${extraConfig})(${var}["${name}"]);
          ''}
        '';
    in
    ''
      const ${var} = {};
      ${lib.concatMapStringsSep "\n" addStmt ws}
    '';
in
{
  inherit
    stringIfNotNull
    setWidgetSettings
    addWidgetStmts
    addDesktopWidgetStmts
    configValueType
    ;
}
</file>

<file path="modules/widgets/pager.nix">
{ lib, ... }:
let
  inherit (import ./lib.nix { inherit lib; }) configValueType;
  inherit (import ./default.nix { inherit lib; }) positionType sizeType;

  mkBoolOption =
    description:
    lib.mkOption {
      type = with lib.types; nullOr bool;
      default = null;
      example = true;
      inherit description;
    };

  capitalizeWord =
    word:
    with lib.strings;
    if word == null then
      null
    else
      concatImapStrings (pos: char: if pos == 1 then toUpper char else char) (stringToCharacters word);
in
{
  pager = {
    description = "The desktop pager is a plasma widget that helps you to organize virtual desktops.";

    opts = {
      position = lib.mkOption {
        type = positionType;
        example = {
          horizontal = 250;
          vertical = 50;
        };
        description = "The position of the widget. (Only for desktop widget)";
      };
      size = lib.mkOption {
        type = sizeType;
        example = {
          width = 500;
          height = 500;
        };
        description = "The size of the widget. (Only for desktop widget)";
      };
      general = {
        showWindowOutlines = mkBoolOption "Whether to show window outlines";
        showApplicationIconsOnWindowOutlines = mkBoolOption "Whether to show application icons on window outlines";
        showOnlyCurrentScreen = mkBoolOption "Whether to limit the Pager to the set of windows and the geometry of the screen the widget resides on";
        navigationWrapsAround = mkBoolOption "Whether to wrap around when navigating the desktops";
        displayedText =
          let
            options = {
              none = "None";
              desktopNumber = "Number";
              desktopName = "Name";
            };
          in
          lib.mkOption {
            type = with lib.types; nullOr (enum (builtins.attrNames options));
            default = null;
            example = "desktopNumber";
            description = "The text to show inside the desktop rectangles";
            apply = option: if option == null then null else options.${option};
          };
        selectingCurrentVirtualDesktop = lib.mkOption {
          type =
            with lib.types;
            nullOr (enum [
              "doNothing"
              "showDesktop"
            ]);
          default = null;
          example = "showDesktop";
          description = "What to do on left-mouse click on a desktop rectangle";
          apply = capitalizeWord;
        };
      };
      settings = lib.mkOption {
        type = configValueType;
        default = null;
        example = {
          General = {
            showWindowOutlines = true;
          };
        };
        description = "Extra configuration options for the widget.";
        apply = settings: if settings == null then { } else settings;
      };
    };
    convert =
      { general, settings, ... }:
      {
        name = "org.kde.plasma.pager";
        config = lib.recursiveUpdate {
          General = lib.filterAttrs (_: v: v != null) {
            showWindowOutlines = general.showWindowOutlines;
            showWindowIcons = general.showApplicationIconsOnWindowOutlines;
            showOnlyCurrentScreen = general.showOnlyCurrentScreen;
            wrapPage = general.navigationWrapsAround;
            displayedText = general.displayedText;
            currentDesktopSelected = general.selectingCurrentVirtualDesktop;
          };
        } settings;
      };
  };
}
</file>

<file path="modules/widgets/panel-spacer.nix">
{ lib, ... }:
let
  inherit (import ./lib.nix { inherit lib; }) configValueType;
  inherit (import ./default.nix { inherit lib; }) positionType sizeType;

  mkBoolOption =
    description:
    lib.mkOption {
      type = with lib.types; nullOr bool;
      default = null;
      example = true;
      inherit description;
    };
in
{
  panelSpacer = {
    opts = {
      position = lib.mkOption {
        type = positionType;
        example = {
          horizontal = 100;
          vertical = 300;
        };
        description = "The position of the widget. (Only for desktop widget)";
      };
      size = lib.mkOption {
        type = sizeType;
        example = {
          width = 500;
          height = 50;
        };
        description = "The size of the widget. (Only for desktop widget)";
      };
      expanding = mkBoolOption "Whether the spacer should expand to fill the available space.";
      length = lib.mkOption {
        type = lib.types.nullOr lib.types.int;
        default = null;
        example = 50;
        description = ''
          The length of the spacer.
          If expanding is set to true, this value is ignored.
        '';
      };
      settings = lib.mkOption {
        type = configValueType;
        default = null;
        example = {
          General = {
            expanding = true;
          };
        };
        description = ''
          Extra configuration for the widget
        '';
        apply = settings: if settings == null then { } else settings;
      };
    };

    convert =
      {
        expanding,
        length,
        settings,
        ...
      }:
      {
        name = "org.kde.plasma.panelspacer";
        config = lib.recursiveUpdate {
          General = lib.filterAttrs (_: v: v != null) { inherit expanding length; };
        } settings;
      };
  };
}
</file>

<file path="modules/widgets/plasma-panel-colorizer.nix">
{ lib, ... }:
let
  inherit (lib) mkOption types;
  inherit (import ./lib.nix { inherit lib; }) configValueType;
  inherit (import ./default.nix { inherit lib; }) positionType sizeType;

  mkBoolOption =
    description:
    mkOption {
      type = types.nullOr types.bool;
      default = null;
      example = true;
      inherit description;
    };

  systemColors = [
    "text"
    "disabledText"
    "highlightedText"
    "activeText"
    "link"
    "visitedLink"
    "negativeText"
    "neutralText"
    "positiveText"
    "background"
    "highlight"
    "activeBackground"
    "linkBackground"
    "visitedLinkBackground"
    "negativeBackground"
    "neutralBackground"
    "positiveBackground"
    "alternateBackground"
    "focus"
    "hover"
  ];

  systemColorSets = [
    "view"
    "window"
    "button"
    "selection"
    "tooltip"
    "complementary"
    "header"
  ];

  getIndexFromEnum =
    enum: value:
    if value == null then
      null
    else
      lib.lists.findFirstIndex (x: x == value)
        (throw "getIndexFromEnum (plasma-panel-colorizer widget): Value ${value} isn't present in the enum. This is a bug")
        enum;

  convertColorList = colors: if colors == null then null else builtins.concatStringsSep " " colors;

  convertWidgets =
    widgets: if widgets == null then null else "|" + builtins.concatStringsSep "|" widgets;

  convertWidgetMarginRules =
    rules:
    if rules == null then
      null
    else
      let
        widgetToString =
          widget:
          "${widget.widgetId},${toString widget.margin.vertical},${toString widget.margin.horizontal}";
      in
      builtins.concatStringsSep "|" (map widgetToString rules);

  widgetMarginRuleType = types.submodule {
    options = {
      widgetId = mkOption {
        type = types.str;
        example = "org.kde.plasma.kickoff";
        description = "Widget id";
      };
      margin = {
        vertical = mkOption {
          type = types.int;
          example = 5;
          description = "Vertical margin value";
        };
        horizontal = mkOption {
          type = types.int;
          example = 5;
          description = "Horizontal margin value";
        };
      };
    };
  };
in
{
  plasmaPanelColorizer = {
    description = "Fully-featured widget to bring Latte-Dock and WM status bar customization features to the default KDE Plasma panel";

    opts = {
      position = mkOption {
        type = positionType;
        example = {
          horizontal = 250;
          vertical = 50;
        };
        description = "The position of the widget. (Only for desktop widget)";
      };
      size = mkOption {
        type = sizeType;
        example = {
          width = 500;
          height = 500;
        };
        description = "The size of the widget. (Only for desktop widget)";
      };
      general = {
        enable = mkBoolOption "Whether to enable the widget";
        hideWidget = mkBoolOption "Whether to hide the widget";
      };
      presetAutoLoading = {
        normal = mkOption {
          type = types.nullOr types.str;
          default = null;
          example = "Normal preset";
          description = "Preset to load when panel is on 'normal' state";
        };
        floating = mkOption {
          type = types.nullOr types.str;
          default = null;
          example = "Floating preset";
          description = "Preset to load when panel is on 'floating' state";
        };
        touchingWindow = mkOption {
          type = types.nullOr types.str;
          default = null;
          example = "Touching window preset";
          description = "Preset to load when panel is on 'touching window' state";
        };
        maximized = mkOption {
          type = types.nullOr types.str;
          default = null;
          example = "Maximized preset";
          description = "Preset to load when panel is on 'maximized' state";
        };
      };
      widgetBackground = {
        enable = mkBoolOption "Whether to enable the widget background configuration";
        colorMode = {
          mode =
            let
              enumVals = [
                "static"
                "animated"
              ];
            in
            mkOption {
              type = types.nullOr (types.enum enumVals);
              default = null;
              example = "static";
              description = "The color mode to use for the widget background";
              apply = getIndexFromEnum enumVals;
            };
          animationInterval = mkOption {
            type = types.nullOr types.ints.unsigned;
            default = null;
            example = 3000;
            description = "The interval in milliseconds between each color change";
          };
          animationSmoothing = mkOption {
            type = types.nullOr types.ints.unsigned;
            default = null;
            example = 800;
            description = "The time in milliseconds it takes to transition between colors";
          };
        };
        colors = {
          source =
            let
              enumVals = [
                "custom"
                "system"
                "customList"
                "random"
              ];
            in
            mkOption {
              type = types.nullOr (types.enum enumVals);
              default = null;
              example = "custom";
              description = "The source of the colors to use for the widget background";
              apply = getIndexFromEnum enumVals;
            };
          customColor = mkOption {
            type = types.nullOr types.str;
            default = null;
            example = "#ff0000";
            description = "The custom color to use for the widget background";
          };
          system = {
            color = mkOption {
              type = types.nullOr (types.enum systemColors);
              default = null;
              example = "text";
              description = "The system color to use for the widget background";
              apply = getIndexFromEnum systemColors;
            };
            colorSet = mkOption {
              type = types.nullOr (types.enum systemColorSets);
              default = null;
              example = "view";
              description = "The system color variant to use for the widget background";
              apply = getIndexFromEnum systemColorSets;
            };
          };
          customColorList = mkOption {
            type = types.nullOr (types.listOf types.str);
            default = null;
            example = [
              "#ff0000"
              "#00ff00"
              "#0000ff"
            ];
            description = "The list of custom colors to use for the widget background";
            apply = convertColorList;
          };
          contrastCorrection = {
            enable = mkBoolOption "Whether to enable contrast correction for the widget background";
            saturation = {
              enable = mkBoolOption "Whether to enable saturation correction for the widget background";
              value = mkOption {
                type = types.nullOr (types.numbers.between 0 1);
                default = null;
                example = 0.5;
                description = "The value to use for the saturation correction";
              };
            };
            lightness = mkOption {
              type = types.nullOr (types.numbers.between 0 1);
              default = null;
              example = 0.5;
              description = "The value to use for the lightness correction";
            };
          };
        };
        shape = {
          opacity = mkOption {
            type = types.nullOr (types.numbers.between 0 1);
            default = null;
            example = 0.5;
            description = "The opacity to use for the widget background";
          };
          radius = mkOption {
            type = types.nullOr types.ints.unsigned;
            default = null;
            example = 5;
            description = "The radius to use for the widget background";
          };
          line = {
            enable = mkBoolOption "Whether to enable the line for the widget background";
            position =
              let
                enumVals = [
                  "top"
                  "bottom"
                  "left"
                  "right"
                ];
              in
              mkOption {
                type = types.nullOr (types.enum enumVals);
                default = null;
                example = "top";
                description = "The position to use for the line of the widget background";
                apply = getIndexFromEnum enumVals;
              };
            width = mkOption {
              type = types.nullOr types.ints.unsigned;
              default = null;
              example = 5;
              description = "The width to use for the line of the widget background";
            };
            horizontalOffset = mkOption {
              type = types.nullOr types.int;
              default = null;
              example = 5;
              description = "The X offset to use for the line of the widget background";
            };
            verticalOffset = mkOption {
              type = types.nullOr types.int;
              default = null;
              example = 5;
              description = "The Y offset to use for the line of the widget background";
            };
          };
          outline = {
            colorSource =
              let
                enumVals = [
                  "custom"
                  "system"
                ];
              in
              mkOption {
                type = types.nullOr (types.enum enumVals);
                default = null;
                example = "custom";
                description = "The source of the color to use for the outline of the widget background";
                apply = getIndexFromEnum enumVals;
              };
            customColor = mkOption {
              type = types.nullOr types.str;
              default = null;
              example = "#ff0000";
              description = "The custom color to use for the outline of the widget background";
            };
            system = {
              color = mkOption {
                type = types.nullOr (types.enum systemColors);
                default = null;
                example = "text";
                description = "The system color to use for the outline of the widget background";
                apply = getIndexFromEnum systemColors;
              };
              colorSet = mkOption {
                type = types.nullOr (types.enum systemColorSets);
                default = null;
                example = "view";
                description = "The system color variant to use for the outline of the widget background";
                apply = getIndexFromEnum systemColorSets;
              };
            };
            opacity = mkOption {
              type = types.nullOr (types.numbers.between 0 1);
              default = null;
              example = 0.5;
              description = "The opacity to use for the outline of the widget background";
            };
            width = mkOption {
              type = types.nullOr types.ints.unsigned;
              default = null;
              example = 5;
              description = "The width to use for the outline of the widget background";
            };
          };
          shadow = {
            color = mkOption {
              type = types.nullOr types.str;
              default = null;
              example = "#7f000000";
              description = "The color to use for the shadow of the widget background";
            };
            size = mkOption {
              type = types.nullOr types.ints.unsigned;
              default = null;
              example = 5;
              description = "The size to use for the shadow of the widget background";
            };
            horizontalOffset = mkOption {
              type = types.nullOr types.int;
              default = null;
              example = 5;
              description = "The X offset to use for the shadow of the widget background";
            };
            verticalOffset = mkOption {
              type = types.nullOr types.int;
              default = null;
              example = 5;
              description = "The Y offset to use for the shadow of the widget background";
            };
          };
        };
      };
      textAndIcons = {
        enable = mkBoolOption "Whether to enable the text and icons configuration";
        colorMode = {
          mode =
            let
              enumVals = [
                "static"
                "interval"
              ];
            in
            mkOption {
              type = types.nullOr (types.enum enumVals);
              default = null;
              example = "static";
              description = "The color mode to use for the text and icons";
              apply = getIndexFromEnum enumVals;
            };
          interval = mkOption {
            type = types.nullOr types.ints.unsigned;
            default = null;
            example = 3000;
            description = "The interval in milliseconds between each color change";
          };
        };
        colors = {
          source =
            let
              enumVals = [
                "custom"
                "system"
                "widgetBackground"
                "customList"
                "random"
              ];
            in
            mkOption {
              type = types.nullOr (types.enum enumVals);
              default = null;
              example = "custom";
              description = "The source of the colors to use for the text and icons";
              apply = getIndexFromEnum enumVals;
            };
          customColor = mkOption {
            type = types.nullOr types.str;
            default = null;
            example = "#ff0000";
            description = "The custom color to use for the text and icons";
          };
          system = {
            color = mkOption {
              type = types.nullOr (types.enum systemColors);
              default = null;
              example = "text";
              description = "The system color to use for the text and icons";
              apply = getIndexFromEnum systemColors;
            };
            colorSet = mkOption {
              type = types.nullOr (types.enum systemColorSets);
              default = null;
              example = "view";
              description = "The system color variant to use for the text and icons";
              apply = getIndexFromEnum systemColorSets;
            };
          };
          customColorList = mkOption {
            type = types.nullOr (types.listOf types.str);
            default = null;
            example = [
              "#ff0000"
              "#00ff00"
              "#0000ff"
            ];
            description = "The list of custom colors to use for the text and icons";
            apply = convertColorList;
          };
          opacity = mkOption {
            type = types.nullOr (types.numbers.between 0 1);
            default = null;
            example = 0.5;
            description = "The opacity to use for the text and icons";
          };
          contrastCorrection = {
            enable = mkBoolOption "Whether to enable contrast correction for the text and icons";
            saturation = {
              enable = mkBoolOption "Whether to enable saturation correction for the text and icons";
              value = mkOption {
                type = types.nullOr (types.numbers.between 0 1);
                default = null;
                example = 0.5;
                description = "The value to use for the saturation correction";
              };
            };
            lightness = mkOption {
              type = types.nullOr (types.numbers.between 0 1);
              default = null;
              example = 0.5;
              description = "The value to use for the lightness correction";
            };
          };
        };
        shadow = {
          enable = mkBoolOption "Whether to enable the shadow for the text and icons";
          color = mkOption {
            type = types.nullOr types.str;
            default = null;
            example = "#7f000000";
            description = "The color to use for the shadow of the text and icons";
          };
          strength = mkOption {
            type = types.nullOr types.ints.unsigned;
            default = null;
            example = 5;
            description = "The strength to use for the shadow of the text and icons";
          };
          horizontalOffset = mkOption {
            type = types.nullOr types.int;
            default = null;
            example = 5;
            description = "The X offset to use for the shadow of the text and icons";
          };
          verticalOffset = mkOption {
            type = types.nullOr types.int;
            default = null;
            example = 5;
            description = "The Y offset to use for the shadow of the text and icons";
          };
        };
        customBadges = {
          fixCustomBadges = mkBoolOption "Whether to fix custom badges";
        };
        forceIconColor = {
          widgets = mkOption {
            type = types.nullOr (types.listOf types.str);
            default = null;
            example = [ "org.kde.plasma.digitalclock" ];
            description = "List of widgets to force icon color";
            apply = convertWidgets;
          };
        };
      };
      panelBackground = {
        originalBackground = {
          hide = mkBoolOption "Whether to hide the original panel background";
          opacity = mkOption {
            type = types.nullOr (types.numbers.between 0 1);
            default = null;
            example = 0.5;
            description = "The opacity to use for the original panel background";
          };
          fixedSizePadding = {
            enable = mkBoolOption "Whether to enable fixed size padding";
            value = mkOption {
              type = types.nullOr types.ints.unsigned;
              default = null;
              example = 5;
              description = "The value to use for the fixed size padding in pixels";
            };
          };
        };
        customBackground = {
          enable = mkBoolOption "Whether to enable the custom panel background";
          colorSource =
            let
              enumVals = [
                "custom"
                "system"
              ];
            in
            mkOption {
              type = types.nullOr (types.enum enumVals);
              default = null;
              example = "custom";
              description = "The source of the color to use for the custom panel background";
              apply = getIndexFromEnum enumVals;
            };
          customColor = mkOption {
            type = types.nullOr types.str;
            default = null;
            example = "#ff0000";
            description = "The custom color to use for the custom panel background";
          };
          system = {
            color = mkOption {
              type = types.nullOr (types.enum systemColors);
              default = null;
              example = "text";
              description = "The system color to use for the custom panel background";
              apply = getIndexFromEnum systemColors;
            };
            colorSet = mkOption {
              type = types.nullOr (types.enum systemColorSets);
              default = null;
              example = "view";
              description = "The system color variant to use for the custom panel background";
              apply = getIndexFromEnum systemColorSets;
            };
          };
          opacity = mkOption {
            type = types.nullOr (types.numbers.between 0 1);
            default = null;
            example = 0.5;
            description = "The opacity to use for the custom panel background";
          };
          radius = mkOption {
            type = types.nullOr types.ints.unsigned;
            default = null;
            example = 5;
            description = "The radius to use for the custom panel background";
          };
          outline = {
            colorSource =
              let
                enumVals = [
                  "custom"
                  "system"
                ];
              in
              mkOption {
                type = types.nullOr (types.enum enumVals);
                default = null;
                example = "custom";
                description = "The source of the color to use for the outline of the custom panel background";
                apply = getIndexFromEnum enumVals;
              };
            customColor = mkOption {
              type = types.nullOr types.str;
              default = null;
              example = "#ff0000";
              description = "The custom color to use for the outline of the custom panel background";
            };
            system = {
              color = mkOption {
                type = types.nullOr (types.enum systemColors);
                default = null;
                example = "text";
                description = "The system color to use for the outline of the custom panel background";
                apply = getIndexFromEnum systemColors;
              };
              colorSet = mkOption {
                type = types.nullOr (types.enum systemColorSets);
                default = null;
                example = "view";
                description = "The system color variant to use for the outline of the custom panel background";
                apply = getIndexFromEnum systemColorSets;
              };
            };
            opacity = mkOption {
              type = types.nullOr (types.numbers.between 0 1);
              default = null;
              example = 0.5;
              description = "The opacity to use for the outline of the custom panel background";
            };
            width = mkOption {
              type = types.nullOr types.ints.unsigned;
              default = null;
              example = 5;
              description = "The width to use for the outline of the custom panel background";
            };
          };
          shadow = {
            color = mkOption {
              type = types.nullOr types.str;
              default = null;
              example = "#7f000000";
              description = "The color to use for the shadow of the custom panel background";
            };
            size = mkOption {
              type = types.nullOr types.ints.unsigned;
              default = null;
              example = 5;
              description = "The size to use for the shadow of the custom panel background";
            };
            horizontalOffset = mkOption {
              type = types.nullOr types.int;
              default = null;
              example = 5;
              description = "The X offset to use for the shadow of the custom panel background";
            };
            verticalOffset = mkOption {
              type = types.nullOr types.int;
              default = null;
              example = 5;
              description = "The Y offset to use for the shadow of the custom panel background";
            };
          };
        };
      };
      blacklist = {
        enable = mkBoolOption "Whether to enable the blacklist";
        colorSource =
          let
            enumVals = [
              "custom"
              "system"
            ];
          in
          mkOption {
            type = types.nullOr (types.enum enumVals);
            default = null;
            example = "custom";
            description = "The source of the color to use for the blacklisted text and icons";
            apply = getIndexFromEnum enumVals;
          };
        customColor = mkOption {
          type = types.nullOr types.str;
          default = null;
          example = "#ff0000";
          description = "The custom color to use for the blacklisted text and icons";
        };
        system = {
          color = mkOption {
            type = types.nullOr (types.enum systemColors);
            default = null;
            example = "text";
            description = "The system color to use for the blacklisted text and icons";
            apply = getIndexFromEnum systemColors;
          };
          colorSet = mkOption {
            type = types.nullOr (types.enum systemColorSets);
            default = null;
            example = "view";
            description = "The system color variant to use for the blacklisted text and icons";
            apply = getIndexFromEnum systemColorSets;
          };
        };
        widgets = mkOption {
          type = types.nullOr (types.listOf types.str);
          default = null;
          example = [ "org.kde.plasma.digitalclock" ];
          description = "List of widgets to blacklist, blacklisted widgets will not be colorized";
          apply = convertWidgets;
        };
      };
      layout = {
        enable = mkBoolOption "Whether to enable the layout configuration";
        backgroundMargin = {
          spacing = mkOption {
            type = types.nullOr types.ints.unsigned;
            default = null;
            example = 5;
            description = "The spacing to use for the background margin";
          };
          vertical = mkOption {
            type = types.nullOr types.ints.unsigned;
            default = null;
            example = 5;
            description = "The vertical margin to use for the background margin";
          };
          horizontal = mkOption {
            type = types.nullOr types.ints.unsigned;
            default = null;
            example = 5;
            description = "The horizontal margin to use for the background margin";
          };
        };
        widgetMarginRules = mkOption {
          type = types.nullOr (types.listOf widgetMarginRuleType);
          default = null;
          example = [
            {
              widgetId = "org.kde.plasma.kickoff";
              margin = {
                vertical = 1;
                horizontal = 2;
              };
            }
            {
              widgetId = "org.kde.plasma.digitalclock";
              margin = {
                vertical = 2;
                horizontal = 1;
              };
            }
          ];
          description = ''
            List of rules to apply margins to specific widgets

            Define every widget from the panel here.
          '';
          apply = convertWidgetMarginRules;
        };
      };
      settings = mkOption {
        type = configValueType;
        default = null;
        example = {
          General = {
            isEnabled = true;
          };
        };
        description = ''
          Extra configuration for the widget options.

          See available options at https://github.com/luisbocanegra/plasma-panel-colorizer/blob/main/package/contents/config/main.xml
        '';
        apply = settings: if settings == null then { } else settings;
      };
    };
    convert =
      {
        general,
        presetAutoLoading,
        widgetBackground,
        textAndIcons,
        panelBackground,
        blacklist,
        layout,
        settings,
        ...
      }:
      {
        name = "luisbocanegra.panel.colorizer";
        config = lib.recursiveUpdate {
          General = lib.filterAttrs (_: v: v != null) {
            # General options
            isEnabled = general.enable;
            hideWidget = general.hideWidget;

            # Preset autoloading
            normalPreset = presetAutoLoading.normal;
            floatingPreset = presetAutoLoading.floating;
            touchingWindowPreset = presetAutoLoading.touchingWindow;
            maximizedPreset = presetAutoLoading.maximized;

            # Widget background options
            widgetBgEnabled = widgetBackground.enable;

            # Widget background options > Color mode
            mode = widgetBackground.colorMode.mode; # Color mode
            rainbowInterval = widgetBackground.colorMode.animationInterval;
            rainbowTransition = widgetBackground.colorMode.animationSmoothing;

            # Widget background options > Colors
            colorMode = widgetBackground.colors.source;
            singleColor = widgetBackground.colors.customColor; # Custom
            colorModeTheme = widgetBackground.colors.system.color; # System
            colorModeThemeVariant = widgetBackground.colors.system.colorSet; # System variant
            customColors = widgetBackground.colors.customColorList; # Custom list
            bgContrastFixEnabled = widgetBackground.colors.contrastCorrection.enable;
            bgSaturationEnabled = widgetBackground.colors.contrastCorrection.saturation.enable;
            bgSaturation = widgetBackground.colors.contrastCorrection.saturation.value;
            bgLightness = widgetBackground.colors.contrastCorrection.lightness;

            # Widget background options > Shape
            opacity = widgetBackground.shape.opacity;
            radius = widgetBackground.shape.radius;
            bgLineModeEnabled = widgetBackground.shape.line.enable;
            bgLinePosition = widgetBackground.shape.line.position;
            bgLineWidth = widgetBackground.shape.line.width;
            bgLineXOffset = widgetBackground.shape.line.horizontalOffset;
            bgLineYOffset = widgetBackground.shape.line.verticalOffset;

            # Widget background options > Shape > Outline
            widgetOutlineColorMode = widgetBackground.shape.outline.colorSource;
            widgetOutlineColor = widgetBackground.shape.outline.customColor;
            widgetOutlineColorModeTheme = widgetBackground.shape.outline.system.color;
            widgetOutlineColorModeThemeVariant = widgetBackground.shape.outline.system.colorSet;
            widgetOutlineOpacity = widgetBackground.shape.outline.opacity;
            widgetOutlineWidth = widgetBackground.shape.outline.width;

            # Widget background options > Shape > Shadow
            widgetShadowColor = widgetBackground.shape.shadow.color;
            widgetShadowSize = widgetBackground.shape.shadow.size;
            widgetShadowX = widgetBackground.shape.shadow.horizontalOffset;
            widgetShadowY = widgetBackground.shape.shadow.verticalOffset;

            # Text and icons options
            fgColorEnabled = textAndIcons.enable;

            # Text and icons options > Color mode
            fgMode = textAndIcons.colorMode.mode;
            fgRainbowInterval = textAndIcons.colorMode.interval;

            # Text and icons options > Colors
            fgColorMode = textAndIcons.colors.source;
            fgSingleColor = textAndIcons.colors.customColor;
            fgColorModeTheme = textAndIcons.colors.system.color;
            fgColorModeThemeVariant = textAndIcons.colors.system.colorSet;
            fgCustomColors = textAndIcons.colors.customColorList;
            fgOpacity = textAndIcons.colors.opacity;
            fgContrastFixEnabled = textAndIcons.colors.contrastCorrection.enable;
            fgSaturationEnabled = textAndIcons.colors.contrastCorrection.saturation.enable;
            fgSaturation = textAndIcons.colors.contrastCorrection.saturation.value;
            fgLightness = textAndIcons.colors.contrastCorrection.lightness;

            # Text and icons options > Shadow
            fgShadowEnabled = textAndIcons.shadow.enable;
            fgShadowColor = textAndIcons.shadow.color;
            fgShadowRadius = textAndIcons.shadow.strength;
            fgShadowX = textAndIcons.shadow.horizontalOffset;
            fgShadowY = textAndIcons.shadow.verticalOffset;

            # Text and icons options > Custom badges
            fixCustomBadges = textAndIcons.customBadges.fixCustomBadges;

            # Text and icons options > Force icon color
            forceRecolor = textAndIcons.forceIconColor.widgets;

            # Panel background options > Original background
            hideRealPanelBg = panelBackground.originalBackground.hide;
            panelRealBgOpacity = panelBackground.originalBackground.opacity;
            enableCustomPadding = panelBackground.originalBackground.fixedSizePadding.enable;
            panelPadding = panelBackground.originalBackground.fixedSizePadding.value;

            # Panel background options > Custom background
            panelBgEnabled = panelBackground.customBackground.enable;
            panelBgColorMode = panelBackground.customBackground.colorSource;
            panelBgColor = panelBackground.customBackground.customColor;
            panelBgColorModeTheme = panelBackground.customBackground.system.color;
            panelBgColorModeThemeVariant = panelBackground.customBackground.system.colorSet;
            panelBgOpacity = panelBackground.customBackground.opacity;
            panelBgRadius = panelBackground.customBackground.radius;

            # Panel background options > Custom background > Outline
            panelOutlineColorMode = panelBackground.customBackground.outline.colorSource;
            panelOutlineColor = panelBackground.customBackground.outline.customColor;
            panelOutlineColorModeTheme = panelBackground.customBackground.outline.system.color;
            panelOutlineColorModeThemeVariant = panelBackground.customBackground.outline.system.colorSet;
            panelOutlineOpacity = panelBackground.customBackground.outline.opacity;
            panelOutlineWidth = panelBackground.customBackground.outline.width;

            # Panel background options > Custom background > Shadow
            panelShadowColor = panelBackground.customBackground.shadow.color;
            panelShadowSize = panelBackground.customBackground.shadow.size;
            panelShadowX = panelBackground.customBackground.shadow.horizontalOffset;
            panelShadowY = panelBackground.customBackground.shadow.verticalOffset;

            # Blacklist options
            fgBlacklistedColorEnabled = blacklist.enable;
            fgBlacklistedColorMode = blacklist.colorSource;
            blacklistedFgColor = blacklist.customColor;
            fgBlacklistedColorModeTheme = blacklist.system.color;
            fgBlacklistedColorModeThemeVariant = blacklist.system.colorSet;
            blacklist = blacklist.widgets;

            # Layout options
            layoutEnabled = layout.enable;

            # Layout options > Background margin
            panelSpacing = layout.backgroundMargin.spacing;
            widgetBgHMargin = layout.backgroundMargin.horizontal;
            widgetBgVMargin = layout.backgroundMargin.vertical;

            # Layout options > Widget margin rules
            marginRules = layout.widgetMarginRules;
          };
        } settings;
      };
  };
}
</file>

<file path="modules/widgets/plasmusic-toolbar.nix">
{ lib, ... }:
let
  inherit (import ./lib.nix { inherit lib; }) configValueType;
  inherit (import ./default.nix { inherit lib; }) positionType sizeType;

  qfont = import ../../lib/qfont.nix { inherit lib; };

  mkBoolOption =
    description:
    lib.mkOption {
      type = with lib.types; nullOr bool;
      default = null;
      inherit description;
    };

  getIndexFromEnum =
    enum: value:
    if value == null then
      null
    else
      lib.lists.findFirstIndex (x: x == value)
        (throw "getIndexFromEnum (plasmusic-toolbar widget): Value ${value} isn't present in the enum. This is a bug")
        enum;

  styleStrategyType = lib.types.submodule {
    options = with qfont.styleStrategy; {
      prefer = lib.mkOption {
        type = prefer;
        default = "default";
        description = ''
          Which type of font is preferred by the font when finding an appropriate default family.

          `default`, `bitmap`, `device`, `outline`, `forceOutline` correspond to the
          `PreferDefault`, `PreferBitmap`, `PreferDevice`, `PreferOutline`, `ForceOutline` enum flags
          respectively.
        '';
      };
      matchingPrefer = lib.mkOption {
        type = matchingPrefer;
        default = "default";
        description = ''
          Whether the font matching process prefers exact matches, of best quality matches.

          `default` corresponds to not setting any enum flag, and `exact` and `quality`
          correspond to `PreferMatch` and `PreferQuality` enum flags respectively.
        '';
      };
      antialiasing = lib.mkOption {
        type = antialiasing;
        default = "default";
        description = ''
          Whether antialiasing is preferred for this font.

          `default` corresponds to not setting any enum flag, and `prefer` and `disable`
          correspond to `PreferAntialias` and `NoAntialias` enum flags respectively.
        '';
      };
      noSubpixelAntialias = lib.mkOption {
        type = lib.types.bool;
        default = false;
        description = ''
          If set to true, this font will try to avoid subpixel antialiasing.

          Corresponds to the `NoSubpixelAntialias` enum flag.
        '';
      };
      noFontMerging = mkOption {
        type = lib.types.bool;
        default = false;
        description = ''
          If set to true, this font will not try to find a substitute font when encountering missing glyphs.

          Corresponds to the `NoFontMerging` enum flag.
        '';
      };
      preferNoShaping = mkOption {
        type = lib.types.bool;
        default = false;
        description = ''
          If set to true, this font will not try to apply shaping rules that may be required for some scripts
          (e.g. Indic scripts), increasing performance if these rules are not required.

          Corresponds to the `PreferNoShaping` enum flag.
        '';
      };
    };
  };

  fontType = lib.types.submodule {
    options = {
      family = lib.mkOption {
        type = lib.types.str;
        description = "The font family of this font.";
        example = "Noto Sans";
      };
      pointSize = lib.mkOption {
        type = with lib.types; nullOr numbers.positive;
        default = null;
        description = ''
          The point size of this font.

          Could be a decimal, but usually an integer. Mutually exclusive with pixel size.
        '';
      };
      pixelSize = lib.mkOption {
        type = with lib.types; nullOr types.ints.u16;
        default = null;
        description = ''
          The pixel size of this font.

          Mutually exclusive with point size.
        '';
      };
      styleHint = lib.mkOption {
        type = qfont.styleHint;
        default = "anyStyle";
        description = ''
          The style hint of this font.

          See https://doc.qt.io/qt-6/qfont.html#StyleHint-enum for more.
        '';
      };
      weight = lib.mkOption {
        type = with lib.types; either (ints.between 1 1000) qfont.weight;
        default = "normal";
        description = ''
          The weight of the font, either as a number between 1 to 1000 or as a pre-defined weight string.

          See https://doc.qt.io/qt-6/qfont.html#Weight-enum for more.
        '';
      };
      style = lib.mkOption {
        type = qfont.style;
        default = "normal";
        description = "The style of the font.";
      };
      underline = lib.mkOption {
        type = lib.types.bool;
        default = false;
        description = "Whether the font is underlined.";
      };
      strikeOut = lib.mkOption {
        type = lib.types.bool;
        default = false;
        description = "Whether the font is struck out.";
      };
      fixedPitch = lib.mkOption {
        type = lib.types.bool;
        default = false;
        description = "Whether the font has a fixed pitch.";
      };
      capitalization = lib.mkOption {
        type = qfont.capitalization;
        default = "mixedCase";
        description = ''
          The capitalization settings for this font.

          See https://doc.qt.io/qt-6/qfont.html#Capitalization-enum for more.
        '';
      };
      letterSpacingType = lib.mkOption {
        type = qfont.spacingType;
        default = "percentage";
        description = ''
          Whether to use percentage or absolute spacing for this font.

          See https://doc.qt.io/qt-6/qfont.html#SpacingType-enum for more.
        '';
      };
      letterSpacing = lib.mkOption {
        type = lib.types.number;
        default = 0;
        description = ''
          The amount of letter spacing for this font.

          Could be a percentage or an absolute spacing change (positive increases spacing, negative decreases spacing),
          based on the selected `letterSpacingType`.
        '';
      };
      wordSpacing = lib.mkOption {
        type = lib.types.number;
        default = 0;
        description = ''
          The amount of word spacing for this font, in pixels.

          Positive values increase spacing while negative ones decrease spacing.
        '';
      };
      stretch = lib.mkOption {
        type = with lib.types; either (ints.between 1 4000) qfont.stretch;
        default = "anyStretch";
        description = ''
          The stretch factor for this font, as an integral percentage (i.e. 150 means a 150% stretch),
          or as a pre-defined stretch factor string.
        '';
      };
      styleStrategy = lib.mkOption {
        type = styleStrategyType;
        default = { };
        description = ''
          The strategy for matching similar fonts to this font.

          See https://doc.qt.io/qt-6/qfont.html#StyleStrategy-enum for more.
        '';
      };
      styleName = lib.mkOption {
        type = with lib.types; nullOr str;
        default = null;
        description = ''
          The style name of this font, overriding the `style` and `weight` parameters when set.
          Used for special fonts that have styles beyond traditional settings.
        '';
      };
    };
  };
in
{
  plasmusicToolbar = {
    description = "KDE Plasma widget that shows currently playing song information and provide playback controls.";

    opts = {
      position = lib.mkOption {
        type = positionType;
        example = {
          horizontal = 250;
          vertical = 100;
        };
        description = "The position of the widget. (Only for desktop widget)";
      };
      size = lib.mkOption {
        type = sizeType;
        example = {
          width = 500;
          height = 100;
        };
        description = "The size of the widget. (Only for desktop widget)";
      };
      panelIcon = {
        icon = lib.mkOption {
          type = with lib.types; nullOr str;
          default = null;
          example = "view-media-track";
          description = "Icon to show in the panel.";
        };
        albumCover = {
          fallbackToIcon = mkBoolOption "Whether to fallback to icon if cover is not available.";
          useAsIcon = mkBoolOption "Whether to use album cover as icon or not.";
          radius = lib.mkOption {
            type = with lib.types; nullOr (ints.between 0 25);
            default = null;
            example = 8;
            description = "Radius of the album cover icon.";
          };
        };
      };
      playbackSource = lib.mkOption {
        type = with lib.types; nullOr (either (enum [ "auto" ]) str);
        default = null;
        example = "auto";
        description = "Preferred source to use for playback.";
        apply =
          source:
          if source == null then
            { }
          else if source == "auto" then
            { choosePlayerAutomatically = true; }
          else
            {
              choosePlayerAutomatically = false;
              preferredPlayerIdentity = source;
            };
      };
      songText = {
        maximumWidth = lib.mkOption {
          type = with lib.types; nullOr ints.unsigned;
          default = null;
          example = 200;
          description = "Maximum width of the song text.";
        };
        scrolling = {
          enable = mkBoolOption "Whether to enable scrolling text or not.";
          behavior =
            let
              enumVals = [
                "alwaysScroll"
                "scrollOnHover"
                "alwaysScrollExceptOnHover"
              ];
            in
            lib.mkOption {
              type = with lib.types; nullOr (enum enumVals);
              default = null;
              example = "alwaysScroll";
              description = "Scrolling behavior of the song text.";
              apply = getIndexFromEnum enumVals;
            };
          speed = lib.mkOption {
            type = with lib.types; nullOr (ints.between 1 10);
            default = null;
            example = 3;
            description = "Speed of the scrolling text.";
          };
          resetOnPause = mkBoolOption "Whether to reset the scrolling text when the song is paused or not.";
        };
        displayInSeparateLines = mkBoolOption "Whether to display song information (title and artist) in separate lines or not.";
      };
      musicControls = {
        showPlaybackControls = mkBoolOption "Whether to show playback controls or not.";
        volumeStep = lib.mkOption {
          type = with lib.types; nullOr (ints.between 1 100);
          default = null;
          example = 5;
          description = "Step size for volume control.";
        };
      };
      font = lib.mkOption {
        type = lib.types.nullOr fontType;
        default = null;
        example = {
          family = "Noto Sans";
          pointSize = 10;
        };
        description = "Custom font to use for the widget.";
        apply = font: if font == null then null else qfont.fontToString font;
      };
      background =
        let
          enumVals = [
            "standard"
            "transparent"
            "transparentShadow"
          ];
        in
        lib.mkOption {
          type = with lib.types; nullOr (enum enumVals);
          default = null;
          example = "transparent";
          description = "Widget background type (only for desktop widget)";
          apply =
            background:
            if background == null then
              null
            else
              builtins.elemAt
                [
                  1
                  0
                  4
                ]
                (
                  lib.lists.findFirstIndex (
                    x: x == background
                  ) (throw "plasmusic-toolbar: non-existent background ${background}. This is a bug!") enumVals
                );
        };
      albumCover = {
        albumPlaceholder = lib.mkOption {
          type = with lib.types; nullOr str;
          default = null;
          example = "file:///home/user/placeholder.png";
          description = "Path to the album placeholder image.";
        };
      };
      settings = lib.mkOption {
        type = configValueType;
        default = null;
        example = {
          General = {
            useCustomFont = true;
          };
        };
        description = ''
          Extra configuration for the widget options.

          See available options at https://github.com/ccatterina/plasmusic-toolbar/blob/main/src/contents/config/main.xml
        '';
        apply = settings: if settings == null then { } else settings;
      };
    };
    convert =
      {
        panelIcon,
        songText,
        musicControls,
        font,
        background,
        albumCover,
        playbackSource,
        settings,
        ...
      }:
      {
        name = "plasmusic-toolbar";
        config = lib.recursiveUpdate {
          General =
            lib.filterAttrs (_: v: v != null) {
              panelIcon = panelIcon.icon;
              useAlbumCoverAsPanelIcon = panelIcon.albumCover.useAsIcon;
              albumCoverRadius = panelIcon.albumCover.radius;
              fallbackToIconWhenArtNotAvailable = panelIcon.albumCover.fallbackToIcon;

              maxSongWidthInPanel = songText.maximumWidth;
              separateText = songText.displayInSeparateLines;

              textScrollingEnabled = songText.scrolling.enable;
              textScrollingBehaviour = songText.scrolling.behavior;
              textScrollingSpeed = songText.scrolling.speed;
              textScrollingResetOnPause = songText.scrolling.resetOnPause;

              commandsInPanel = musicControls.showPlaybackControls;
              volumeStep = musicControls.volumeStep;

              useCustomFont = font != null;
              customFont = font;

              desktopWidgetBg = background;

              albumPlaceholder = albumCover.albumPlaceholder;
            }
            // playbackSource;
        } settings;
      };
  };
}
</file>

<file path="modules/widgets/system-monitor.nix">
{ lib, ... }:
let
  inherit (lib) mkOption types;
  inherit (import ./lib.nix { inherit lib; }) configValueType;
  inherit (import ./default.nix { inherit lib; }) positionType sizeType;

  # KDE expects a key/value pair like this:
  # ```ini
  # highPrioritySensorIds=["cpu/all/usage", "cpu/all/averageTemperature"]
  # ```
  #
  # Which is **different** to what would happen if you pass a list of strings to the JS script:
  # ```ini
  # highPrioritySensorIds=cpu/all/usage,cpu/all/averageTemperature
  # ```
  #
  # So, to satisfy the expected format we must quote the ENTIRE string as a valid JS string,
  # which means constructing a string that looks like this in the source code:
  # "[\"cpu/all/usage\", \"cpu/all/averageTemperature\"]"
  toEscapedList =
    ids: if ids != null then "[${lib.concatMapStringsSep ", " (x: ''\"${x}\"'') ids}]" else null;

  mkListOption = mkOption {
    type = with types; nullOr (listOf str);
    default = null;
    apply = toEscapedList;
  };

  # {name, color} -> {name, value}
  # Convert the sensor attrset into a name-value pair expected by listToAttrs
  toColorKV =
    { name, color, ... }:
    {
      inherit name;
      value = color;
    };
  toLabelKV =
    { name, label, ... }:
    {
      inherit name;
      value = label;
    };
in
{
  systemMonitor = {
    description = "A system monitor widget.";

    opts = {
      # See https://invent.kde.org/plasma/plasma-workspace/-/blob/master/applets/systemmonitor/systemmonitor/package/contents/config/main.xml for the accepted raw options

      position = mkOption {
        type = positionType;
        example = {
          horizontal = 250;
          vertical = 50;
        };
        description = "The position of the widget. (Only for desktop widget)";
      };
      size = mkOption {
        type = sizeType;
        example = {
          width = 500;
          height = 500;
        };
        description = "The size of the widget. (Only for desktop widget)";
      };
      title = mkOption {
        type = with types; nullOr str;
        default = null;
        description = "The title of this system monitor.";
      };
      showTitle = mkOption {
        type = with types; nullOr bool;
        default = null;
        description = "Show or hide the title.";
      };
      showLegend = mkOption {
        type = with types; nullOr bool;
        default = null;
        description = "Show or hide the legend.";
      };
      displayStyle = mkOption {
        type = with types; nullOr str;
        default = null;
        example = "org.kde.ksysguard.barchart";
        description = "The display style of the chart. Uses the internal plugin name.";
      };
      sensors = mkOption {
        type =
          with types;
          nullOr (
            listOf (submodule {
              options = {
                name = mkOption {
                  type = str;
                  example = "cpu/all/usage";
                  description = "The name of the sensor.";
                };
                color = mkOption {
                  type = str; # TODO maybe use a better type
                  example = "255,255,255";
                  description = "The color of the sensor, as a string containing 8-bit integral RGB values separated by commas";
                };
                label = mkOption {
                  type = str;
                  example = "CPU %";
                  description = "The label of the sensor.";
                };
              };
            })
          );
        default = null;
        example = [
          {
            name = "gpu/gpu1/usage";
            color = "180,190,254";
            label = "GPU %";
          }
        ];
        description = ''
          The list of sensors displayed as a part of the graph/chart.
        '';
        apply =
          sensors:
          lib.optionalAttrs (sensors != null) {
            SensorColors = builtins.listToAttrs (map toColorKV sensors);
            SensorLabels = builtins.listToAttrs (map toLabelKV sensors);
            Sensors.highPrioritySensorIds = toEscapedList (map (s: s.name) sensors);
          };
      };

      totalSensors = mkListOption // {
        example = [ "cpu/all/usage" ];
        description = ''
          The list of "total sensors" displayed on top of the graph/chart.
        '';
      };
      textOnlySensors = mkListOption // {
        example = [
          "cpu/all/averageTemperature"
          "cpu/all/averageFrequency"
        ];
        description = ''
          The list of text-only sensors, displayed in the pop-up upon clicking the widget.
        '';
      };
      range = {
        from = mkOption {
          type = with lib.types; nullOr (ints.between 0 100);
          default = null;
          description = "The lower range the sensors can take.";
        };
        to = mkOption {
          type = with lib.types; nullOr (ints.between 0 100);
          default = null;
          description = "The upper range the sensors can take.";
        };
      };
      settings = mkOption {
        type = configValueType;
        default = null;
        description = "Extra configuration options for the widget.";
        apply = settings: if settings == null then { } else settings;
      };
    };

    convert =
      {
        title,
        showTitle,
        showLegend,
        displayStyle,
        totalSensors,
        sensors,
        textOnlySensors,
        range,
        settings,
        ...
      }:
      {
        name = "org.kde.plasma.systemmonitor";
        config = lib.filterAttrsRecursive (_: v: v != null) (
          lib.recursiveUpdate {
            Appearance = {
              inherit title;
              inherit showTitle;
              chartFace = displayStyle;
            };
            Sensors = {
              lowPrioritySensorIds = textOnlySensors;
              totalSensors = totalSensors;
            };
            "org.kde.ksysguard.piechart/General" = {
              inherit showLegend;
              rangeAuto = (range.from == null && range.to == null);
              rangeFrom = range.from;
              rangeTo = range.to;
            };
          } (lib.recursiveUpdate sensors settings)
        );
      };
  };
}
</file>

<file path="modules/widgets/system-tray.nix">
{ lib, widgets, ... }:
let
  inherit (lib) mkOption types;
  inherit (import ./lib.nix { inherit lib; }) configValueType;
  inherit (import ./default.nix { inherit lib; }) positionType sizeType;

  mkBoolOption =
    description:
    mkOption {
      type = with types; nullOr bool;
      default = null;
      inherit description;
    };
in
{
  systemTray = {
    description = "A system tray of other widgets/plasmoids";

    opts = (
      { options, ... }:
      {
        # See https://invent.kde.org/plasma/plasma-workspace/-/blob/master/applets/systemtray/package/contents/config/main.xml for the accepted raw options.

        position = mkOption {
          type = positionType;
          example = {
            horizontal = 250;
            vertical = 50;
          };
          description = "The position of the widget. (Only for desktop widget)";
        };
        size = mkOption {
          type = sizeType;
          example = {
            width = 500;
            height = 500;
          };
          description = "The size of the widget. (Only for desktop widget)";
        };
        pin = mkBoolOption "Whether the popup should remain open when another window is activated.";

        icons = {
          spacing =
            let
              enum = [
                "small"
                "medium"
                "large"
              ];
            in
            mkOption {
              type = types.nullOr (types.either (types.enum enum) types.ints.positive);
              default = null;
              description = ''
                The spacing between icons.

                Could be an integer unit, or "small" (1 unit), "medium" (2 units) or "large" (6 units).
              '';
              apply =
                spacing:
                (
                  if (spacing == null) then
                    null
                  else
                    (
                      if builtins.isInt spacing then
                        spacing
                      else
                        builtins.elemAt
                          [
                            1
                            2
                            6
                          ]
                          (
                            lib.lists.findFirstIndex (
                              x: x == spacing
                            ) (throw "systemTray: nonexistent spacing ${spacing}! This is a bug!") enum
                          )
                    )
                );
            };
          scaleToFit = mkBoolOption ''
            Whether to automatically scale System Tray icons to fix the available thickness of the panel.

            If false, tray icons will be capped at the smallMedium size (22px) and become a two-row/column
            layout when the panel is thick.
          '';
        };

        items = {
          showAll = mkBoolOption "If true, all system tray entries will always be in the main bar, outside the popup.";

          hidden = mkOption {
            type = types.nullOr (types.listOf types.str);
            default = null;
            example = [
              # Plasmoid plugin example
              "org.kde.plasma.brightness"

              # StatusNotifier example
              "org.kde.plasma.addons.katesessions"
            ];
            description = ''
              List of widgets that should be hidden from the main bar, only visible in the popup.

              Expects a list of plasmoid plugin IDs or StatusNotifier IDs.
            '';
          };

          shown = mkOption {
            type = types.nullOr (types.listOf types.str);
            default = null;
            example = [
              # Plasmoid plugin example
              "org.kde.plasma.battery"

              # StatusNotifier example
              "org.kde.plasma.addons.katesessions"
            ];
            description = ''
              List of widgets that should be shown in the main bar.

              Expects a list of plasmoid plugin IDs or StatusNotifier IDs.
            '';
          };

          extra = mkOption {
            type = types.nullOr (types.listOf types.str);
            default = null;
            example = [ "org.kde.plasma.battery" ];
            description = ''
              List of extra widgets that are explicitly enabled in the system tray.

              Expects a list of plasmoid plugin IDs.
            '';
          };

          configs = mkOption {
            # The type here is deliberately NOT modelled exactly correctly,
            # to allow the apply function to provide better errors with the richer option and type system.
            type = types.attrsOf (types.attrsOf types.anything);
            default = { };
            example = {
              # Example of a widget-specific config
              battery.showPercentage = true;
              keyboardLayout.displayStyle = "label";

              # Example of raw config for an untyped widget
              "org.kde.plasma.devicenotifier".config.General = {
                removableDevices = false;
                nonRemovableDevices = true;
              };
            };
            description = ''
              Configurations for each widget in the tray.

              Uses widget-specific configs if the key is a known widget type,
              otherwise uses raw configs that's not specifically checked to be valid,
              or even idiomatic in Nix!
            '';

            # You might be asking yourself... WTH is this?
            # Simply put, this thing allows us to apply the same defaults as defined by the options,
            # Instead of forcing downstream converters to provide defaults to everything *again*.
            # The way to do this is kind of cursed and honestly it might be easier if `lib.evalOptionValue`
            # is not recommended for public use. Oh well.
            apply = lib.mapAttrsToList (
              name: config:
              let
                isKnownWidget = widgets.isKnownWidget name;
                # Raw widgets aren't wrapped in an extra attrset layer, unlike known ones
                # We wrap them back up to ensure the path is accurate
                loc = options.items.configs.loc ++ lib.optional (!isKnownWidget) name;
              in
              widgets.convert
                (lib.mergeDefinitions loc widgets.type [
                  {
                    file = builtins.head options.items.configs.files;
                    # Looks a bit funny, does the job just right.
                    value = if isKnownWidget then { ${name} = config; } else config // { inherit name; };
                  }
                ]).mergedValue
            );
          };
        };
        settings = mkOption {
          type = configValueType;
          default = null;
          description = "Extra configuration options for the widget.";
          apply = settings: if settings == null then { } else settings;
        };
      }
    );

    convert =
      {
        pin,
        icons,
        items,
        settings,
        ...
      }:
      let
        sets = {
          General = lib.filterAttrs (_: v: v != null) {
            inherit pin;
            extraItems = items.extra;
            hiddenItems = items.hidden;
            shownItems = items.shown;
            showAllItems = items.showAll;

            scaleIconsToFit = icons.scaleToFit;
            iconSpacing = icons.spacing;
          };
        };
        mergedSettings = lib.recursiveUpdate sets settings;
      in
      {
        name = "org.kde.plasma.systemtray";
        extraConfig = ''
          (widget) => {
            const tray = desktopById(widget.readConfig("SystrayContainmentId"));
            if (!tray) return; // if somehow the containment doesn't exist

            ${widgets.lib.setWidgetSettings "tray" mergedSettings}
            ${widgets.lib.addWidgetStmts "tray" "trayWidgets" items.configs}
          }
        '';
      };
  };
}
</file>

<file path="modules/default.nix">
{ lib, ... }:

{
  imports = [
    ./apps
    ./desktop.nix
    ./files.nix
    ./fonts.nix
    ./hotkeys.nix
    ./input.nix
    ./krunner.nix
    ./kscreenlocker.nix
    ./kwin.nix
    ./panels.nix
    ./powerdevil.nix
    ./session.nix
    ./shortcuts.nix
    ./spectacle.nix
    ./startup.nix
    ./window-rules.nix
    ./windows.nix
    ./workspace.nix
  ];

  options.programs.plasma.enable = lib.mkEnableOption ''
    declarative configuration options for the KDE Plasma Desktop.
  '';
}
</file>

<file path="modules/desktop.nix">
{ config, lib, ... }:
let
  cfg = config.programs.plasma;

  widgets = import ./widgets { inherit lib; };

  desktopIconSortingModeId = {
    manual = -1;
    name = 0;
    size = 1;
    date = 2;
    type = 6;
  };

  mouseActions = {
    applicationLauncher = "org.kde.applauncher";
    contextMenu = "org.kde.contextmenu";
    paste = "org.kde.paste";
    switchActivity = "switchactivity";
    switchVirtualDesktop = "org.kde.switchdesktop";
    switchWindow = "switchwindow";
  };

  mouseActionNamesEnum = lib.types.enum (builtins.attrNames mouseActions);

  # Becomes true if any option under "cfg.desktop.icons" is set to something other than null.
  anyDesktopFolderSettingsSet =
    let
      recurse =
        l: lib.any (v: if builtins.isAttrs v then recurse v else v != null) (builtins.attrValues l);
    in
    recurse cfg.desktop.icons;

  # Becomes true if any option under "cfg.desktop.mouseActions" is set to something other than null.
  anyDesktopMouseActionsSet = lib.any (v: v != null) (builtins.attrValues cfg.desktop.mouseActions);
in
{
  imports = [
    (lib.mkRenamedOptionModule
      [
        "programs"
        "plasma"
        "workspace"
        "desktop"
        "icons"
        "arrangement"
      ]
      [
        "programs"
        "plasma"
        "desktop"
        "icons"
        "arrangement"
      ]
    )
    (lib.mkRenamedOptionModule
      [
        "programs"
        "plasma"
        "workspace"
        "desktop"
        "icons"
        "alignment"
      ]
      [
        "programs"
        "plasma"
        "desktop"
        "icons"
        "alignment"
      ]
    )
    (lib.mkRenamedOptionModule
      [
        "programs"
        "plasma"
        "workspace"
        "desktop"
        "icons"
        "lockInPlace"
      ]
      [
        "programs"
        "plasma"
        "desktop"
        "icons"
        "lockInPlace"
      ]
    )
    (lib.mkRenamedOptionModule
      [
        "programs"
        "plasma"
        "workspace"
        "desktop"
        "icons"
        "sorting"
        "mode"
      ]
      [
        "programs"
        "plasma"
        "desktop"
        "icons"
        "sorting"
        "mode"
      ]
    )
    (lib.mkRenamedOptionModule
      [
        "programs"
        "plasma"
        "workspace"
        "desktop"
        "icons"
        "sorting"
        "descending"
      ]
      [
        "programs"
        "plasma"
        "desktop"
        "icons"
        "sorting"
        "descending"
      ]
    )
    (lib.mkRenamedOptionModule
      [
        "programs"
        "plasma"
        "workspace"
        "desktop"
        "icons"
        "sorting"
        "foldersFirst"
      ]
      [
        "programs"
        "plasma"
        "desktop"
        "icons"
        "sorting"
        "foldersFirst"
      ]
    )
    (lib.mkRenamedOptionModule
      [
        "programs"
        "plasma"
        "workspace"
        "desktop"
        "icons"
        "size"
      ]
      [
        "programs"
        "plasma"
        "desktop"
        "icons"
        "size"
      ]
    )
    (lib.mkRenamedOptionModule
      [
        "programs"
        "plasma"
        "workspace"
        "desktop"
        "icons"
        "folderPreviewPopups"
      ]
      [
        "programs"
        "plasma"
        "desktop"
        "icons"
        "folderPreviewPopups"
      ]
    )
    (lib.mkRenamedOptionModule
      [
        "programs"
        "plasma"
        "workspace"
        "desktop"
        "icons"
        "previewPlugins"
      ]
      [
        "programs"
        "plasma"
        "desktop"
        "icons"
        "previewPlugins"
      ]
    )
    (lib.mkRenamedOptionModule
      [
        "programs"
        "plasma"
        "workspace"
        "desktop"
        "mouseActions"
        "leftClick"
      ]
      [
        "programs"
        "plasma"
        "desktop"
        "mouseActions"
        "leftClick"
      ]
    )
    (lib.mkRenamedOptionModule
      [
        "programs"
        "plasma"
        "workspace"
        "desktop"
        "mouseActions"
        "middleClick"
      ]
      [
        "programs"
        "plasma"
        "desktop"
        "mouseActions"
        "middleClick"
      ]
    )
    (lib.mkRenamedOptionModule
      [
        "programs"
        "plasma"
        "workspace"
        "desktop"
        "mouseActions"
        "rightClick"
      ]
      [
        "programs"
        "plasma"
        "desktop"
        "mouseActions"
        "rightClick"
      ]
    )
    (lib.mkRenamedOptionModule
      [
        "programs"
        "plasma"
        "workspace"
        "desktop"
        "mouseActions"
        "verticalScroll"
      ]
      [
        "programs"
        "plasma"
        "desktop"
        "mouseActions"
        "verticalScroll"
      ]
    )
  ];

  options.programs.plasma.desktop = {
    icons = {
      arrangement = lib.mkOption {
        type =
          with lib.types;
          nullOr (enum [
            "leftToRight"
            "topToBottom"
          ]);
        default = null;
        example = "topToBottom";
        description = ''
          The direction in which desktop icons are to be arranged.
        '';
      };

      alignment = lib.mkOption {
        type =
          with lib.types;
          nullOr (enum [
            "left"
            "right"
          ]);
        default = null;
        example = "right";
        description = ''
          Whether to align the icons on the left (the default) or right
          side of the screen.
        '';
      };

      lockInPlace = lib.mkOption {
        type = with lib.types; nullOr bool;
        default = null;
        example = true;
        description = ''
          Locks the position of all desktop icons to the order and placement
          defined by `arrangement`, `alignment` and the `sorting` options,
          so they cannot be manually moved.
        '';
      };

      sorting = {
        mode = lib.mkOption {
          type = with lib.types; nullOr (enum (builtins.attrNames desktopIconSortingModeId));
          default = null;
          example = "type";
          description = ''
            Specifies the sort mode for the desktop icons. By default, they are
            sorted by `name`.
          '';
          apply = sortMode: if (sortMode == null) then null else desktopIconSortingModeId.${sortMode};
        };

        descending = lib.mkOption {
          type = with lib.types; nullOr bool;
          default = null;
          example = true;
          description = ''
            Reverses the sorting order if enabled. Sorting is ascending by default.
          '';
        };

        foldersFirst = lib.mkOption {
          type = with lib.types; nullOr bool;
          default = null;
          example = false;
          description = ''
            Folders are sorted separately from files by default. This means
            folders appear first, sorted, for example, ascending by name,
            followed by files, also sorted ascending by name.
            If this option is disabled, all items are sorted regardless
            of type.
          '';
        };
      };

      size = lib.mkOption {
        type = with lib.types; nullOr (ints.between 0 6);
        default = null;
        example = 2;
        description = ''
          The desktop icon size, which is normally configured via a slider
          with seven possible values ranging from small (`0`) to large (`6`).
          The fourth position (`3`) is the default.
        '';
      };

      folderPreviewPopups = lib.mkOption {
        type = with lib.types; nullOr bool;
        default = null;
        example = false;
        description = ''
          Enables the arrow button when hovering over a folder on the desktop
          which shows a preview popup of the folders contents.

          Enabled by default.
        '';
      };

      previewPlugins = lib.mkOption {
        type = with lib.types; nullOr (listOf str);
        default = null;
        example = [
          "audiothumbnail"
          "fontthumbnail"
        ];
        description = ''
          Configures the preview plugins used to preview desktop files and folders.
        '';
      };
    };

    mouseActions = {
      leftClick = lib.mkOption {
        type = lib.types.nullOr mouseActionNamesEnum;
        default = null;
        example = "appLauncher";
        description = "Action for a left mouse click on the desktop.";
        apply = value: if (value == null) then null else mouseActions.${value};
      };

      middleClick = lib.mkOption {
        type = lib.types.nullOr mouseActionNamesEnum;
        default = null;
        example = "switchWindow";
        description = "Action for a middle mouse click on the desktop.";
        apply = value: if (value == null) then null else mouseActions.${value};
      };

      rightClick = lib.mkOption {
        type = lib.types.nullOr mouseActionNamesEnum;
        default = null;
        example = "contextMenu";
        description = "Action for a right mouse click on the desktop.";
        apply = value: if (value == null) then null else mouseActions.${value};
      };

      verticalScroll = lib.mkOption {
        type = lib.types.nullOr mouseActionNamesEnum;
        default = null;
        example = "switchVirtualDesktop";
        description = "Action for scrolling (vertically) while hovering over the desktop.";
        apply = value: if (value == null) then null else mouseActions.${value};
      };
    };

    widgets = lib.mkOption {
      type = with lib.types; nullOr (listOf widgets.desktopType);
      default = null;
      example = [
        {
          name = "org.kde.plasma.digitalclock";
          position = {
            horizontal = 51;
            vertical = 100;
          };
          size = {
            width = 250;
            height = 250;
          };
          config.Appearance.showDate = false;
        }
        {
          plasmusicToolbar = {
            position = {
              horizontal = 51;
              vertical = 300;
            };
            size = {
              width = 250;
              height = 400;
            };
            background = "transparentShadow";
          };
        }
      ];
      description = ''
        A list of widgets to be added to the desktop.
      '';
      apply = option: if option == null then null else (map widgets.desktopConvert option);
    };
  };

  config = (
    lib.mkIf cfg.enable {
      programs.plasma.startup = {
        desktopScript."set_desktop_folder_settings" = (
          lib.mkIf anyDesktopFolderSettingsSet {
            text = ''
              // Desktop folder settings
              let allDesktops = desktops();
              for (const desktop of allDesktops) {
                desktop.currentConfigGroup = ["General"];
                ${
                  lib.optionalString (
                    cfg.desktop.icons.arrangement == "topToBottom"
                  ) ''desktop.writeConfig("arrangement", 1);''
                }
                ${
                  lib.optionalString (cfg.desktop.icons.alignment == "right") ''desktop.writeConfig("alignment", 1);''
                }
                ${
                  lib.optionalString (cfg.desktop.icons.lockInPlace == true) ''desktop.writeConfig("locked", true);''
                }
                ${widgets.lib.stringIfNotNull cfg.desktop.icons.size ''desktop.writeConfig("iconSize", ${builtins.toString cfg.desktop.icons.size});''}
                ${
                  lib.optionalString (
                    cfg.desktop.icons.folderPreviewPopups == false
                  ) ''desktop.writeConfig("popups", false);''
                }
                ${widgets.lib.stringIfNotNull cfg.desktop.icons.previewPlugins ''desktop.writeConfig("previewPlugins", "${lib.strings.concatStringsSep "," cfg.desktop.icons.previewPlugins}");''}
                ${widgets.lib.stringIfNotNull cfg.desktop.icons.sorting.mode ''desktop.writeConfig("sortMode", ${builtins.toString cfg.desktop.icons.sorting.mode});''}
                ${
                  lib.optionalString (
                    cfg.desktop.icons.sorting.descending == true
                  ) ''desktop.writeConfig("sortDesc", true);''
                }
                ${
                  lib.optionalString (
                    cfg.desktop.icons.sorting.foldersFirst == false
                  ) ''desktop.writeConfig("sortDirsFirst", false);''
                }
              }
            '';
            priority = 3;
          }
        );

        desktopScript."set_desktop_mouse_actions" = (
          lib.mkIf anyDesktopMouseActionsSet {
            text = ''
              // Mouse actions
              let configFile = ConfigFile('plasma-org.kde.plasma.desktop-appletsrc');
              configFile.group = 'ActionPlugins';
              // References the section [ActionPlugins][0].
              let actionPluginSubSection = ConfigFile(configFile, 0)
              ${widgets.lib.stringIfNotNull cfg.desktop.mouseActions.leftClick ''actionPluginSubSection.writeEntry("LeftButton;NoModifier", "${cfg.desktop.mouseActions.leftClick}");''}
              ${widgets.lib.stringIfNotNull cfg.desktop.mouseActions.middleClick ''actionPluginSubSection.writeEntry("MiddleButton;NoModifier", "${cfg.desktop.mouseActions.middleClick}");''}
              ${widgets.lib.stringIfNotNull cfg.desktop.mouseActions.rightClick ''actionPluginSubSection.writeEntry("RightButton;NoModifier", "${cfg.desktop.mouseActions.rightClick}");''}
              ${widgets.lib.stringIfNotNull cfg.desktop.mouseActions.verticalScroll ''actionPluginSubSection.writeEntry("wheel:Vertical;NoModifier", "${cfg.desktop.mouseActions.verticalScroll}");''}
            '';
            priority = 3;
            restartServices = [ "plasma-plasmashell" ];
          }
        );

        desktopScript."set_desktop_widgets" = (
          lib.mkIf (cfg.desktop.widgets != null) {
            text = ''
              // Desktop widgets
              let allDesktops = desktops();

              // Remove all desktop widgets
              allDesktops.forEach((desktop) => {
                desktop.widgets().forEach((widget) => {
                  widget.remove();
                });
              });

              for (let i = 0; i < allDesktops.length; i++) {
                const desktop = allDesktops[i];
                ${widgets.lib.addDesktopWidgetStmts "desktop" "desktopWidgets" cfg.desktop.widgets}
              }
            '';
            priority = 2;
          }
        );
      };
    }
  );
}
</file>

<file path="modules/files.nix">
# Low-level access to changing Plasma settings.
{
  config,
  lib,
  pkgs,
  ...
}:

let
  inherit (import ../lib/writeconfig.nix { inherit lib pkgs config; }) writeConfig;
  inherit
    (import ../lib/types.nix {
      inherit lib;
      inherit config;
    })
    coercedSettingsType
    ;

  # Helper function to prepend the appropriate path prefix (e.g. XDG_CONFIG_HOME) to file
  prependPath =
    prefix: attrset:
    lib.mapAttrs' (path: config: {
      name = "${prefix}/${path}";
      value = config;
    }) attrset;
  plasmaCfg = config.programs.plasma;
  cfg =
    (prependPath config.home.homeDirectory plasmaCfg.file)
    // (prependPath config.xdg.configHome plasmaCfg.configFile)
    // (prependPath config.xdg.dataHome plasmaCfg.dataFile);

  fileSettingsType = with lib.types; attrsOf (attrsOf (attrsOf coercedSettingsType));

  ##############################################################################
  # Generate a script that will use write_config.py to update all
  # settings.
  resetFilesList = (
    map (f: "${config.xdg.configHome}/${f}") (
      lib.lists.subtractLists plasmaCfg.resetFilesExclude plasmaCfg.resetFiles
    )
  );
  script = pkgs.writeScript "plasma-config" (writeConfig cfg plasmaCfg.overrideConfig resetFilesList);

  ##############################################################################
  # Generate a script that will remove all the current config files.
  defaultResetFiles = (
    if plasmaCfg.overrideConfig then
      [
        "auroraerc"
        "baloofilerc"
        "dolphinrc"
        "ffmpegthumbsrc"
        "kactivitymanagerdrc"
        "katerc"
        "kcminputrc"
        "KDE/Sonnet.conf"
        "kde.org/ghostwriter.conf"
        "kded5rc"
        "kded6rc"
        "kdeglobals"
        "kgammarc"
        "kglobalshortcutsrc"
        "khotkeysrc"
        "kiorc"
        "klaunchrc"
        "klipperrc"
        "kmixrc"
        "krunnerrc"
        "kscreenlockerrc"
        "kservicemenurc"
        "ksmserverrc"
        "ksplashrc"
        "kwalletrc"
        "kwin_rules_dialogrc"
        "kwinrc"
        "kwinrulesrc"
        "kxkbrc"
        "plasma_calendar_alternatecalendar"
        "plasma_calendar_astronomicalevents"
        "plasma_calendar_holiday_regions"
        "plasma-localerc"
        "plasmanotifyrc"
        "plasmarc"
        "plasmashellrc"
        "powerdevilrc"
        "systemsettingsrc"
      ]
    else
      lib.optional (builtins.length plasmaCfg.window-rules > 0) "kwinrulesrc"
  );
in
{
  options.programs.plasma = {
    file = lib.mkOption {
      type = fileSettingsType;
      default = { };
      description = ''
        An attribute set where the keys are file names (relative to
        `$HOME`) and the values are attribute sets that represent
        configuration groups and settings inside those groups.
      '';
    };
    configFile = lib.mkOption {
      type = fileSettingsType;
      default = { };
      description = ''
        An attribute set where the keys are file names (relative to
        `$XDG_CONFIG_HOME`) and the values are attribute sets that
        represent configuration groups and settings inside those groups.
      '';
    };
    dataFile = lib.mkOption {
      type = fileSettingsType;
      default = { };
      description = ''
        An attribute set where the keys are file names (relative to
        `$XDG_DATA_HOME`) and the values are attribute sets that
        represent configuration groups and settings inside those groups.
      '';
    };
    overrideConfig = lib.mkOption {
      type = lib.types.bool;
      default = false;
      description = ''
        Wether to discard changes made outside `plasma-manager`. If enabled, all
        settings not specified explicitly in `plasma-manager` will be set to the
        default on next login. This will automatically delete a lot of
        KDE Plasma configuration files on each generation, so do be careful with this
        option.
      '';
    };
    resetFiles = lib.mkOption {
      type = lib.types.listOf lib.types.str;
      default = defaultResetFiles;
      description = ''
        Configuration files which should be explicitly deleted on each generation.
      '';
    };
    resetFilesExclude = lib.mkOption {
      type = lib.types.listOf lib.types.str;
      default = [ ];
      description = ''
        Configuration files which explicitly should not be deleted on each generation, if `overrideConfig` is enabled.
      '';
    };
    immutableByDefault = lib.mkEnableOption "" // {
      description = "Whether to make keys written by plasma-manager immutable by default.";
    };
  };

  imports = [
    (lib.mkRenamedOptionModule
      [
        "programs"
        "plasma"
        "files"
      ]
      [
        "programs"
        "plasma"
        "configFile"
      ]
    )
    (lib.mkRenamedOptionModule
      [
        "programs"
        "plasma"
        "overrideConfigFiles"
      ]
      [
        "programs"
        "plasma"
        "resetFiles"
      ]
    )
    (lib.mkRenamedOptionModule
      [
        "programs"
        "plasma"
        "overrideConfigExclude"
      ]
      [
        "programs"
        "plasma"
        "resetFilesExclude"
      ]
    )
  ];

  config.home.activation = lib.mkIf plasmaCfg.enable {
    configure-plasma = (
      lib.hm.dag.entryAfter [ "writeBoundary" ] ''
        $DRY_RUN_CMD ${script}
      ''
    );
  };
}
</file>

<file path="modules/fonts.nix">
{ lib, config, ... }:
let
  inherit (lib) mkIf mkOption types;
  qfont = import ../lib/qfont.nix { inherit lib; };

  styleStrategyType = types.submodule {
    options = with qfont.styleStrategy; {
      prefer = mkOption {
        type = prefer;
        default = "default";
        description = ''
          Which type of font is preferred by the font when finding an appropriate default family.

          `default`, `bitmap`, `device`, `outline`, `forceOutline` correspond to the
          `PreferDefault`, `PreferBitmap`, `PreferDevice`, `PreferOutline`, `ForceOutline` enum flags
          respectively.
        '';
      };
      matchingPrefer = mkOption {
        type = matchingPrefer;
        default = "default";
        description = ''
          Whether the font matching process prefers exact matches, or best quality matches.

          `default` corresponds to not setting any enum flag, and `exact` and `quality`
          correspond to `PreferMatch` and `PreferQuality` enum flags respectively.
        '';
      };
      antialiasing = mkOption {
        type = antialiasing;
        default = "default";
        description = ''
          Whether antialiasing is preferred for this font.

          `default` corresponds to not setting any enum flag, and `prefer` and `disable`
          correspond to `PreferAntialias` and `NoAntialias` enum flags respectively.
        '';
      };
      noSubpixelAntialias = mkOption {
        type = types.bool;
        default = false;
        description = ''
          If set to `true`, this font will try to avoid subpixel antialiasing.

          Corresponds to the `NoSubpixelAntialias` enum flag.
        '';
      };
      noFontMerging = mkOption {
        type = types.bool;
        default = false;
        description = ''
          If set to `true`, this font will not try to find a substitute font when encountering missing glyphs.

          Corresponds to the `NoFontMerging` enum flag.
        '';
      };
      preferNoShaping = mkOption {
        type = types.bool;
        default = false;
        description = ''
          If set to true, this font will not try to apply shaping rules that may be required for some scripts
          (e.g. Indic scripts), increasing performance if these rules are not required.

          Corresponds to the `PreferNoShaping` enum flag.
        '';
      };
    };
  };

  fontType = types.submodule {
    options = {
      family = mkOption {
        type = types.str;
        description = "The font family of this font.";
        example = "Noto Sans";
      };
      pointSize = mkOption {
        type = types.nullOr types.numbers.positive;
        default = null;
        description = ''
          The point size of this font.

          Could be a decimal, but usually an integer. Mutually exclusive with pixel size.
        '';
      };
      pixelSize = mkOption {
        type = types.nullOr types.ints.u16;
        default = null;
        description = ''
          The pixel size of this font.

          Mutually exclusive with point size.
        '';
      };
      styleHint = mkOption {
        type = qfont.styleHint;
        default = "anyStyle";
        description = ''
          The style hint of this font.

          See https://doc.qt.io/qt-6/qfont.html#StyleHint-enum for more.
        '';
      };
      weight = mkOption {
        type = types.either (types.ints.between 1 1000) qfont.weight;
        default = "normal";
        description = ''
          The weight of the font, either as a number between 1 to 1000 or as a pre-defined weight string.

          See https://doc.qt.io/qt-6/qfont.html#Weight-enum for more.
        '';
      };
      style = mkOption {
        type = qfont.style;
        default = "normal";
        description = "The style of the font.";
      };
      underline = mkOption {
        type = types.bool;
        default = false;
        description = "Whether the font is underlined.";
      };
      strikeOut = mkOption {
        type = types.bool;
        default = false;
        description = "Whether the font is struck out.";
      };
      fixedPitch = mkOption {
        type = types.bool;
        default = false;
        description = "Whether the font has a fixed pitch.";
      };
      capitalization = mkOption {
        type = qfont.capitalization;
        default = "mixedCase";
        description = ''
          The capitalization settings for this font.

          See https://doc.qt.io/qt-6/qfont.html#Capitalization-enum for more.
        '';
      };
      letterSpacingType = mkOption {
        type = qfont.spacingType;
        default = "percentage";
        description = ''
          Whether to use percentage or absolute spacing for this font.

          See https://doc.qt.io/qt-6/qfont.html#SpacingType-enum for more.
        '';
      };
      letterSpacing = mkOption {
        type = types.number;
        default = 0;
        description = ''
          The amount of letter spacing for this font.

          Could be a percentage or an absolute spacing change (positive increases spacing, negative decreases spacing),
          based on the selected `letterSpacingType`.
        '';
      };
      wordSpacing = mkOption {
        type = types.number;
        default = 0;
        description = ''
          The amount of word spacing for this font, in pixels.

          Positive values increase spacing while negative ones decrease spacing.
        '';
      };
      stretch = mkOption {
        type = types.either (types.ints.between 1 4000) qfont.stretch;
        default = "anyStretch";
        description = ''
          The stretch factor for this font, as an integral percentage (i.e. 150 means a 150% stretch),
          or as a pre-defined stretch factor string.
        '';
      };
      styleStrategy = mkOption {
        type = styleStrategyType;
        default = { };
        description = ''
          The strategy for matching similar fonts to this font.

          See https://doc.qt.io/qt-6/qfont.html#StyleStrategy-enum for more.
        '';
      };
      styleName = mkOption {
        type = types.nullOr types.str;
        default = null;
        description = ''
          The style name of this font, overriding the `style` and `weight` parameters when set.
          Used for special fonts that have styles beyond traditional settings.
        '';
      };
    };
  };

  inherit (config.programs.plasma) enable;
  cfg = lib.filterAttrs (_: v: v != null) config.programs.plasma.fonts;
in
{
  options.programs.plasma.fonts = {
    general = mkOption {
      type = types.nullOr fontType;
      default = null;
      description = "The main font for the Plasma desktop.";
      example = lib.literalExpression ''
        {
          family = "Noto Sans";
          pointSize = 11;
        }
      '';
    };
    fixedWidth = mkOption {
      type = types.nullOr fontType;
      default = null;
      description = "The fixed width or monospace font for the Plasma desktop.";
      example = lib.literalExpression ''
        {
          family = "Iosevka";
          pointSize = 11;
        }
      '';
    };
    small = mkOption {
      type = types.nullOr fontType;
      default = null;
      description = "The font used for very small text.";
      example = lib.literalExpression ''
        {
          family = "Noto Sans";
          pointSize = 8;
        }
      '';
    };
    toolbar = mkOption {
      type = types.nullOr fontType;
      default = null;
      description = "The font used for toolbars.";
      example = lib.literalExpression ''
        {
          family = "Noto Sans";
          pointSize = 10;
        }
      '';
    };
    menu = mkOption {
      type = types.nullOr fontType;
      default = null;
      description = "The font used for menus.";
      example = lib.literalExpression ''
        {
          family = "Noto Sans";
          pointSize = 10;
        }
      '';
    };
    windowTitle = mkOption {
      type = types.nullOr fontType;
      default = null;
      description = "The font used for window titles.";
      example = lib.literalExpression ''
        {
          family = "Noto Sans";
          pointSize = 10;
        }
      '';
    };
  };

  config.programs.plasma.configFile.kdeglobals =
    let
      mkFont = f: mkIf (enable && builtins.hasAttr f cfg) (qfont.fontToString cfg.${f});
    in
    {
      General = {
        font = mkFont "general";
        fixed = mkFont "fixedWidth";
        smallestReadableFont = mkFont "small";
        toolBarFont = mkFont "toolbar";
        menuFont = mkFont "menu";
      };
      WM.activeFont = mkFont "windowTitle";
    };
}
</file>

<file path="modules/hotkeys.nix">
# Global hotkeys (user-defined keyboard shortcuts):
{
  pkgs,
  config,
  lib,
  ...
}:
let
  cfg = config.programs.plasma;

  commandString = command: (builtins.replaceStrings [ "%" ] [ "%%" ] command);

  group = rec {
    name = "plasma-manager-commands";
    desktop = "${name}.desktop";
    description = "Plasma Manager";
  };

  commandType =
    { name, ... }:
    {
      options = {
        name = lib.mkOption {
          type = lib.types.str;
          default = name;
          description = "Command hotkey name.";
        };

        comment = lib.mkOption {
          type = lib.types.str;
          default = name;
          description = "Optional comment to display in the System Settings app.";
        };

        key = lib.mkOption {
          type = lib.types.str;
          description = "The key combination that triggers the action.";
          default = "";
        };

        keys = lib.mkOption {
          type = with lib.types; listOf str;
          description = "The key combinations that trigger the action.";
          default = [ ];
        };

        command = lib.mkOption {
          type = lib.types.str;
          description = "The command to execute.";
        };

        logs = {
          enabled = lib.mkOption {
            type = lib.types.bool;
            default = true;
            description = "Connect the command's `stdin` and `stdout` to the systemd journal with `systemd-cat`.";
          };

          identifier = lib.mkOption {
            type = lib.types.str;
            default = lib.trivial.pipe name [
              lib.strings.toLower
              (builtins.replaceStrings [ " " ] [ "-" ])
              (n: "${group.name}-${n}")
            ];
            description = "Identifier passed down to `systemd-cat`.";
          };

          extraArgs = lib.mkOption {
            type = lib.types.str;
            default = "";
            description = "Additional arguments provided to `systemd-cat`.";
          };
        };
      };
    };
in
{
  options.programs.plasma.hotkeys = {
    commands = lib.mkOption {
      type = with lib.types; attrsOf (submodule commandType);
      default = { };
      description = "Commands triggered by a keyboard shortcut.";
    };
  };

  config = lib.mkIf (cfg.enable && builtins.length (builtins.attrNames cfg.hotkeys.commands) != 0) {
    xdg.desktopEntries."${group.name}" = {
      name = group.description;
      noDisplay = true;
      type = "Application";
      actions = lib.mapAttrs (_: command: {
        name = command.name;
        exec =
          if command.logs.enabled then
            "${pkgs.systemd}/bin/systemd-cat --identifier=${command.logs.identifier} ${command.logs.extraArgs} ${commandString command.command}"
          else
            (commandString command.command);
      }) cfg.hotkeys.commands;
    };

    programs.plasma.configFile."kglobalshortcutsrc"."${group.desktop}" =
      {
        _k_friendly_name = group.description;
      }
      // lib.mapAttrs (
        _: command:
        let
          keys = command.keys ++ lib.optionals (command.key != "") [ command.key ];
        in
        lib.concatStringsSep "," [
          (lib.concatStringsSep "\t" (map (lib.escape [ "," ]) keys))
          "" # List of default keys, not needed.
          command.comment
        ]
      ) cfg.hotkeys.commands;
  };
}
</file>

<file path="modules/input.nix">
{ config, lib, ... }:

let
  cfg = config.programs.plasma;
  numlockSettings = [
    "on"
    "off"
    "unchanged"
  ];
  switchModes = [
    "global"
    "desktop"
    "winClass"
    "window"
  ];

  scrollMethods = {
    twoFingers = 1;
    touchPadEdges = 2;
  };
  rightClickMethods = {
    bottomRight = 1;
    twoFingers = 2;
  };
  accelerationProfiles = {
    none = 1;
    default = 2;
  };

  capitalizeWord =
    word:
    let
      firstLetter = builtins.substring 0 1 word;
      rest = builtins.substring 1 (builtins.stringLength word - 1) word;
    in
    "${lib.toUpper firstLetter}${rest}";

  layoutType = lib.types.submodule {
    options = {
      layout = lib.mkOption {
        type = lib.types.str;
        example = "us";
        description = ''
          Keyboard layout.
        '';
      };
      variant = lib.mkOption {
        type = with lib.types; nullOr str;
        default = null;
        example = "eng";
        description = ''
          Keyboard layout variant.
          Examples: "mac", "dvorak", "workman-intl", and "colemak_dh_wide_iso"
        '';
        apply = builtins.toString;
      };
      displayName = lib.mkOption {
        type = with lib.types; nullOr str;
        default = null;
        example = "us";
        description = ''
          Keyboard layout display name.
        '';
        apply = builtins.toString;
      };
    };
  };

  touchPadType = lib.types.submodule {
    options = {
      enable = lib.mkOption {
        type = with lib.types; nullOr bool;
        default = null;
        example = true;
        description = ''
          Whether to enable the touchpad.
        '';
      };
      name = lib.mkOption {
        type = lib.types.str;
        default = null;
        example = "PNP0C50:00 0911:5288 Touchpad";
        description = ''
          The name of the touchpad.

          This can be found by looking at the `Name` attribute in the section in
          the `/proc/bus/input/devices` path belonging to the touchpad.
        '';
      };
      vendorId = lib.mkOption {
        type = lib.types.str;
        default = null;
        example = "0911";
        description = ''
          The vendor ID of the touchpad.

          This can be found by looking at the `Vendor` attribute in the section in
          the `/proc/bus/input/devices` path belonging to the touchpad.
        '';
      };
      productId = lib.mkOption {
        type = lib.types.str;
        default = null;
        example = "5288";
        description = ''
          The product ID of the touchpad.

          This can be found by looking at the `Product` attribute in the section in
          the `/proc/bus/input/devices` path belonging to the touchpad.
        '';
      };
      disableWhileTyping = lib.mkOption {
        type = with lib.types; nullOr bool;
        default = null;
        example = true;
        description = ''
          Whether to disable the touchpad while typing.
        '';
      };
      leftHanded = lib.mkOption {
        type = with lib.types; nullOr bool;
        default = null;
        example = false;
        description = ''
          Whether to swap the left and right buttons.
        '';
      };
      middleButtonEmulation = lib.mkOption {
        type = with lib.types; nullOr bool;
        default = null;
        example = false;
        description = ''
          Whether to enable middle mouse click emulation by pressing the left and right buttons at the same time.
          Activating this increases the click latency by 50ms.
        '';
      };
      pointerSpeed = lib.mkOption {
        type = with lib.types; nullOr (numbers.between (-1) 1);
        default = null;
        example = "0";
        description = ''
          How fast the pointer moves.
        '';
      };
      accelerationProfile = lib.mkOption {
        type = with lib.types; nullOr (enum (builtins.attrNames accelerationProfiles));
        default = null;
        example = "none";
        description = "Set the touchpad acceleration profile.";
        apply = profile: if (profile == null) then null else accelerationProfiles."${profile}";
      };
      naturalScroll = lib.mkOption {
        type = with lib.types; nullOr bool;
        default = null;
        example = true;
        description = ''
          Whether to enable natural scrolling for the touchpad.
        '';
      };
      tapToClick = lib.mkOption {
        type = with lib.types; nullOr bool;
        default = null;
        example = true;
        description = ''
          Whether to enable tap-to-click for the touchpad.
        '';
      };
      tapAndDrag = lib.mkOption {
        type = with lib.types; nullOr bool;
        default = null;
        example = true;
        description = ''
          Whether to enable tap-and-drag for the touchpad.
        '';
      };
      tapDragLock = lib.mkOption {
        type = with lib.types; nullOr bool;
        default = null;
        example = true;
        description = ''
          Whether to enable the tap-and-drag lock for the touchpad.
        '';
      };
      scrollMethod = lib.mkOption {
        type = with lib.types; nullOr (enum (builtins.attrNames scrollMethods));
        default = null;
        example = "touchPadEdges";
        description = ''
          Configure how scrolling is performed on the touchpad.
        '';
        apply = method: if (method == null) then null else scrollMethods."${method}";
      };
      scrollSpeed = lib.mkOption {
        type = with lib.types; nullOr (numbers.between 0.1 20);
        default = null;
        example = 0.1;
        description = ''
          Configure the scrolling speed of the touchpad. Lower is slower.
          If unset, KDE Plasma will default to 0.3.
        '';
      };
      rightClickMethod = lib.mkOption {
        type = with lib.types; nullOr (enum (builtins.attrNames rightClickMethods));
        default = null;
        example = "twoFingers";
        description = ''
          Configure how right-clicking is performed on the touchpad.
        '';
        apply = method: if (method == null) then null else rightClickMethods."${method}";
      };
      twoFingerTap = lib.mkOption {
        type =
          with lib.types;
          nullOr (enum [
            "rightClick"
            "middleClick"
          ]);
        default = null;
        example = "twoFingers";
        description = ''
          Configure what a two-finger tap maps to on the touchpad.
        '';
        apply = v: if (v == null) then null else (v == "middleClick");
      };
    };
  };
  touchPadToConfig =
    touchpad:
    let
      touchName = touchpad.name;
      touchVendor = builtins.toString (lib.fromHexString touchpad.vendorId);
      touchProduct = builtins.toString (lib.fromHexString touchpad.productId);
    in
    {
      "Libinput/${touchVendor}/${touchProduct}/${lib.escape [ "/" ] touchName}" = {
        Enabled = touchpad.enable;
        DisableWhileTyping = touchpad.disableWhileTyping;
        LeftHanded = touchpad.leftHanded;
        MiddleButtonEmulation = touchpad.middleButtonEmulation;
        PointerAcceleration = touchpad.pointerSpeed;
        PointerAccelerationProfile = touchpad.accelerationProfile;
        NaturalScroll = touchpad.naturalScroll;
        TapToClick = touchpad.tapToClick;
        TapAndDrag = touchpad.tapAndDrag;
        TapDragLock = touchpad.tapDragLock;
        ScrollMethod = touchpad.scrollMethod;
        ScrollFactor = touchpad.scrollSpeed;
        ClickMethod = touchpad.rightClickMethod;
        LmrTapButtonMap = touchpad.twoFingerTap;
      };
    };

  mouseType = lib.types.submodule {
    options = {
      enable = lib.mkOption {
        type = with lib.types; nullOr bool;
        default = null;
        example = true;
        description = ''
          Enables or disables the mouse.
        '';
      };
      name = lib.mkOption {
        type = lib.types.str;
        default = null;
        example = "Logitech G403 HERO Gaming Mouse";
        description = ''
          The name of the mouse.

          This can be found by looking at the `Name` attribute in the section in
          the `/proc/bus/input/devices` path belonging to the mouse.
        '';
      };
      vendorId = lib.mkOption {
        type = lib.types.str;
        default = null;
        example = "046d";
        description = ''
          The vendor ID of the mouse.

          This can be found by looking at the `Vendor` attribute in the section in
          the `/proc/bus/input/devices` path belonging to the mouse.
        '';
      };
      productId = lib.mkOption {
        type = lib.types.str;
        default = null;
        example = "c077";
        description = ''
          The product ID of the mouse.

          This can be found by looking at the `Product` attribute in the section in
          the `/proc/bus/input/devices` path belonging to the mouse.
        '';
      };
      leftHanded = lib.mkOption {
        type = with lib.types; nullOr bool;
        default = null;
        example = false;
        description = ''
          Whether to swap the left and right buttons.
        '';
      };
      middleButtonEmulation = lib.mkOption {
        type = with lib.types; nullOr bool;
        default = null;
        example = false;
        description = ''
          Whether to enable middle mouse click emulation by pressing the left and right buttons at the same time.
          Activating this increases the click latency by 50ms.
        '';
      };
      acceleration = lib.mkOption {
        type = with lib.types; nullOr (numbers.between (-1) 1);
        default = null;
        example = 0.5;
        description = ''
          Set the mouse acceleration.
        '';
      };
      accelerationProfile = lib.mkOption {
        type = with lib.types; nullOr (enum (builtins.attrNames accelerationProfiles));
        default = null;
        example = "none";
        description = "Set the mouse acceleration profile.";
        apply = profile: if (profile == null) then null else accelerationProfiles."${profile}";
      };
      naturalScroll = lib.mkOption {
        type = with lib.types; nullOr bool;
        default = null;
        example = true;
        description = ''
          Whether to enable natural scrolling for the mouse.
        '';
      };
      scrollSpeed = lib.mkOption {
        type = with lib.types; nullOr (numbers.between 0.1 20);
        default = null;
        example = 1;
        description = ''
          Configure how fast the scroll wheel moves.
        '';
      };
    };
  };

  mouseToConfig =
    mouse:
    let
      mouseName = mouse.name;
      mouseVendor = builtins.toString (lib.fromHexString mouse.vendorId);
      mouseProduct = builtins.toString (lib.fromHexString mouse.productId);
    in
    {
      "Libinput/${mouseVendor}/${mouseProduct}/${mouseName}" = {
        Enabled = mouse.enable;
        LeftHanded = mouse.leftHanded;
        MiddleButtonEmulation = mouse.middleButtonEmulation;
        NaturalScroll = mouse.naturalScroll;
        PointerAcceleration = mouse.acceleration;
        PointerAccelerationProfile = mouse.accelerationProfile;
        ScrollFactor = mouse.scrollSpeed;
      };
    };
in
{
  config.assertions = [
    (
      let
        validChars = [
          "0"
          "1"
          "2"
          "3"
          "4"
          "5"
          "6"
          "7"
          "8"
          "9"
          "a"
          "b"
          "c"
          "d"
          "e"
          "f"
        ];
        hexChars = hexStr: builtins.tail (lib.reverseList (builtins.tail (lib.splitString "" hexStr)));
        hexCodeInvalid =
          hex:
          !(lib.all (c: builtins.elem (lib.toLower c) validChars) (hexChars hex))
          && (builtins.stringLength hex) > 0;
        allHexCodes = lib.flatten (
          map (t: [
            t.vendorId
            t.productId
          ]) (cfg.input.touchpads ++ cfg.input.mice)
        );
        invalidHexCodes = builtins.filter hexCodeInvalid allHexCodes;
      in
      {
        assertion = (builtins.length invalidHexCodes) == 0;
        message = "Invalid hex-code for product or vendor-ID in the input module in plasma-manager: ${builtins.head invalidHexCodes}";
      }
    )
  ];
  # Keyboard options
  options.programs.plasma.input.keyboard = {
    model = lib.mkOption {
      type = with lib.types; nullOr str;
      default = null;
      example = "pc104";
      description = ''
        Keyboard model.
      '';
    };
    switchingPolicy = lib.mkOption {
      type = with lib.types; nullOr (enum switchModes);
      default = null;
      example = "global";
      description = ''
        Switching policy for keyboard layouts.
      '';
      apply = policy: if policy == null then null else capitalizeWord policy;
    };
    layouts = lib.mkOption {
      type = with lib.types; nullOr (listOf layoutType);
      default = null;
      example = [
        { layout = "us"; }
        {
          layout = "ca";
          variant = "eng";
        }
        {
          layout = "us";
          variant = "intl";
          displayName = "usi";
        }
      ];
      description = ''
        Keyboard layouts to use.
      '';
    };
    numlockOnStartup = lib.mkOption {
      type = with lib.types; nullOr (enum numlockSettings);
      default = null;
      example = "on";
      description = ''
        Numpad settings at startup.
      '';
    };
    repeatDelay = lib.mkOption {
      type = with lib.types; nullOr (ints.between 100 5000);
      default = null;
      example = 200;
      description = ''
        Configure how many milliseconds a key must be held down for before the input
        starts repeating.
      '';
    };
    repeatRate = lib.mkOption {
      type = with lib.types; nullOr (numbers.between 0.2 100.0);
      default = null;
      example = 50.0;
      description = ''
        Configure how quickly the inputs should be repeated when holding down a key.
      '';
    };
    options = lib.mkOption {
      type = with lib.types; nullOr (listOf str);
      default = null;
      example = [
        "altwin:meta_alt"
        "caps:shift"
        "custom:types"
      ];
      description = ''
        Keyboard options.
      '';
    };
  };

  config.programs.plasma.configFile."kxkbrc" = lib.mkIf (cfg.enable) (
    lib.mkMerge [
      (lib.mkIf (cfg.input.keyboard.layouts != null) {
        Layout = {
          Use.value = true;
          LayoutList.value = lib.concatStringsSep "," (map (l: l.layout) cfg.input.keyboard.layouts);
          VariantList.value = lib.concatStringsSep "," (map (l: l.variant) cfg.input.keyboard.layouts);
          DisplayNames.value = lib.concatStringsSep "," (map (l: l.displayName) cfg.input.keyboard.layouts);
        };
      })
      (lib.mkIf (cfg.input.keyboard.options != null) {
        Layout = {
          ResetOldOptions.value = true;
          Options.value = lib.concatStringsSep "," cfg.input.keyboard.options;
        };
      })
      (lib.mkIf (cfg.input.keyboard.model != null) {
        Layout = {
          Model.value = cfg.input.keyboard.model;
        };
      })
      (lib.mkIf (cfg.input.keyboard.switchingPolicy != null) {
        Layout = {
          SwitchMode.value = cfg.input.keyboard.switchingPolicy;
        };
      })
    ]
  );

  # Touchpads options
  options.programs.plasma.input.touchpads = lib.mkOption {
    type = with lib.types; listOf touchPadType;
    default = [ ];
    example = [
      {
        enable = true;
        name = "PNP0C50:00 0911:5288 Touchpad";
        vendorId = "2321";
        productId = "21128";
        disableWhileTyping = true;
        leftHanded = true;
        middleButtonEmulation = true;
        pointerSpeed = 0;
        naturalScroll = true;
        tapToClick = true;
      }
    ];
    description = ''
      Configure the different touchpads.
    '';
  };

  options.programs.plasma.input.mice = lib.mkOption {
    type = with lib.types; listOf mouseType;
    default = [ ];
    example = [
      {
        enable = true;
        name = "Logitech G403 HERO Gaming Mouse";
        vendorId = "046d";
        productId = "c08f";
        leftHanded = false;
        middleButtonEmulation = false;
        acceleration = 0.5;
        accelerationProfile = "none";
        naturalScroll = false;
        scrollSpeed = 1;
      }
    ];
    description = ''
      Configure the different mice.
    '';
  };

  config.programs.plasma.configFile."kcminputrc" = lib.mkIf (cfg.enable) (
    lib.mkMerge [
      {
        Keyboard = (
          lib.filterAttrs (k: v: v != null) {
            NumLock = (
              lib.lists.findFirstIndex (x: x == cfg.input.keyboard.numlockOnStartup) null numlockSettings
            );
            RepeatDelay = cfg.input.keyboard.repeatDelay;
            RepeatRate = cfg.input.keyboard.repeatRate;
          }
        );
      }
      (lib.mkMerge (map touchPadToConfig cfg.input.touchpads))
      (lib.mkMerge (map mouseToConfig cfg.input.mice))
    ]
  );
}
</file>

<file path="modules/krunner.nix">
{ config, lib, ... }:
let
  cfg = config.programs.plasma;
in
{
  options.programs.plasma.krunner = {
    position = lib.mkOption {
      type =
        with lib.types;
        nullOr (enum [
          "top"
          "center"
        ]);
      default = null;
      example = "center";
      description = "Set KRunner's position on the screen.";
    };
    activateWhenTypingOnDesktop = lib.mkOption {
      type = with lib.types; nullOr bool;
      default = null;
      example = true;
      description = "Whether to activate KRunner when typing on the desktop.";
    };
    historyBehavior = lib.mkOption {
      type =
        with lib.types;
        nullOr (enum [
          "disabled"
          "enableSuggestions"
          "enableAutoComplete"
        ]);
      default = null;
      example = "disabled";
      description = "Set the behavior of KRunners history.";
    };

    shortcuts = {
      launch = lib.mkOption {
        type = with lib.types; nullOr (either str (listOf str));
        default = null;
        example = "Meta";
        description = "Set the shortcut to launch KRunner.";
      };
      runCommandOnClipboard = lib.mkOption {
        type = with lib.types; nullOr (either str (listOf str));
        default = null;
        example = "Meta+Shift";
        description = "Set the shortcut to run the command on the clipboard contents.";
      };
    };
  };

  config.programs.plasma = {
    configFile.krunnerrc = lib.mkMerge [
      (lib.mkIf (cfg.krunner.position != null) {
        General.FreeFloating = cfg.krunner.position == "center";
      })
      (lib.mkIf (cfg.krunner.activateWhenTypingOnDesktop != null) {
        General.ActivateWhenTypingOnDesktop = cfg.krunner.activateWhenTypingOnDesktop;
      })
      (lib.mkIf (cfg.krunner.historyBehavior != null) {
        General.historyBehavior = (
          if cfg.krunner.historyBehavior == "enableSuggestions" then
            "CompletionSuggestion"
          else if cfg.krunner.historyBehavior == "enableAutoComplete" then
            "ImmediateCompletion"
          else
            "Disabled"
        );
      })
    ];

    shortcuts."services/org.kde.krunner.desktop" = lib.mkMerge [
      (lib.mkIf (cfg.krunner.shortcuts.launch != null) {
        _launch = cfg.krunner.shortcuts.launch;
      })

      (lib.mkIf (cfg.krunner.shortcuts.runCommandOnClipboard != null) {
        RunClipboard = cfg.krunner.shortcuts.runCommandOnClipboard;
      })
    ];
  };
}
</file>

<file path="modules/kscreenlocker.nix">
{ config, lib, ... }:
let
  cfg = config.programs.plasma;
  inherit (import ../lib/wallpapers.nix { inherit lib; })
    wallpaperPictureOfTheDayType
    wallpaperSlideShowType
    ;
in
{
  options.programs.plasma.kscreenlocker = {
    autoLock = lib.mkOption {
      type = with lib.types; nullOr bool;
      default = null;
      example = true;
      description = ''
        Whether the screen will be locked after the specified time.
      '';
    };
    lockOnResume = lib.mkOption {
      type = with lib.types; nullOr bool;
      default = null;
      example = false;
      description = ''
        Whether to lock the screen when the system resumes from sleep.
      '';
    };

    timeout = lib.mkOption {
      type = with lib.types; nullOr ints.unsigned;
      default = null;
      example = 5;
      description = ''
        Sets the timeout in minutes after which the screen will be locked.
      '';
    };

    passwordRequired = lib.mkOption {
      type = with lib.types; nullOr bool;
      default = null;
      example = true;
      description = ''
        Whether the user password is required to unlock the screen.
      '';
    };

    passwordRequiredDelay = lib.mkOption {
      type = with lib.types; nullOr ints.unsigned;
      default = null;
      example = 5;
      description = ''
        The time it takes in seconds for the password to be required after the screen is locked.
      '';
    };

    lockOnStartup = lib.mkOption {
      type = with lib.types; nullOr bool;
      default = null;
      example = false;
      description = ''
        Whether to lock the screen on startup.

        **Note:** This option is not provided in the System Settings app.
      '';
    };

    appearance = {
      alwaysShowClock = lib.mkOption {
        type = with lib.types; nullOr bool;
        default = null;
        example = false;
        description = ''
          Whether to always show the clock on the lockscreen, even if the unlock dialog is not shown.
        '';
      };
      showMediaControls = lib.mkOption {
        type = with lib.types; nullOr bool;
        default = null;
        example = false;
        description = ''
          Whether to show media controls on the lockscreen.
        '';
      };

      wallpaper = lib.mkOption {
        type = with lib.types; nullOr path;
        default = null;
        example = lib.literalExpression ''"''${pkgs.kdePackages.plasma-workspace-wallpapers}/share/wallpapers/Kay/contents/images/1080x1920.png"'';
        description = ''
          The wallpaper for the lockscreen. Can be either the path to an image file or a KPackage.
        '';
      };
      wallpaperPictureOfTheDay = lib.mkOption {
        type = lib.types.nullOr wallpaperPictureOfTheDayType;
        default = null;
        example = {
          provider = "apod";
        };
        description = ''
          Which plugin to fetch the Picture of the Day from.
        '';
      };
      wallpaperSlideShow = lib.mkOption {
        type = lib.types.nullOr wallpaperSlideShowType;
        default = null;
        example = lib.literalExpression ''{ path = "''${pkgs.kdePackages.plasma-workspace-wallpapers}/share/wallpapers/"; }'';
        description = ''
          Allows you to set the wallpaper using the slideshow plugin. Needs the path
          to at least one directory with wallpaper images.
        '';
      };
      wallpaperPlainColor = lib.mkOption {
        type = lib.types.nullOr lib.types.str;
        default = null;
        example = "0,64,174,256";
        description = ''
          Set the wallpaper using a plain color. Color is a comma-seperated R,G,B,A string. The alpha is optional (default is 256).
        '';
      };
    };
  };

  imports = [
    (lib.mkRenamedOptionModule
      [
        "programs"
        "plasma"
        "kscreenlocker"
        "wallpaper"
      ]
      [
        "programs"
        "plasma"
        "kscreenlocker"
        "appearance"
        "wallpaper"
      ]
    )
    (lib.mkRenamedOptionModule
      [
        "programs"
        "plasma"
        "kscreenlocker"
        "wallpaperPictureOfTheDay"
      ]
      [
        "programs"
        "plasma"
        "kscreenlocker"
        "appearance"
        "wallpaperPictureOfTheDay"
      ]
    )
    (lib.mkRenamedOptionModule
      [
        "programs"
        "plasma"
        "kscreenlocker"
        "wallpaperSlideShow"
      ]
      [
        "programs"
        "plasma"
        "kscreenlocker"
        "appearance"
        "wallpaperSlideShow"
      ]
    )
    (lib.mkRenamedOptionModule
      [
        "programs"
        "plasma"
        "kscreenlocker"
        "wallpaperPlainColor"
      ]
      [
        "programs"
        "plasma"
        "kscreenlocker"
        "appearance"
        "wallpaperPlainColor"
      ]
    )
  ];

  config = {
    assertions = [
      {
        assertion =
          let
            wallpapers = with cfg.kscreenlocker.appearance; [
              wallpaperSlideShow
              wallpaper
              wallpaperPictureOfTheDay
              wallpaperPlainColor
            ];
          in
          lib.count (x: x != null) wallpapers <= 1;
        message = "Can set only one of wallpaper, wallpaperSlideShow, wallpaperPictureOfTheDay, and wallpaperPlainColor for kscreenlocker.";
      }
    ];
    programs.plasma.configFile.kscreenlockerrc = (
      lib.mkMerge [
        (lib.mkIf (cfg.kscreenlocker.appearance.wallpaper != null) {
          Greeter.WallpaperPlugin = "org.kde.image";
          "Greeter/Wallpaper/org.kde.image/General".Image = (
            builtins.toString cfg.kscreenlocker.appearance.wallpaper
          );
        })
        (lib.mkIf (cfg.kscreenlocker.appearance.wallpaperPictureOfTheDay != null) {
          Greeter.WallpaperPlugin = "org.kde.potd";
          "Greeter/Wallpaper/org.kde.potd/General" = {
            Provider = cfg.kscreenlocker.appearance.wallpaperPictureOfTheDay.provider;
            UpdateOverMeteredConnection =
              with cfg.kscreenlocker.appearance.wallpaperPictureOfTheDay;
              (lib.mkIf (updateOverMeteredConnection != null) (if updateOverMeteredConnection then 1 else 0));
          };
        })
        (lib.mkIf (cfg.kscreenlocker.appearance.wallpaperSlideShow != null) {
          Greeter.WallpaperPlugin = "org.kde.slideshow";
          "Greeter/Wallpaper/org.kde.slideshow/General" = {
            SlidePaths =
              with cfg.kscreenlocker.appearance.wallpaperSlideShow;
              (
                if ((builtins.isPath path) || (builtins.isString path)) then
                  (builtins.toString cfg.kscreenlocker.appearance.wallpaperSlideShow.path)
                else
                  (builtins.concatStringsSep "," cfg.kscreenlocker.appearance.wallpaperSlideShow.path)
              );
            SlideInterval = cfg.kscreenlocker.appearance.wallpaperSlideShow.interval;
          };
        })
        (lib.mkIf (cfg.kscreenlocker.appearance.wallpaperPlainColor != null) {
          Greeter.WallpaperPlugin = "org.kde.color";
          "Greeter/Wallpaper/org.kde.color/General".Color = cfg.kscreenlocker.appearance.wallpaperPlainColor;
        })

        (lib.mkIf (cfg.kscreenlocker.appearance.alwaysShowClock != null) {
          "Greeter/LnF/General".alwaysShowClock = cfg.kscreenlocker.appearance.alwaysShowClock;
        })
        (lib.mkIf (cfg.kscreenlocker.appearance.showMediaControls != null) {
          "Greeter/LnF/General".showMediaControls = cfg.kscreenlocker.appearance.showMediaControls;
        })

        (lib.mkIf (cfg.kscreenlocker.autoLock != null) { Daemon.Autolock = cfg.kscreenlocker.autoLock; })

        (lib.mkIf (cfg.kscreenlocker.lockOnResume != null) {
          Daemon.LockOnResume = cfg.kscreenlocker.lockOnResume;
        })

        (lib.mkIf (cfg.kscreenlocker.timeout != null) { Daemon.Timeout = cfg.kscreenlocker.timeout; })

        (lib.mkIf (cfg.kscreenlocker.passwordRequiredDelay != null) {
          Daemon.LockGrace = cfg.kscreenlocker.passwordRequiredDelay;
        })

        (lib.mkIf (cfg.kscreenlocker.passwordRequired != null) {
          Daemon.RequirePassword = cfg.kscreenlocker.passwordRequired;
        })

        (lib.mkIf (cfg.kscreenlocker.lockOnStartup != null) {
          Daemon.LockOnStart = cfg.kscreenlocker.lockOnStartup;
        })
      ]
    );
  };
}
</file>

<file path="modules/kwin.nix">
{
  config,
  lib,
  pkgs,
  ...
}:

let
  cfg = config.programs.plasma;
  validTitlebarButtons = {
    longNames = [
      "more-window-actions"
      "application-menu"
      "on-all-desktops"
      "minimize"
      "maximize"
      "close"
      "help"
      "shade"
      "keep-below-windows"
      "keep-above-windows"
    ];
    shortNames = [
      "M"
      "N"
      "S"
      "I"
      "A"
      "X"
      "H"
      "L"
      "B"
      "F"
    ];
  };

  # Gets a list with long names and turns it into short names
  getShortNames =
    wantedButtons:
    lib.forEach (lib.flatten (
      lib.forEach wantedButtons (
        currentButton:
        lib.remove null (
          lib.imap0 (
            index: value: if value == currentButton then "${toString index}" else null
          ) validTitlebarButtons.longNames
        )
      )
    )) getShortNameFromIndex;

  # Gets the index and returns the short name in that position
  getShortNameFromIndex =
    position: builtins.elemAt validTitlebarButtons.shortNames (lib.toInt position);

  virtualDesktopNameAttrs =
    names:
    builtins.listToAttrs (lib.imap1 (i: v: (lib.nameValuePair "Name_${builtins.toString i}" v)) names);

  virtualDesktopIdAttrs =
    number:
    builtins.listToAttrs (
      map (i: (lib.nameValuePair "Id_${builtins.toString i}" "Desktop_${builtins.toString i}")) (
        lib.range 1 number
      )
    );

  capitalizeWord =
    word:
    let
      firstLetter = builtins.substring 0 1 word;
      rest = builtins.substring 1 (builtins.stringLength word - 1) word;
    in
    "${lib.toUpper firstLetter}${rest}";

  removeColon = string: builtins.replaceStrings [ ":" ] [ "" ] string;

  getIndexFromEnum =
    enum: value:
    if value == null then
      null
    else
      lib.lists.findFirstIndex (
        x: x == value
      ) (throw "getIndexFromEnum (kwin): Value ${value} isn't present in the enum. This is a bug.") enum;

  convertPoloniumFilter = list: if list == null then null else builtins.concatStringsSep ", " list;

  tilingLayoutType = lib.types.submodule {
    options = {
      id = lib.mkOption {
        type = lib.types.str;
        description = "The ID of the layout.";
        example = "cf5c25c2-4217-4193-add6-b5971cb543f2";
      };
      tiles = lib.mkOption {
        type = with lib.types; attrsOf anything;
        example = {
          layoutDirection = "horizontal";
          tiles = [
            { width = 0.5; }
            {
              layoutDirection = "vertical";
              tiles = [
                { height = 0.5; }
                { height = 0.5; }
              ];
              width = 0.5;
            }
          ];
        };
        apply = builtins.toJSON;
      };
    };
  };
in
{
  imports = [
    (lib.mkRenamedOptionModule
      [
        "programs"
        "plasma"
        "kwin"
        "virtualDesktops"
        "animation"
      ]
      [
        "programs"
        "plasma"
        "kwin"
        "effects"
        "desktopSwitching"
        "animation"
      ]
    )
  ];

  options.programs.plasma.kwin = {
    titlebarButtons.right = lib.mkOption {
      type = with lib.types; nullOr (listOf (enum validTitlebarButtons.longNames));
      default = null;
      example = [
        "help"
        "minimize"
        "maximize"
        "close"
      ];
      description = ''
        Title bar buttons to be placed on the right.
      '';
    };
    titlebarButtons.left = lib.mkOption {
      type = with lib.types; nullOr (listOf (enum validTitlebarButtons.longNames));
      default = null;
      example = [
        "on-all-desktops"
        "keep-above-windows"
      ];
      description = ''
        Title bar buttons to be placed on the left.
      '';
    };

    effects = {
      shakeCursor.enable = lib.mkOption {
        type = with lib.types; nullOr bool;
        default = null;
        description = "Enable the shake cursor effect.";
      };
      translucency.enable = lib.mkOption {
        type = with lib.types; nullOr bool;
        default = null;
        description = "Make windows translucent under certain conditions.";
      };
      minimization = {
        animation = lib.mkOption {
          type =
            with lib.types;
            nullOr (enum [
              "squash"
              "magiclamp"
              "off"
            ]);
          default = null;
          example = "magiclamp";
          description = "The effect to be displayed when windows are minimized.";
        };
        duration = lib.mkOption {
          type = with lib.types; nullOr ints.positive;
          default = null;
          example = 50;
          description = ''
            The duration of the minimization effect in milliseconds. Only
            available when the minimization effect is `magiclamp`.
          '';
        };
      };
      wobblyWindows.enable = lib.mkOption {
        type = with lib.types; nullOr bool;
        default = null;
        description = "Deform windows while they are moving.";
      };
      fps.enable = lib.mkOption {
        type = with lib.types; nullOr bool;
        default = null;
        description = "Display KWin's FPS performance graph in the corner of the screen.";
      };
      cube.enable = lib.mkOption {
        type = with lib.types; nullOr bool;
        default = null;
        description = "Arrange desktops in a virtual cube.";
      };
      desktopSwitching.animation = lib.mkOption {
        type =
          with lib.types;
          nullOr (enum [
            "fade"
            "slide"
            "off"
          ]);
        default = null;
        example = "fade";
        description = "The animation used when switching through virtual desktops.";
      };
      windowOpenClose = {
        animation = lib.mkOption {
          type =
            with lib.types;
            nullOr (enum [
              "fade"
              "glide"
              "scale"
              "off"
            ]);
          default = null;
          example = "glide";
          description = "The animation used when opening/closing windows.";
        };
      };
      fallApart.enable = lib.mkOption {
        type = with lib.types; nullOr bool;
        default = null;
        description = "Whether to make closed windows break into pieces.";
      };
      blur = {
        enable = lib.mkOption {
          type = with lib.types; nullOr bool;
          default = null;
          description = "Blurs the background behind semi-transparent windows.";
        };
        strength = lib.mkOption {
          type = with lib.types; nullOr (ints.between 1 15);
          default = null;
          example = 5;
          description = "Controls the intensity of the blur.";
        };
        noiseStrength = lib.mkOption {
          type = with lib.types; nullOr (ints.between 0 14);
          default = null;
          example = 8;
          description = "Adds noise to the blur effect.";
        };
      };
      snapHelper.enable = lib.mkOption {
        type = with lib.types; nullOr bool;
        default = null;
        description = "Helps locate the center of the screen when moving a window.";
      };
      dimInactive.enable = lib.mkOption {
        type = with lib.types; nullOr bool;
        default = null;
        description = "Darken inactive windows.";
      };
      dimAdminMode.enable = lib.mkOption {
        type = with lib.types; nullOr bool;
        default = null;
        description = "Darken the entire screen, except for the PolKit window, when requesting `root` privileges.";
      };
      slideBack.enable = lib.mkOption {
        type = with lib.types; nullOr bool;
        default = null;
        description = "Slide back windows when another window is raised.";
      };
    };

    virtualDesktops = {
      rows = lib.mkOption {
        type = with lib.types; nullOr ints.positive;
        default = null;
        example = 2;
        description = "The amount of rows for the virtual desktops.";
      };
      names = lib.mkOption {
        type = with lib.types; nullOr (listOf str);
        default = null;
        example = [
          "Desktop 1"
          "Desktop 2"
          "Desktop 3"
          "Desktop 4"
        ];
        description = ''
          The names of your virtual desktops. When set, the number of virtual
          desktops is automatically detected and doesn't need to be specified.
        '';
      };
      number = lib.mkOption {
        type = with lib.types; nullOr ints.positive;
        default = null;
        example = 8;
        description = ''
          The amount of virtual desktops. If the `names` attribute is set as
          well, then the number of desktops must be the same as the length of the
          `names` list.
        '';
      };
    };

    borderlessMaximizedWindows = lib.mkOption {
      type = with lib.types; nullOr bool;
      default = null;
      example = true;
      description = "Whether to remove the border of maximized windows.";
    };

    nightLight = {
      enable = lib.mkOption {
        type = with lib.types; nullOr bool;
        default = null;
        example = true;
        description = "Enable the night light effect.";
      };
      mode = lib.mkOption {
        type =
          with lib.types;
          nullOr (enum [
            "constant"
            "location"
            "times"
          ]);
        default = null;
        example = "times";
        description = ''
          When to enable the night light effect.

          - `constant` enables it unconditonally.
          - `location` uses coordinates to figure out the sunset/sunrise times for your location.
          - `times` allows you to set the times for enabling and disabling night light.
        '';
        apply = mode: if mode == null then null else capitalizeWord mode;
      };
      location = {
        latitude = lib.mkOption {
          type = with lib.types; nullOr str;
          default = null;
          example = "39.160305343511446";
          description = "The latitude of your location.";
        };
        longitude = lib.mkOption {
          type = with lib.types; nullOr str;
          default = null;
          example = "-35.86466165413535";
          description = "The longitude of your location.";
        };
      };
      temperature = {
        day = lib.mkOption {
          type = with lib.types; nullOr ints.positive;
          default = null;
          example = 4500;
          description = "The temperature of the screen during the day.";
        };
        night = lib.mkOption {
          type = with lib.types; nullOr ints.positive;
          default = null;
          example = 4500;
          description = "The temperature of the screen during the night.";
        };
      };
      time = {
        morning = lib.mkOption {
          type = with lib.types; nullOr str;
          default = null;
          example = "06:30";
          description = "The exact time when the morning light starts.";
          apply = time: if time == null then null else removeColon time;
        };
        evening = lib.mkOption {
          type = with lib.types; nullOr str;
          default = null;
          example = "19:30";
          description = "The exact time when the evening light starts.";
          apply = time: if time == null then null else removeColon time;
        };
      };
      transitionTime = lib.mkOption {
        type = with lib.types; nullOr ints.positive;
        default = null;
        example = 30;
        description = "The time in minutes it takes to transition from day to night.";
      };
    };

    edgeBarrier = lib.mkOption {
      type = with lib.types; nullOr (ints.between 0 1000);
      default = null;
      example = 50;
      description = ''
        Additional distance the cursor needs to travel to cross screen edges. To
        disable edge barriers, set this to `0`.
      '';
    };

    cornerBarrier = lib.mkOption {
      type = with lib.types; nullOr bool;
      default = null;
      example = false;
      description = "When enabled, prevents the cursor from crossing at screen-corners.";
    };

    tiling = {
      padding = lib.mkOption {
        type = with lib.types; nullOr (ints.between 0 36);
        default = null;
        example = 10;
        description = "The padding between windows in tiling.";
      };
      layout = lib.mkOption {
        type = with lib.types; nullOr tilingLayoutType;
        default = null;
        example = {
          id = "cf5c25c2-4217-4193-add6-b5971cb543f2";
          tiles = {
            layoutDirection = "horizontal";
            tiles = [
              { width = 0.5; }
              {
                layoutDirection = "vertical";
                tiles = [
                  { height = 0.5; }
                  { height = 0.5; }
                ];
                width = 0.5;
              }
            ];
          };
        };
      };
    };

    scripts = {
      polonium = {
        enable = lib.mkOption {
          type = with lib.types; nullOr bool;
          default = null;
          example = true;
          description = "Whether to enable Polonium.";
        };
        settings = {
          borderVisibility =
            let
              enumVals = [
                "noBorderAll"
                "noBorderTiled"
                "borderSelected"
                "borderAll"
              ];
            in
            lib.mkOption {
              type = with lib.types; nullOr (enum enumVals);
              default = null;
              example = "noBorderAll";
              description = "The border visibility setting for Polonium.";
              apply = getIndexFromEnum enumVals;
            };
          callbackDelay = lib.mkOption {
            type = with lib.types; nullOr (ints.between 1 200);
            default = null;
            example = 100;
            description = "The callback delay setting for Polonium.";
          };
          enableDebug = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
            example = true;
            description = "Whether to enable debug mode for Polonium.";
          };
          filter = {
            processes = lib.mkOption {
              type = with lib.types; nullOr (listOf str);
              default = null;
              example = [
                "firefox"
                "chromium"
              ];
              description = "The processes to filter for Polonium.";
              apply = convertPoloniumFilter;
            };
            windowTitles = lib.mkOption {
              type = with lib.types; nullOr (listOf str);
              default = null;
              example = [
                "Discord"
                "Telegram"
              ];
              description = "The window titles to filter for Polonium.";
              apply = convertPoloniumFilter;
            };
          };
          layout = {
            engine =
              let
                enumVals = [
                  "binaryTree"
                  "half"
                  "threeColumn"
                  "monocle"
                  "kwin"
                ];
              in
              lib.mkOption {
                type = with lib.types; nullOr (enum enumVals);
                default = null;
                example = "binaryTree";
                description = "The layout engine setting for Polonium.";
                apply = getIndexFromEnum enumVals;
              };
            insertionPoint =
              let
                enumVals = [
                  "left"
                  "right"
                  "activeWindow"
                ];
              in
              lib.mkOption {
                type = with lib.types; nullOr (enum enumVals);
                default = null;
                example = "top";
                description = "The insertion point setting for Polonium.";
                apply = getIndexFromEnum enumVals;
              };
            rotate = lib.mkOption {
              type = with lib.types; nullOr bool;
              default = null;
              example = true;
              description = "Whether to rotate the layout for Polonium.";
            };
          };
          maximizeSingleWindow = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
            example = true;
            description = "Whether to maximize a single window for Polonium.";
          };
          resizeAmount = lib.mkOption {
            type = with lib.types; nullOr (ints.between 1 450);
            default = null;
            example = 100;
            description = "The resize amount setting for Polonium.";
          };
          saveOnTileEdit = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
            example = true;
            description = "Whether to save on tile edit for Polonium.";
          };
          tilePopups = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
            example = true;
            description = "Whether to tile popups for Polonium.";
          };
        };
      };
    };
  };

  config = (
    lib.mkIf cfg.enable {
      assertions = [
        {
          assertion =
            cfg.kwin.virtualDesktops.number == null
            || cfg.kwin.virtualDesktops.names == null
            || cfg.kwin.virtualDesktops.number == (builtins.length cfg.kwin.virtualDesktops.names);
          message = "programs.plasma.virtualDesktops.number doesn't match the length of programs.plasma.virtualDesktops.names.";
        }
        {
          assertion =
            cfg.kwin.virtualDesktops.rows == null
            || (cfg.kwin.virtualDesktops.names == null && cfg.kwin.virtualDesktops.number == null)
            || (
              cfg.kwin.virtualDesktops.number != null
              && cfg.kwin.virtualDesktops.number >= cfg.kwin.virtualDesktops.rows
            )
            || (
              cfg.kwin.virtualDesktops.names != null
              && (builtins.length cfg.kwin.virtualDesktops.names) >= cfg.kwin.virtualDesktops.rows
            );
          message = "KWin cannot have more rows virtual desktops.";
        }
        {
          assertion =
            cfg.kwin.effects.minimization.duration == null
            || cfg.kwin.effects.minimization.animation == "magiclamp";
          message = "programs.plasma.kwin.effects.minimization.duration is only supported for the magic lamp effect";
        }
        {
          assertion =
            (cfg.kwin.nightLight.enable == null || cfg.kwin.nightLight.enable == false)
            || cfg.kwin.nightLight.mode != null;
          message = "programs.plasma.kwin.nightLight.mode must be set when programs.plasma.kwin.nightLight.enable is true.";
        }
        {
          assertion =
            cfg.kwin.nightLight.mode != "Times"
            || (cfg.kwin.nightLight.time.morning != null && cfg.kwin.nightLight.time.evening != null);
          message = "programs.plasma.kwin.nightLight.time.morning and programs.plasma.kwin.nightLight.time.evening must be set when programs.plasma.kwin.nightLight.mode is set to times.";
        }
        {
          assertion =
            cfg.kwin.nightLight.mode != "Location"
            || (
              cfg.kwin.nightLight.location.latitude != null && cfg.kwin.nightLight.location.longitude != null
            );
          message = "programs.plasma.kwin.nightLight.location.latitude and programs.plasma.kwin.nightLight.location.longitude must be set when programs.plasma.kwin.nightLight.mode is set to location.";
        }
        {
          assertion =
            cfg.kwin.nightLight.time.morning == null
            || builtins.stringLength cfg.kwin.nightLight.time.morning == 4;
          message = "programs.plasma.kwin.nightLight.time.morning must have the exact length of 4. If it doesn't have, it means that it doesn't have this time format: HH:MM";
        }
        {
          assertion =
            cfg.kwin.nightLight.time.evening == null
            || builtins.stringLength cfg.kwin.nightLight.time.evening == 4;
          message = "programs.plasma.kwin.nightLight.time.evening must have the exact length of 4. If it doesn't have, it means that it doesn't have this time format: HH:MM";
        }
      ];

      home.packages =
        with pkgs;
        [ ] ++ lib.optionals (cfg.kwin.scripts.polonium.enable == true) [ polonium ];

      programs.plasma.configFile."kwinrc" = (
        lib.mkMerge [
          # Titlebar buttons
          (lib.mkIf (cfg.kwin.titlebarButtons.left != null) {
            "org.kde.kdecoration2".ButtonsOnLeft = lib.concatStrings (
              getShortNames cfg.kwin.titlebarButtons.left
            );
          })
          (lib.mkIf (cfg.kwin.titlebarButtons.right != null) {
            "org.kde.kdecoration2".ButtonsOnRight = lib.concatStrings (
              getShortNames cfg.kwin.titlebarButtons.right
            );
          })

          # Effects
          (lib.mkIf (cfg.kwin.effects.shakeCursor.enable != null) {
            Plugins.shakecursorEnabled = cfg.kwin.effects.shakeCursor.enable;
          })
          (lib.mkIf (cfg.kwin.effects.minimization.animation != null) {
            Plugins = {
              magiclampEnabled = cfg.kwin.effects.minimization.animation == "magiclamp";
              squashEnabled = cfg.kwin.effects.minimization.animation == "squash";
            };
          })
          (lib.mkIf (cfg.kwin.effects.minimization.duration != null) {
            Effect-magiclamp.AnimationDuration = cfg.kwin.effects.minimization.duration;
          })
          (lib.mkIf (cfg.kwin.effects.wobblyWindows.enable != null) {
            Plugins.wobblywindowsEnabled = cfg.kwin.effects.wobblyWindows.enable;
          })
          (lib.mkIf (cfg.kwin.effects.translucency.enable != null) {
            Plugins.translucencyEnabled = cfg.kwin.effects.translucency.enable;
          })
          (lib.mkIf (cfg.kwin.effects.windowOpenClose.animation != null) {
            Plugins = {
              glideEnabled = cfg.kwin.effects.windowOpenClose.animation == "glide";
              fadeEnabled = cfg.kwin.effects.windowOpenClose.animation == "fade";
              scaleEnabled = cfg.kwin.effects.windowOpenClose.animation == "scale";
            };
          })
          (lib.mkIf (cfg.kwin.effects.fps.enable != null) {
            Plugins.showfpsEnabled = cfg.kwin.effects.fps.enable;
          })
          (lib.mkIf (cfg.kwin.effects.cube.enable != null) {
            Plugins.cubeEnabled = cfg.kwin.effects.cube.enable;
          })
          (lib.mkIf (cfg.kwin.effects.desktopSwitching.animation != null) {
            Plugins.slideEnabled = cfg.kwin.effects.desktopSwitching.animation == "slide";
            Plugins.fadedesktopEnabled = cfg.kwin.effects.desktopSwitching.animation == "fade";
          })
          (lib.mkIf (cfg.kwin.effects.fallApart.enable != null) {
            Plugins.fallapartEnabled = cfg.kwin.effects.fallApart.enable;
          })
          (lib.mkIf (cfg.kwin.effects.snapHelper.enable != null) {
            Plugins.snaphelperEnabled = cfg.kwin.effects.snapHelper.enable;
          })
          (lib.mkIf (cfg.kwin.effects.blur.enable != null) {
            Plugins.blurEnabled = cfg.kwin.effects.blur.enable;
            Effect-blur = {
              BlurStrength = cfg.kwin.effects.blur.strength;
              NoiseStrength = cfg.kwin.effects.blur.noiseStrength;
            };
          })
          (lib.mkIf (cfg.kwin.effects.dimInactive.enable != null) {
            Plugins.diminactiveEnabled = cfg.kwin.effects.dimInactive.enable;
          })
          (lib.mkIf (cfg.kwin.effects.dimAdminMode.enable != null) {
            Plugins.dimscreenEnabled = cfg.kwin.effects.dimAdminMode.enable;
          })
          (lib.mkIf (cfg.kwin.effects.slideBack.enable != null) {
            Plugins.slidebackEnabled = cfg.kwin.effects.slideBack.enable;
          })

          # Virtual Desktops
          (lib.mkIf (cfg.kwin.virtualDesktops.number != null) {
            Desktops = lib.mkMerge [
              { Number = cfg.kwin.virtualDesktops.number; }
              (virtualDesktopIdAttrs cfg.kwin.virtualDesktops.number)
            ];
          })
          (lib.mkIf (cfg.kwin.virtualDesktops.rows != null) {
            Desktops.Rows = cfg.kwin.virtualDesktops.rows;
          })
          (lib.mkIf (cfg.kwin.virtualDesktops.names != null) {
            Desktops = lib.mkMerge [
              { Number = builtins.length cfg.kwin.virtualDesktops.names; }
              (virtualDesktopIdAttrs (builtins.length cfg.kwin.virtualDesktops.names))
              (virtualDesktopNameAttrs cfg.kwin.virtualDesktops.names)
            ];
          })

          # Borderless maximized windows
          (lib.mkIf (cfg.kwin.borderlessMaximizedWindows != null) {
            Windows = {
              BorderlessMaximizedWindows = cfg.kwin.borderlessMaximizedWindows;
            };
          })

          # Night Light
          (lib.mkIf (cfg.kwin.nightLight.enable != null) {
            NightColor = {
              Active = cfg.kwin.nightLight.enable;
              DayTemperature = cfg.kwin.nightLight.temperature.day;
              EveningBeginFixed = cfg.kwin.nightLight.time.evening;
              LatitudeFixed = cfg.kwin.nightLight.location.latitude;
              LongitudeFixed = cfg.kwin.nightLight.location.longitude;
              Mode = cfg.kwin.nightLight.mode;
              MorningBeginFixed = cfg.kwin.nightLight.time.morning;
              NightTemperature = cfg.kwin.nightLight.temperature.night;
              TransitionTime = cfg.kwin.nightLight.transitionTime;
            };
          })

          (lib.mkIf (cfg.kwin.cornerBarrier != null) { EdgeBarrier.CornerBarrier = cfg.kwin.cornerBarrier; })
          (lib.mkIf (cfg.kwin.edgeBarrier != null) { EdgeBarrier.EdgeBarrier = cfg.kwin.edgeBarrier; })

          (lib.mkIf (cfg.kwin.scripts.polonium.enable != null) {
            Plugins.poloniumEnabled = cfg.kwin.scripts.polonium.enable;
            Script-polonium = {
              Borders = cfg.kwin.scripts.polonium.settings.borderVisibility;
              Debug = cfg.kwin.scripts.polonium.settings.enableDebug;
              EngineType = cfg.kwin.scripts.polonium.settings.layout.engine;
              FilterCaption = cfg.kwin.scripts.polonium.settings.filter.windowTitles;
              FilterProcess = cfg.kwin.scripts.polonium.settings.filter.processes;
              InsertionPoint = cfg.kwin.scripts.polonium.settings.layout.insertionPoint;
              MaximizeSingle = cfg.kwin.scripts.polonium.settings.maximizeSingleWindow;
              ResizeAmount = cfg.kwin.scripts.polonium.settings.resizeAmount;
              RotateLayout = cfg.kwin.scripts.polonium.settings.layout.rotate;
              SaveOnTileEdit = cfg.kwin.scripts.polonium.settings.saveOnTileEdit;
              TilePopups = cfg.kwin.scripts.polonium.settings.tilePopups;
              TimerDelay = cfg.kwin.scripts.polonium.settings.callbackDelay;
            };
          })

          (lib.mkIf (cfg.kwin.tiling.padding != null) {
            Tiling = {
              padding = cfg.kwin.tiling.padding;
            };
          })

          (lib.mkIf (cfg.kwin.tiling.layout != null) {
            "Tiling/${cfg.kwin.tiling.layout.id}" = {
              tiles = {
                escapeValue = false;
                value = cfg.kwin.tiling.layout.tiles;
              };
            };
          })
        ]
      );
    }
  );
}
</file>

<file path="modules/panels.nix">
{
  lib,
  config,
  pkgs,
  ...
}@args:
let
  cfg = config.programs.plasma;
  desktopWidgets = if cfg.desktop.widgets != null then cfg.desktop.widgets else [ ];
  hasWidget =
    widgetName:
    builtins.any (panel: builtins.any (widget: widget.name == widgetName) panel.widgets) cfg.panels
    || builtins.any (widget: widget.name == widgetName) desktopWidgets;

  # An attrset keeping track of the packages which should be added when a
  # widget is present in the config.
  additionalWidgetPackages = with pkgs; {
    "com.github.antroids.application-title-bar" = [ application-title-bar ];
    plasmusic-toolbar = [ plasmusic-toolbar ];
    "luisbocanegra.panel.colorizer" = [ plasma-panel-colorizer ];
    "org.kde.windowbuttons" = [ kdePackages.applet-window-buttons6 ];
    "org.dhruv8sh.kara" = [ kara ];
    "luisbocanegra.panelspacer.extended" = [ plasma-panel-spacer-extended ];
  };
  # An attrset of service-names and widgets/conditions. If any of the
  # conditions (given in cond) evaluate to true for any of the widgets with the
  # name given in the widget attribute, the service is marked for restart in
  # the panel-script.
  serviceRestarts = {
    "plasma-plasmashell" = [
      {
        widget = "org.kde.plasma.systemmonitor";
        cond =
          widget:
          (
            (builtins.hasAttr "org.kde.ksysguard.piechart/General" widget.config)
            && (builtins.hasAttr "showLegend" widget.config."org.kde.ksysguard.piechart/General")
          );
      }
    ];
  };
  widgetsOfName =
    name: (lib.filter (w: w.name == name) (lib.flatten (map (panel: panel.widgets) cfg.panels)));
  shouldRestart =
    service:
    (
      let
        candidates = serviceRestarts."${service}";
      in
      (builtins.any (x: x) (map (v: (builtins.any v.cond (widgetsOfName v.widget))) candidates))
    );

  widgets = import ./widgets args;

  panelType = lib.types.submodule (
    { config, ... }:
    {
      options = {
        height = lib.mkOption {
          type = lib.types.int;
          default = 44;
          description = "The height of the panel.";
        };
        offset = lib.mkOption {
          type = with lib.types; nullOr int;
          default = null;
          example = 100;
          description = "The offset of the panel from the anchor-point.";
        };
        minLength = lib.mkOption {
          type = with lib.types; nullOr int;
          default = null;
          example = 1000;
          description = "The minimum required length/width of the panel.";
        };
        maxLength = lib.mkOption {
          type = with lib.types; nullOr int;
          default = null;
          example = 1600;
          description = "The maximum allowed length/width of the panel.";
        };
        lengthMode = lib.mkOption {
          type =
            with lib.types;
            nullOr (enum [
              "fit"
              "fill"
              "custom"
            ]);
          default = if config.minLength != null || config.maxLength != null then "custom" else null;
          example = "fit";
          description = "The length mode of the panel. Defaults to `custom` if either `minLength` or `maxLength` is set.";
        };
        location = lib.mkOption {
          type =
            with lib.types;
            nullOr (enum [
              "top"
              "bottom"
              "left"
              "right"
              "floating"
            ]);
          default = "bottom";
          example = "left";
          description = "The location of the panel.";
        };
        alignment = lib.mkOption {
          type =
            with lib.types;
            nullOr (enum [
              "left"
              "center"
              "right"
            ]);
          default = "center";
          example = "right";
          description = "The alignment of the panel.";
        };
        hiding = lib.mkOption {
          type =
            with lib.types;
            nullOr (enum [
              "none"
              "autohide"
              # Plasma 5 only
              "windowscover"
              "windowsbelow"
              # Plasma 6 only
              "dodgewindows"
              "normalpanel"
              "windowsgobelow"
            ]);
          default = null;
          example = "autohide";
          description = ''
            The hiding mode of the panel. Here, `windowscover` and `windowsbelow` are
            Plasma 5-only, while `dodgewindows`, `windowsgobelow` and `normalpanel` are
            Plasma 6-only.
          '';
        };
        floating = lib.mkEnableOption "floating style.";
        widgets = lib.mkOption {
          type = lib.types.listOf widgets.type;
          default = [
            "org.kde.plasma.kickoff"
            "org.kde.plasma.pager"
            "org.kde.plasma.icontasks"
            "org.kde.plasma.marginsseparator"
            "org.kde.plasma.systemtray"
            "org.kde.plasma.digitalclock"
            "org.kde.plasma.showdesktop"
          ];
          example = [
            "org.kde.plasma.kickoff"
            "org.kde.plasma.icontasks"
            "org.kde.plasma.marginsseparator"
            "org.kde.plasma.digitalclock"
          ];
          description = ''
            The widgets to use in the panel. To get the names, it may be useful
            to look in the `share/plasma/plasmoids` subdirectory in the Nix Store path the
            widget/plasmoid is sourced from. Some packages which include some
            widgets/plasmoids are, for example, `plasma-desktop` and
            `plasma-workspace`.
          '';
          apply = map widgets.convert;
        };
        screen = lib.mkOption {
          type =
            with lib.types;
            nullOr (oneOf [
              ints.unsigned
              (listOf ints.unsigned)
              (enum [ "all" ])
            ]);
          default = null;
          description = ''
            The screen the panel should appear on. Can be an `int`, or a `list of ints`,
            starting from `0`, representing the ID of the screen the panel should
            appear on. Alternatively, it can be set to `all` if the panel should
            appear on all the screens.
          '';
        };
        opacity = lib.mkOption {
          type =
            with lib.types;
            nullOr (enum [
              "adaptive"
              "opaque"
              "translucent"
            ]);
          default = null;
          example = "opaque";
          description = ''
            The opacity mode of the panel.
          '';
        };
        extraSettings = lib.mkOption {
          type = with lib.types; nullOr str;
          default = null;
          description = ''
            Extra lines to add to the `layout.js`. See
            the [KDE Documentation](https://develop.kde.org/docs/plasma/scripting) for information.
          '';
        };
      };
    }
  );

  anyPanelSet = (builtins.length cfg.panels) > 0;
in
{
  imports = [
    (lib.mkRemovedOptionModule [
      "programs"
      "plasma"
      "extraWidgets"
    ] "Place the widget packages in home.packages or environment.systemPackages instead.")
  ];

  options.programs.plasma.panels = lib.mkOption {
    type = lib.types.listOf panelType;
    default = [ ];
  };

  config = (
    lib.mkIf cfg.enable {
      home.packages = (
        lib.flatten (
          lib.filter (x: x != null) (
            lib.mapAttrsToList (
              widgetName: packages: if (hasWidget widgetName) then packages else null
            ) additionalWidgetPackages
          )
        )
      );

      programs.plasma.startup.desktopScript."panels" = (
        lib.mkIf anyPanelSet (
          let
            anyNonDefaultScreens = ((builtins.any (panel: panel.screen != null)) cfg.panels);
            panelPreCMD = ''
              # We delete plasma-org.kde.plasma.desktop-appletsrc to hinder it
              # growing indefinitely. See:
              # https://github.com/nix-community/plasma-manager/issues/76
              [ -f ${config.xdg.configHome}/plasma-org.kde.plasma.desktop-appletsrc ] && rm ${config.xdg.configHome}/plasma-org.kde.plasma.desktop-appletsrc
            '';
            panelLayoutStr = (
              import ../lib/panel.nix {
                inherit lib;
                inherit config;
              }
            );
            panelPostCMD = (
              if anyNonDefaultScreens then
                ''
                  sed -i 's/^lastScreen\\x5b$i\\x5d=/lastScreen[$i]=/' ${config.xdg.configHome}/plasma-org.kde.plasma.desktop-appletsrc
                ''
              else
                ""
            );
          in
          {
            preCommands = panelPreCMD;
            text = panelLayoutStr;
            postCommands = panelPostCMD;
            restartServices = (
              lib.unique (if anyNonDefaultScreens then [ "plasma-plasmashell" ] else [ ])
              ++ (lib.filter (service: shouldRestart service) (builtins.attrNames serviceRestarts))
            );
            priority = 2;
          }
        )
      );
    }
  );
}
</file>

<file path="modules/powerdevil.nix">
{ config, lib, ... }:
let
  cfg = config.programs.plasma;

  # Values can be found at:
  # https://invent.kde.org/plasma/powerdevil/-/blob/v6.2.1/daemon/powerdevilenums.h
  powerButtonActions = {
    nothing = 0;
    sleep = 1;
    hibernate = 2;
    shutDown = 8;
    lockScreen = 32;
    showLogoutScreen = 16;
    turnOffScreen = 64;
  };

  autoSuspendActions = {
    nothing = 0;
    hibernate = 2;
    sleep = 1;
    shutDown = 8;
  };

  autoCriticalActions = {
    nothing = 0;
    hibernate = 2;
    sleep = 1;
    shutDown = 8;
  };

  whenSleepingEnterActions = {
    standby = 1;
    hybridSleep = 2;
    standbyThenHibernate = 3;
  };

  whenLaptopLidClosedActions = {
    doNothing = 0;
    sleep = 1;
    hibernate = 2;
    shutDown = 8;
    lockScreen = 32;
    turnOffScreen = 64;
  };

  # Since AC and battery allows the same options we create a function here which
  # can generate the options by just specifying the type (i.e. "AC" or
  # "battery").
  createPowerDevilOptions = type: {
    powerButtonAction = lib.mkOption {
      type = with lib.types; nullOr (enum (builtins.attrNames powerButtonActions));
      default = null;
      example = "nothing";
      description = ''
        The action, when on ${type}, to perform when the power button is pressed.
      '';
      apply = action: if (action == null) then null else powerButtonActions."${action}";
    };
    autoSuspend = {
      action = lib.mkOption {
        type = with lib.types; nullOr (enum (builtins.attrNames autoSuspendActions));
        default = null;
        example = "nothing";
        description = ''
          The action, when on ${type}, to perform after a certain period of inactivity.
        '';
        apply = action: if (action == null) then null else autoSuspendActions."${action}";
      };
      idleTimeout = lib.mkOption {
        type = with lib.types; nullOr (ints.between 60 600000);
        default = null;
        example = 600;
        description = ''
          The duration (in seconds), when on ${type}, the computer must be idle for
          until the auto-suspend action is executed.
        '';
      };
    };
    whenSleepingEnter = lib.mkOption {
      type = with lib.types; nullOr (enum (builtins.attrNames whenSleepingEnterActions));
      default = null;
      example = "standbyThenHibernate";
      description = ''
        The state, when on ${type}, to enter when sleeping.
      '';
      apply = action: if (action == null) then null else whenSleepingEnterActions."${action}";
    };
    whenLaptopLidClosed = lib.mkOption {
      type = with lib.types; nullOr (enum (builtins.attrNames whenLaptopLidClosedActions));
      default = null;
      example = "shutDown";
      description = ''
        The action, when on ${type}, to perform when the laptop lid is closed.
      '';
      apply = action: if (action == null) then null else whenLaptopLidClosedActions."${action}";
    };
    inhibitLidActionWhenExternalMonitorConnected = lib.mkOption {
      type = with lib.types; nullOr bool;
      default = null;
      example = true;
      description = ''
        If enabled, the lid action will be inhibited when an external monitor is connected.
      '';
    };
    turnOffDisplay = {
      idleTimeout = lib.mkOption {
        type = with lib.types; nullOr (either (enum [ "never" ]) (ints.between 30 600000));
        default = null;
        example = 300;
        description = ''
          The duration (in seconds), when on ${type}, the computer, when unlocked, must be idle for
          until the display turns off.
        '';
        apply =
          timeout:
          if (timeout == null) then
            null
          else if (timeout == "never") then
            -1
          else
            timeout;
      };
      idleTimeoutWhenLocked = lib.mkOption {
        type =
          with lib.types;
          nullOr (
            either (enum [
              "whenLockedAndUnlocked"
              "immediately"
            ]) (ints.between 20 600000)
          );
        default = null;
        example = 60;
        description = ''
          The duration (in seconds), when on ${type}, the computer must be idle
          (when locked) until the display turns off.
        '';
        apply =
          timeout:
          if (timeout == null) then
            null
          else if (timeout == "whenLockedAndUnlocked") then
            -2
          else if (timeout == "immediately") then
            0
          else
            timeout;
      };
    };
    dimDisplay = {
      enable = lib.mkOption {
        type = with lib.types; nullOr bool;
        default = null;
        example = false;
        description = "Whether to enable screen dimming.";
      };
      idleTimeout = lib.mkOption {
        type = with lib.types; nullOr (ints.between 20 600000);
        default = null;
        example = 300;
        description = ''
          The duration (in seconds), when on ${type}, the computer must be idle
          until the display starts dimming.
        '';
      };
    };
    displayBrightness = lib.mkOption {
      type = with lib.types; nullOr (ints.between 0 100);
      default = null;
      example = 10;
      description = ''
        The brightness to set the display to in this mode.
      '';
    };
    powerProfile = lib.mkOption {
      type =
        with lib.types;
        nullOr (enum [
          "performance"
          "balanced"
          "powerSaving"
        ]);
      default = null;
      example = "powerSaving";
      description = ''
        The Power Profile to enter in this mode.
      '';
      apply = profile: if profile == "powerSaving" then "power-saver" else profile;
    };
  };

  # By the same logic as createPowerDevilOptions, we can generate the
  # configuration. cfgSectName is here the name of the section in powerdevilrc,
  # while optionsName is the name of the "namespace" where we should draw the
  # options from (i.e. powerdevil.AC or powerdevil.battery).
  createPowerDevilConfig = cfgSectName: optionsName: {
    "${cfgSectName}/SuspendAndShutdown" = {
      PowerButtonAction = cfg.powerdevil.${optionsName}.powerButtonAction;
      AutoSuspendAction = cfg.powerdevil.${optionsName}.autoSuspend.action;
      AutoSuspendIdleTimeoutSec = cfg.powerdevil.${optionsName}.autoSuspend.idleTimeout;
      SleepMode = cfg.powerdevil.${optionsName}.whenSleepingEnter;
      LidAction = cfg.powerdevil.${optionsName}.whenLaptopLidClosed;
      InhibitLidActionWhenExternalMonitorPresent =
        cfg.powerdevil.${optionsName}.inhibitLidActionWhenExternalMonitorConnected;
    };
    "${cfgSectName}/Display" = {
      TurnOffDisplayIdleTimeoutSec = cfg.powerdevil.${optionsName}.turnOffDisplay.idleTimeout;
      TurnOffDisplayIdleTimeoutWhenLockedSec =
        cfg.powerdevil.${optionsName}.turnOffDisplay.idleTimeoutWhenLocked;
      DimDisplayWhenIdle =
        if (cfg.powerdevil.${optionsName}.dimDisplay.enable != null) then
          cfg.powerdevil.${optionsName}.dimDisplay.enable
        else if (cfg.powerdevil.${optionsName}.dimDisplay.idleTimeout != null) then
          true
        else
          null;
      DimDisplayIdleTimeoutSec =
        if (cfg.powerdevil.${optionsName}.dimDisplay.idleTimeout != null) then
          cfg.powerdevil.${optionsName}.dimDisplay.idleTimeout
        else if (cfg.powerdevil.${optionsName}.dimDisplay.enable == false) then
          -1
        else
          null;
      DisplayBrightness = cfg.powerdevil.${optionsName}.displayBrightness;
      UseProfileSpecificDisplayBrightness = (
        if (cfg.powerdevil.${optionsName}.displayBrightness == null) then null else true
      );
    };
    "${cfgSectName}/Performance" = {
      PowerProfile = cfg.powerdevil.${optionsName}.powerProfile;
    };
  };
in
{
  imports = [
    (lib.mkRenamedOptionModule
      [
        "programs"
        "plasma"
        "powerdevil"
        "powerButtonAction"
      ]
      [
        "programs"
        "plasma"
        "powerdevil"
        "AC"
        "powerButtonAction"
      ]
    )
    (lib.mkRenamedOptionModule
      [
        "programs"
        "plasma"
        "powerdevil"
        "autoSuspend"
      ]
      [
        "programs"
        "plasma"
        "powerdevil"
        "AC"
        "autoSuspend"
      ]
    )
    (lib.mkRenamedOptionModule
      [
        "programs"
        "plasma"
        "powerdevil"
        "turnOffDisplay"
      ]
      [
        "programs"
        "plasma"
        "powerdevil"
        "AC"
        "turnOffDisplay"
      ]
    )
  ];

  config.assertions =
    let
      createAssertions = type: [
        {
          assertion = (
            cfg.powerdevil.${type}.autoSuspend.action != autoSuspendActions.nothing
            || cfg.powerdevil.${type}.autoSuspend.idleTimeout == null
          );
          message = "Setting programs.plasma.powerdevil.${type}.autoSuspend.idleTimeout for autosuspend-action \"nothing\" is not supported.";
        }
        {
          assertion = (
            cfg.powerdevil.${type}.turnOffDisplay.idleTimeout != -1
            || cfg.powerdevil.${type}.turnOffDisplay.idleTimeoutWhenLocked == null
          );
          message = "Setting programs.plasma.powerdevil.${type}.turnOffDisplay.idleTimeoutWhenLocked for idleTimeout \"never\" is not supported.";
        }
        {
          assertion = (
            cfg.powerdevil.${type}.dimDisplay.enable != false
            || cfg.powerdevil.${type}.dimDisplay.idleTimeout == null
          );
          message = "Cannot set programs.plasma.powerdevil.${type}.dimDisplay.idleTimeout when programs.plasma.powerdevil.${type}.dimDisplay.enable is disabled.";
        }
      ];
    in
    (createAssertions "AC") ++ (createAssertions "battery") ++ (createAssertions "lowBattery");

  options = {
    programs.plasma.powerdevil = {
      AC = (createPowerDevilOptions "AC");
      battery = (createPowerDevilOptions "battery");
      lowBattery = (createPowerDevilOptions "lowBattery");
      general = {
        pausePlayersOnSuspend = lib.mkOption {
          type = with lib.types; nullOr bool;
          default = null;
          example = false;
          description = ''
            If enabled, pause media players when the system is suspended.
          '';
        };
      };
      batteryLevels = {
        lowLevel = lib.mkOption {
          type = with lib.types; nullOr (ints.between 0 100);
          default = null;
          example = 10;
          description = ''
            The battery level considered "low" for the laptop.
          '';
        };
        criticalLevel = lib.mkOption {
          type = with lib.types; nullOr (ints.between 0 100);
          default = null;
          example = 2;
          description = ''
            The battery level considered "critical" for the laptop.
          '';
        };
        criticalAction = lib.mkOption {
          type = with lib.types; nullOr (enum (builtins.attrNames autoCriticalActions));
          default = null;
          example = "shutDown";
          description = ''
            The action to perform when Critical Battery Level is reached.
          '';
          apply = action: if (action == null) then null else autoCriticalActions."${action}";
        };
      };
    };
  };

  config.programs.plasma.configFile = lib.mkIf cfg.enable {
    powerdevilrc = lib.filterAttrsRecursive (k: v: v != null) (
      (createPowerDevilConfig "AC" "AC")
      // (createPowerDevilConfig "Battery" "battery")
      // (createPowerDevilConfig "LowBattery" "lowBattery")
      // {
        General = {
          pausePlayersOnSuspend = cfg.powerdevil.general.pausePlayersOnSuspend;
        };
        BatteryManagement = {
          BatteryCriticalAction = cfg.powerdevil.batteryLevels.criticalAction;
          BatteryCriticalLevel = cfg.powerdevil.batteryLevels.criticalLevel;
          BatteryLowLevel = cfg.powerdevil.batteryLevels.lowLevel;
        };
      }
    );
  };
}
</file>

<file path="modules/session.nix">
{ config, lib, ... }:
let
  cfg = config.programs.plasma;
in
{
  options.programs.plasma.session = {
    general = {
      askForConfirmationOnLogout = lib.mkOption {
        type = with lib.types; nullOr bool;
        default = null;
        example = true;
        description = "Whether to ask for confirmation when shutting down, restarting or logging out";
      };
    };
    sessionRestore = {
      restoreOpenApplicationsOnLogin =
        let
          options = {
            onLastLogout = "restorePreviousLogout";
            whenSessionWasManuallySaved = "restoreSavedSession";
            startWithEmptySession = "emptySession";
          };
        in
        lib.mkOption {
          type = with lib.types; nullOr (enum (builtins.attrNames options));
          default = null;
          example = "startWithEmptySession";
          description = ''
            Controls how applications are restored on login:
            - "onLastLogout": Restores applications that were open during the last logout.
            - "whenSessionWasManuallySaved": Restores applications based on a manually saved session.
            - "startWithEmptySession": Starts with a clean, empty session each time.
          '';
          apply = option: if option == null then null else options.${option};
        };
      excludeApplications = lib.mkOption {
        type = with lib.types; nullOr (listOf str);
        default = null;
        example = [
          "firefox"
          "xterm"
        ];
        description = "List of applications to exclude from session restore";
        apply = apps: if apps == null then null else builtins.concatStringsSep "," apps;
      };
    };
  };

  config.programs.plasma.configFile."ksmserverrc".General = lib.mkMerge [
    (lib.mkIf (cfg.session.general.askForConfirmationOnLogout != null) {
      confirmLogout = cfg.session.general.askForConfirmationOnLogout;
    })
    (lib.mkIf (cfg.session.sessionRestore.excludeApplications != null) {
      excludeApps = cfg.session.sessionRestore.excludeApplications;
    })
    (lib.mkIf (cfg.session.sessionRestore.restoreOpenApplicationsOnLogin != null) {
      loginMode = cfg.session.sessionRestore.restoreOpenApplicationsOnLogin;
    })
  ];
}
</file>

<file path="modules/shortcuts.nix">
# Global keyboard shortcuts:
{ config, lib, ... }:

let
  cfg = config.programs.plasma;

  # Checks if the shortcut is in the "service" group, in which case we need to
  # write the values a little differently.
  isService =
    group:
    let
      startString = "services/";
    in
    (builtins.substring 0 (builtins.stringLength startString) group) == startString;

  # Convert one shortcut into a settings attribute set.
  shortcutToConfigValue =
    group: _action: skey:
    let
      # Keys are expected to be a list:
      keys =
        if builtins.isList skey then
          (if ((builtins.length skey) == 0) then [ "none" ] else skey)
        else
          [ skey ];

      # Don't allow un-escaped commas:
      escape = lib.escape [ "," ];
      keysStr = (
        if ((builtins.length keys) == 1) then
          (escape (builtins.head keys))
        else
          builtins.concatStringsSep "\t" (map escape keys)
      );
    in
    (
      if (isService group) then
        keysStr
      else
        (lib.concatStringsSep "," [
          keysStr
          "" # List of default keys, not needed.
          "" # Display string, not needed.
        ])
    );

  shortcutsToSettings =
    groups: lib.mapAttrs (group: attrs: (lib.mapAttrs (shortcutToConfigValue group) attrs)) groups;
in
{
  options.programs.plasma.shortcuts = lib.mkOption {
    type =
      with lib.types;
      attrsOf (
        attrsOf (oneOf [
          (listOf str)
          str
        ])
      );
    default = { };
    description = ''
      An attribute set where the keys are application groups and the
      values are shortcuts.
    '';
  };

  config = lib.mkIf cfg.enable {
    programs.plasma.configFile."kglobalshortcutsrc" = shortcutsToSettings cfg.shortcuts;
  };
}
</file>

<file path="modules/spectacle.nix">
{ config, lib, ... }:

let
  cfg = config.programs.plasma;
in
{
  options.programs.plasma.spectacle.shortcuts = {
    captureActiveWindow = lib.mkOption {
      type =
        with lib.types;
        nullOr (oneOf [
          (listOf str)
          str
        ]);
      default = null;
      example = "Meta+Print";
      description = ''
        The shortcut for capturing the active window.
      '';
    };

    captureCurrentMonitor = lib.mkOption {
      type =
        with lib.types;
        nullOr (oneOf [
          (listOf str)
          str
        ]);
      default = null;
      example = "Print";
      description = ''
        The shortcut for capturing the current monitor.
      '';
    };

    captureEntireDesktop = lib.mkOption {
      type =
        with lib.types;
        nullOr (oneOf [
          (listOf str)
          str
        ]);
      default = null;
      example = "Shift+Print";
      description = ''
        The shortcut for capturing the entire desktop.
      '';
    };

    captureRectangularRegion = lib.mkOption {
      type =
        with lib.types;
        nullOr (oneOf [
          (listOf str)
          str
        ]);
      default = null;
      example = "Meta+Shift+S";
      description = ''
        The shortcut for capturing a rectangular region.
      '';
    };

    captureWindowUnderCursor = lib.mkOption {
      type =
        with lib.types;
        nullOr (oneOf [
          (listOf str)
          str
        ]);
      default = null;
      example = "Meta+Ctrl+Print";
      description = ''
        The shortcut for capturing the window under the cursor.
      '';
    };

    launch = lib.mkOption {
      type =
        with lib.types;
        nullOr (oneOf [
          (listOf str)
          str
        ]);
      default = null;
      example = "Meta+S";
      description = ''
        The shortcut for launching Spectacle.
      '';
    };

    launchWithoutCapturing = lib.mkOption {
      type =
        with lib.types;
        nullOr (oneOf [
          (listOf str)
          str
        ]);
      default = null;
      example = "Meta+Alt+S";
      description = ''
        The shortcut for launching Spectacle without capturing.
      '';
    };

    recordRegion = lib.mkOption {
      type =
        with lib.types;
        nullOr (oneOf [
          (listOf str)
          str
        ]);
      default = null;
      example = "Meta+Shift+R";
      description = ''
        The shortcut for recording a region on the screen.
      '';
    };

    recordScreen = lib.mkOption {
      type =
        with lib.types;
        nullOr (oneOf [
          (listOf str)
          str
        ]);
      default = null;
      example = "Meta+Alt+R";
      description = ''
        The shortcut for selecting a screen to record.
      '';
    };

    recordWindow = lib.mkOption {
      type =
        with lib.types;
        nullOr (oneOf [
          (listOf str)
          str
        ]);
      default = null;
      example = "Meta+Ctrl+R";
      description = ''
        The shortcut for selecting a window to record.
      '';
    };
  };

  config = lib.mkIf cfg.enable {
    programs.plasma.shortcuts."services/org.kde.spectacle.desktop" = lib.mkMerge [
      (lib.mkIf (cfg.spectacle.shortcuts.captureActiveWindow != null) {
        ActiveWindowScreenShot = cfg.spectacle.shortcuts.captureActiveWindow;
      })
      (lib.mkIf (cfg.spectacle.shortcuts.captureCurrentMonitor != null) {
        CurrentMonitorScreenShot = cfg.spectacle.shortcuts.captureCurrentMonitor;
      })
      (lib.mkIf (cfg.spectacle.shortcuts.captureEntireDesktop != null) {
        FullScreenScreenShot = cfg.spectacle.shortcuts.captureEntireDesktop;
      })
      (lib.mkIf (cfg.spectacle.shortcuts.captureRectangularRegion != null) {
        RectangularRegionScreenShot = cfg.spectacle.shortcuts.captureRectangularRegion;
      })
      (lib.mkIf (cfg.spectacle.shortcuts.captureWindowUnderCursor != null) {
        WindowUnderCursorScreenShot = cfg.spectacle.shortcuts.captureWindowUnderCursor;
      })
      (lib.mkIf (cfg.spectacle.shortcuts.launch != null) { _launch = cfg.spectacle.shortcuts.launch; })
      (lib.mkIf (cfg.spectacle.shortcuts.launchWithoutCapturing != null) {
        OpenWithoutScreenshot = cfg.spectacle.shortcuts.launchWithoutCapturing;
      })
      (lib.mkIf (cfg.spectacle.shortcuts.recordRegion != null) {
        RecordRegion = cfg.spectacle.shortcuts.recordRegion;
      })
      (lib.mkIf (cfg.spectacle.shortcuts.recordScreen != null) {
        RecordScreen = cfg.spectacle.shortcuts.recordScreen;
      })
      (lib.mkIf (cfg.spectacle.shortcuts.recordWindow != null) {
        RecordWindow = cfg.spectacle.shortcuts.recordWindow;
      })
    ];
  };
}
</file>

<file path="modules/startup.nix">
# Allows to run commands/scripts at startup (this is used by some of the other
# modules, which may need to do this, but can also be used on its own)
{ config, lib, ... }:
let
  cfg = config.programs.plasma;
  topScriptName = "run_all.sh";

  textOption = lib.mkOption {
    type = lib.types.str;
    description = "The content of the startup script.";
  };
  priorityOption = lib.mkOption {
    type = (lib.types.ints.between 0 8);
    default = 0;
    description = "The priority for the execution of the script. Lower priority means earlier execution.";
  };
  restartServicesOption = lib.mkOption {
    type = with lib.types; listOf str;
    default = [ ];
    description = "Services to restart after the script has been run.";
  };
  runAlwaysOption = lib.mkOption {
    type = lib.types.bool;
    default = false;
    example = true;
    description = ''
      When enabled the script will run even if no changes have been made
      since last successful run.
    '';
  };

  startupScriptType = lib.types.submodule {
    options = {
      text = textOption;
      priority = priorityOption;
      restartServices = restartServicesOption;
      runAlways = runAlwaysOption;
    };
  };
  desktopScriptType = lib.types.submodule {
    options = {
      text = textOption;
      priority = priorityOption;
      restartServices = restartServicesOption;
      runAlways = runAlwaysOption;
      preCommands = lib.mkOption {
        type = lib.types.str;
        description = "Commands to run before the desktop script lines.";
        default = "";
      };
      postCommands = lib.mkOption {
        type = lib.types.str;
        description = "Commands to run after the desktop script lines.";
        default = "";
      };
    };
  };

  createScriptContentRunOnce = name: sha256sumFile: script: text: ''
    last_update="$(sha256sum ${sha256sumFile})"
    last_update_file=${config.xdg.dataHome}/plasma-manager/last_run_${name}
    if [ -f "$last_update_file" ]; then
      stored_last_update=$(cat "$last_update_file")
    fi

    if ! [ "$last_update" = "$stored_last_update" ]; then
      echo "Running script: ${name}"
      success=1
      trap 'success=0' ERR
      ${text}
      if [ $success -eq 1 ]; then
        echo "$last_update" > "$last_update_file"
        ${
          builtins.concatStringsSep "\n" (
            map (
              s: "echo ${s} >> ${config.xdg.dataHome}/plasma-manager/services_to_restart"
            ) script.restartServices
          )
        }
      fi
    fi
  '';

  createScriptContentRunAlways = name: text: ''
    echo "Running script: ${name}"
    ${text}
  '';

  createScriptContent = name: sha256sumFile: script: text: {
    "plasma-manager/${cfg.startup.scriptsDir}/${builtins.toString script.priority}_${name}.sh" = {
      text = ''
        #!/bin/sh
        ${
          if script.runAlways then
            (createScriptContentRunAlways name text)
          else
            (createScriptContentRunOnce name sha256sumFile script text)
        }
      '';
      executable = true;
    };
  };
in
{
  options.programs.plasma.startup = {
    startupScript = lib.mkOption {
      type = lib.types.attrsOf startupScriptType;
      default = { };
      description = "Commands/scripts to be run at startup.";
    };
    desktopScript = lib.mkOption {
      type = lib.types.attrsOf desktopScriptType;
      default = { };
      description = ''
        Plasma desktop scripts to be run exactly once at startup. See
        the [KDE Documentation](https://develop.kde.org/docs/plasma/scripting) for details on Plasma
        desktop scripts.
      '';
    };
    dataFile = lib.mkOption {
      type = with lib.types; attrsOf str;
      default = { };
      description = "Datafiles, typically for use in autostart scripts.";
    };
    scriptsDir = lib.mkOption {
      type = lib.types.str;
      default = "scripts";
      description = "The name of the subdirectory where the scripts should be.";
    };
    dataDir = lib.mkOption {
      type = lib.types.str;
      default = "data";
      description = "The name of the subdirectory where the datafiles should be.";
    };
  };

  config.xdg =
    lib.mkIf
      (
        cfg.enable
        && (
          builtins.length (builtins.attrNames cfg.startup.startupScript) != 0
          || (builtins.length (builtins.attrNames cfg.startup.desktopScript)) != 0
        )
      )
      {
        dataFile = lib.mkMerge [
          # Autostart scripts
          (lib.mkMerge (
            lib.mapAttrsToList (
              name: script: createScriptContent "script_${name}" "$0" script script.text
            ) cfg.startup.startupScript
          ))
          # Desktop scripts
          (lib.mkMerge (
            (lib.mapAttrsToList (
              name: script:
              let
                layoutScriptPath = "${config.xdg.dataHome}/plasma-manager/${cfg.startup.dataDir}/desktop_script_${name}.js";
              in
              createScriptContent "desktop_script_${name}" layoutScriptPath script ''
                ${script.preCommands}
                qdbus org.kde.plasmashell /PlasmaShell org.kde.PlasmaShell.evaluateScript "$(cat ${layoutScriptPath})"
                ${script.postCommands}
              ''
            ) cfg.startup.desktopScript)
            ++ (lib.mapAttrsToList (name: content: {
              "plasma-manager/${cfg.startup.dataDir}/desktop_script_${name}.js" = {
                text = content.text;
              };
            }) cfg.startup.desktopScript)
          ))
          # Datafiles
          (lib.mkMerge (
            lib.mapAttrsToList (name: content: {
              "plasma-manager/${cfg.startup.dataDir}/${name}" = {
                text = content;
              };
            }) cfg.startup.dataFile
          ))
          # Autostart script runner
          {
            "plasma-manager/${topScriptName}" = {
              text = ''
                #!/bin/sh

                services_restart_file="${config.xdg.dataHome}/plasma-manager/services_to_restart"

                # Reset the file keeping track of which scripts to restart.
                # Technically can be put at the end as well (maybe better, at
                # least assuming the file hasn't been tampered with of some sort).
                if [ -f $services_restart_file ]; then rm $services_restart_file; fi

                for script in ${config.xdg.dataHome}/plasma-manager/${cfg.startup.scriptsDir}/*.sh; do
                  [ -x "$script" ] && $script
                done

                # Restart the services
                if [ -f $services_restart_file ]; then
                  for service in $(sort $services_restart_file | uniq); do
                    systemctl --user restart $service
                  done
                fi
              '';
              executable = true;
            };
          }
        ];

        configFile."autostart/plasma-manager-autostart.desktop".text = ''
          [Desktop Entry]
          Type=Application
          Name=Plasma Manager theme application
          Exec=${config.xdg.dataHome}/plasma-manager/${topScriptName}
          X-KDE-autostart-condition=ksmserver
        '';
      };

  # Due to the fact that running certain desktop-scripts can reset what has
  # been applied by other desktop-script (for example running the panel
  # desktop-script will reset the wallpaper), we make it so that if any of the
  # desktop-scripts have been modified, that we must re-run all the
  # desktop-scripts, not just the ones who have been changed.
  config.programs.plasma.startup.startupScript."reset_lastrun_desktopscripts" =
    lib.mkIf (cfg.startup.desktopScript != { })
      {
        text = ''
          should_reset=0
          for ds in ${config.xdg.dataHome}/plasma-manager/data/desktop_script_*.js; do
            ds_name="$(basename $ds)"
            ds_name="''${ds_name%.js}"
            ds_shafile="${config.xdg.dataHome}/plasma-manager/last_run_"$ds_name

            if ! [ -f "$ds_shafile" ]; then
              echo "Resetting desktop-script last_run-files since $ds_name is a new desktop-script"
              should_reset=1
            elif ! [ "$(cat $ds_shafile)" = "$(sha256sum $ds)" ]; then
              echo "Resetting desktop-script last_run-files since $ds_name has changed content"
              should_reset=1
            fi
          done

          [ $should_reset = 1 ] && rm ${config.xdg.dataHome}/plasma-manager/last_run_desktop_script_*
        '';
        runAlways = true;
      };
}
</file>

<file path="modules/window-rules.nix">
{ lib, config, ... }:
with lib.types;
let
  inherit (builtins)
    length
    listToAttrs
    foldl'
    toString
    attrNames
    getAttr
    concatStringsSep
    add
    isAttrs
    ;
  inherit (lib) mkOption mkIf;
  inherit (lib.trivial) mergeAttrs;
  inherit (lib.lists) imap0;
  inherit (lib.attrsets) optionalAttrs filterAttrs mapAttrsToList;
  cfg = config.programs.plasma;
  applyRules = {
    "do-not-affect" = 1;
    "force" = 2;
    "initially" = 3;
    "remember" = 4;
  };
  matchRules = {
    "exact" = 1;
    "substring" = 2;
    "regex" = 3;
  };
  windowTypes = {
    normal = 1;
    desktop = 2;
    dock = 4;
    toolbar = 8;
    torn-of-menu = 16;
    dialog = 32;
    menubar = 128;
    utility = 256;
    spash = 512;
    osd = 65536;
  };
  matchNameMap = {
    "window-class" = "wmclass";
    "window-types" = "types";
    "window-role" = "windowrole";
  };
  matchOptionType =
    hasMatchWhole:
    submodule {
      options =
        {
          value = mkOption {
            type = str;
            description = "Name to match.";
          };
          type = mkOption {
            type = enum (attrNames matchRules);
            default = "exact";
            description = "Name match type.";
          };
        }
        // optionalAttrs hasMatchWhole {
          match-whole = mkOption {
            type = bool;
            default = true;
            description = "Match whole name.";
          };
        };
    };
  basicValueType = oneOf [
    bool
    float
    int
    str
  ];
  applyOptionType = submodule {
    options = {
      value = mkOption {
        type = basicValueType;
        description = "Value to set.";
      };
      apply = mkOption {
        type = enum (attrNames applyRules);
        default = "initially";
        description = "How to apply the value.";
      };
    };
  };
  mkMatchOption =
    name: hasMatchWhole:
    mkOption {
      type = nullOr (coercedTo str (value: { inherit value; }) (matchOptionType hasMatchWhole));
      default = null;
      description = "${name} matching.";
    };
  fixMatchName = name: matchNameMap.${name} or name;
  buildMatchRule =
    name: rule:
    (
      {
        "${fixMatchName name}" = rule.value;
        "${fixMatchName name}match" = getAttr rule.type matchRules;
      }
      // optionalAttrs (rule ? match-whole) { "${fixMatchName name}complete" = rule.match-whole; }
    );
  buildApplyRule = name: rule: {
    "${name}" = rule.value;
    "${name}rule" = getAttr rule.apply applyRules;
  };
  buildWindowRule =
    rule:
    let
      matchOptions = filterAttrs (_name: isAttrs) rule.match;
      matchRules = mapAttrsToList buildMatchRule matchOptions;
      applyRules = mapAttrsToList buildApplyRule rule.apply;
      combinedRules = foldl' mergeAttrs { } (matchRules ++ applyRules);
    in
    {
      Description = rule.description;
    }
    // optionalAttrs (rule.match.window-types != 0) { types = rule.match.window-types; }
    // combinedRules;
  windowRules = listToAttrs (
    imap0 (i: rule: {
      name = toString (i + 1);
      value = buildWindowRule rule;
    }) cfg.window-rules
  );
in
{
  options.programs.plasma = {
    window-rules = mkOption {
      type = listOf (submodule {
        options = {
          match = mkOption {
            type = submodule {
              options = {
                window-class = mkMatchOption "Window class" true;
                window-role = mkMatchOption "Window role" false;
                title = mkMatchOption "Title" false;
                machine = mkMatchOption "clientmachine" false;
                window-types = mkOption {
                  type = listOf (enum (attrNames windowTypes));
                  default = [ ];
                  description = "Window types to match.";
                  apply = values: foldl' add 0 (map (val: getAttr val windowTypes) values);
                };
              };
            };
          };
          apply = mkOption {
            type = attrsOf (coercedTo basicValueType (value: { inherit value; }) applyOptionType);
            default = { };
            description = "Values to apply.";
          };
          description = mkOption {
            type = str;
            description = "Value to set.";
          };
        };
      });
      description = "KWin window rules.";
      default = [ ];
    };
  };

  config = mkIf (length cfg.window-rules > 0) {
    programs.plasma.configFile = {
      kwinrulesrc = {
        General = {
          count = length cfg.window-rules;
          rules = concatStringsSep "," (attrNames windowRules);
        };
      } // windowRules;
    };
  };
}
</file>

<file path="modules/windows.nix">
# Window configuration:
{ config, lib, ... }:

let
  cfg = config.programs.plasma;
in
{
  options.programs.plasma.windows = {
    allowWindowsToRememberPositions = lib.mkOption {
      type = with lib.types; nullOr bool;
      default = null;
      description = ''
        Allow apps to remember the positions of their own windows, if
        they support it.
      '';
    };
  };

  config = (
    lib.mkIf (cfg.enable && cfg.windows.allowWindowsToRememberPositions != null) {
      programs.plasma.configFile = {
        kdeglobals = {
          General.AllowKDEAppsToRememberWindowPositions = cfg.windows.allowWindowsToRememberPositions;
        };
      };
    }
  );
}
</file>

<file path="modules/workspace.nix">
# General workspace behavior settings:
{
  config,
  lib,
  pkgs,
  ...
}:

let
  cfg = config.programs.plasma;

  inherit (import ../lib/wallpapers.nix { inherit lib; })
    wallpaperPictureOfTheDayType
    wallpaperSlideShowType
    wallpaperFillModeTypes
    ;

  cursorType =
    with lib.types;
    submodule {
      options = {
        theme = lib.mkOption {
          type = nullOr str;
          default = null;
          example = "Breeze_Snow";
          description = "The Plasma cursor theme. Run `plasma-apply-cursortheme --list-themes` for valid options.";
        };
        size = lib.mkOption {
          type = nullOr ints.positive;
          default = null;
          example = 24;
          description = "The size of the cursor. See the System Settings app for allowed sizes for each cursor theme.";
        };
      };
    };

  wallpaperBackgroundType = lib.types.submodule {
    options = {
      color = lib.mkOption {
        type = with lib.types; nullOr str;
        default = null;
        example = "219,99,99";
        description = "Background color to use";
      };
      blur = lib.mkOption {
        type = with lib.types; nullOr bool;
        default = null;
        example = true;
        description = "Whether to blur the background";
      };
    };
  };

  anyThemeSet = (
    cfg.workspace.theme != null
    || cfg.workspace.colorScheme != null
    || (cfg.workspace.cursor != null && cfg.workspace.cursor.theme != null)
    || cfg.workspace.lookAndFeel != null
    || cfg.workspace.iconTheme != null
  );

  splashScreenEngineDetect = theme: (if (theme == "None") then "none" else "KSplashQML");
in
{
  imports = [
    (lib.mkRenamedOptionModule
      [
        "programs"
        "plasma"
        "workspace"
        "cursorTheme"
      ]
      [
        "programs"
        "plasma"
        "workspace"
        "cursor"
        "theme"
      ]
    )
  ];

  options.programs.plasma.workspace = {
    clickItemTo = lib.mkOption {
      type =
        with lib.types;
        nullOr (enum [
          "open"
          "select"
        ]);
      default = null;
      description = ''
        Whether clicking files or folders should open or select them.
      '';
    };

    enableMiddleClickPaste = lib.mkOption {
      type = with lib.types; nullOr bool;
      default = null;
      example = false;
      description = ''
        Whether clicking the middle mouse button pastes the clipboard content.";
      '';
    };

    tooltipDelay = lib.mkOption {
      type = with lib.types; nullOr ints.positive;
      default = null;
      example = 5;
      description = ''
        The delay in milliseconds before an element's tooltip is shown when hovered over.
      '';
    };

    theme = lib.mkOption {
      type = with lib.types; nullOr str;
      default = null;
      example = "breeze-dark";
      description = ''
        The Plasma style. Run `plasma-apply-desktoptheme --list-themes` for valid options.
      '';
    };

    colorScheme = lib.mkOption {
      type = with lib.types; nullOr str;
      default = null;
      example = "BreezeDark";
      description = ''
        The Plasma color scheme. Run `plasma-apply-colorscheme --list-schemes` for valid options.
      '';
    };

    cursor = lib.mkOption {
      type = lib.types.nullOr cursorType;
      default = null;
      example = {
        theme = "Breeze_Snow";
        size = 24;
      };
      description = ''
        Submodule for configuring the cursor appearance. Both the theme and size are configurable.
      '';
    };

    lookAndFeel = lib.mkOption {
      type = with lib.types; nullOr str;
      default = null;
      example = "org.kde.breezedark.desktop";
      description = ''
        The Plasma Global Theme. Run `plasma-apply-lookandfeel --list` for valid options.
      '';
    };

    iconTheme = lib.mkOption {
      type = with lib.types; nullOr str;
      default = null;
      example = "Papirus";
      description = ''
        The Plasma icon theme.
      '';
    };

    wallpaper = lib.mkOption {
      type = with lib.types; nullOr path;
      default = null;
      example = lib.literalExpression ''"''${pkgs.kdePackages.plasma-workspace-wallpapers}/share/wallpapers/Kay/contents/images/1080x1920.png"'';
      description = ''
        The Plasma desktop wallpaper. Can be either the path to an image file or a KPackage.
      '';
    };

    wallpaperSlideShow = lib.mkOption {
      type = lib.types.nullOr wallpaperSlideShowType;
      default = null;
      example = lib.literalExpression ''{ path = "''${pkgs.kdePackages.plasma-workspace-wallpapers}/share/wallpapers/"; }'';
      description = ''
        Submodule for configuring the wallpaper slideshow. Needs a directory with wallpapers and an interval length.
      '';
    };

    wallpaperPictureOfTheDay = lib.mkOption {
      type = lib.types.nullOr wallpaperPictureOfTheDayType;
      default = null;
      example = {
        provider = "apod";
      };
      description = ''
        Which plugin to fetch the Picture of the Day from.
      '';
    };

    wallpaperPlainColor = lib.mkOption {
      type = with lib.types; nullOr str;
      default = null;
      example = "0,64,174,256";
      description = ''
        Set the wallpaper using a plain color. Color is a comma-seperated R,G,B,A string. The alpha is optional (default is 256).
      '';
    };

    wallpaperFillMode = lib.mkOption {
      type = with lib.types; nullOr (enum (builtins.attrNames wallpaperFillModeTypes));
      default = null;
      example = "stretch";
      description = ''
        Defines how the wallpaper should be displayed on the screen.
        Applies only to `wallpaper`, `wallpaperPictureOfTheDay` or `wallpaperSlideShow`.
      '';
    };

    wallpaperBackground = lib.mkOption {
      type = lib.types.nullOr wallpaperBackgroundType;
      default = null;
      example = {
        blur = true;
      };
      description = "How to handle wallpaper background when there is empty space.";
    };

    soundTheme = lib.mkOption {
      type = with lib.types; nullOr str;
      default = null;
      example = "freedesktop";
      description = ''
        The sound theme to use with Plasma.
      '';
    };

    splashScreen = {
      engine = lib.mkOption {
        type = with lib.types; nullOr str;
        default = null;
        example = "none";
        description = ''
          The engine for the splash screen theme. If not specified, Plasma will try
          to set an appropriate engine, but this may fail, in which case this option
          should be specified manually.
        '';
      };
      theme = lib.mkOption {
        type = with lib.types; nullOr str;
        default = null;
        example = "None";
        description = ''
          The splash screen theme shown at login. To view all available values, see the
          `Theme` key in `$HOME/.config/ksplashrc` after imperatively applying the splash screen via
          the System Settings app. Can also be set to `None` to disable the splash screen
          altogether.
        '';
      };
    };

    windowDecorations = {
      library = lib.mkOption {
        type = with lib.types; nullOr str;
        default = null;
        example = "org.kde.kwin.aurorae";
        description = ''
          The library for the window decorations theme. To view all available values,
          see the `library` key in the `org.kde.kdecoration2` section of
          `$HOME/.config/kwinrc` after imperatively applying the window decoration via the
          System Settings app.
        '';
      };
      theme = lib.mkOption {
        type = with lib.types; nullOr str;
        default = null;
        example = "__aurorae__svg__CatppuccinMocha-Modern";
        description = ''
          The window decorations theme. To view all available values, see the `theme` key
          in the `org.kde.kdecoration2` section of `$HOME/.config/kwinrc` after
          imperatively applying the window decoration via the System Settings app.
        '';
      };
    };
  };

  config = (
    lib.mkIf cfg.enable {
      assertions = [
        {
          assertion =
            let
              wallpapers = with cfg.workspace; [
                wallpaperSlideShow
                wallpaper
                wallpaperPictureOfTheDay
                wallpaperPlainColor
              ];
            in
            lib.count (x: x != null) wallpapers <= 1;
          message = "Can set only one of wallpaper, wallpaperSlideShow, wallpaperPictureOfTheDay, and wallpaperPlainColor.";
        }
        {
          assertion = (cfg.workspace.splashScreen.engine == null || cfg.workspace.splashScreen.theme != null);
          message = ''
            Cannot set plasma.workspace.splashScreen.engine without a
            corresponding theme.
          '';
        }
        {
          assertion =
            !(lib.xor (cfg.workspace.windowDecorations.theme == null) (
              cfg.workspace.windowDecorations.library == null
            ));
          message = ''
            Must set both plasma.workspace.windowDecorations.library and
            plasma.workspace.windowDecorations.theme or none.
          '';
        }
        {
          assertion = (
            cfg.workspace.wallpaperBackground == null
            || (
              cfg.workspace.wallpaperBackground.blur == null || cfg.workspace.wallpaperBackground.color == null
            )
          );
          message = "programs.plasma.wallpaperBackground can only have a color or be blurred.";
        }
      ];
      warnings = (
        if
          (
            (cfg.workspace.lookAndFeel != null)
            && (cfg.workspace.splashScreen.theme != null || cfg.workspace.windowDecorations.theme != null)
          )
        then
          [
            ''
              Setting lookAndFeel together with splashScreen or windowDecorations in
              plasma-manager is not recommended since lookAndFeel themes often
              override these settings. Consider setting each part in the lookAndFeel
              theme manually.
            ''
          ]
        else
          [ ]
      );

      programs.plasma.configFile = (
        lib.mkMerge [
          {
            kdeglobals = {
              KDE.SingleClick = (
                lib.mkIf (cfg.workspace.clickItemTo != null) (cfg.workspace.clickItemTo == "open")
              );
              Sounds.Theme = (lib.mkIf (cfg.workspace.soundTheme != null) cfg.workspace.soundTheme);
            };
            plasmarc = (
              lib.mkIf (cfg.workspace.tooltipDelay != null) { PlasmaToolTips.Delay = cfg.workspace.tooltipDelay; }
            );
            kcminputrc = (
              lib.mkIf (cfg.workspace.cursor != null && cfg.workspace.cursor.size != null) {
                Mouse.cursorSize = cfg.workspace.cursor.size;
              }
            );
            ksplashrc.KSplash = (
              lib.mkIf (cfg.workspace.splashScreen.theme != null) {
                Engine = (
                  if (cfg.workspace.splashScreen.engine == null) then
                    (splashScreenEngineDetect cfg.workspace.splashScreen.theme)
                  else
                    cfg.workspace.splashScreen.engine
                );
                Theme = cfg.workspace.splashScreen.theme;
              }
            );
            kwinrc =
              (lib.mkIf (cfg.workspace.windowDecorations.theme != null) {
                "org.kde.kdecoration2".library = cfg.workspace.windowDecorations.library;
                "org.kde.kdecoration2".theme = cfg.workspace.windowDecorations.theme;
              })
              // (lib.optionalAttrs (cfg.workspace.enableMiddleClickPaste != null) {
                Wayland.EnablePrimarySelection = cfg.workspace.enableMiddleClickPaste;
              });
          }
          # We add persistence to some keys in order to not reset the themes on
          # each generation when we use overrideConfig.
          (lib.mkIf (cfg.overrideConfig && anyThemeSet) (
            let
              colorSchemeIgnore =
                if (cfg.workspace.colorScheme != null || cfg.workspace.lookAndFeel != null) then
                  (import ../lib/colorscheme.nix { inherit lib; })
                else
                  { };
            in
            (lib.mkMerge [
              {
                kcminputrc.Mouse.cursorTheme.persistent = lib.mkDefault (
                  cfg.workspace.cursor != null && cfg.workspace.cursor.theme != null
                );
                kdeglobals.General.ColorScheme.persistent = lib.mkDefault (
                  cfg.workspace.colorScheme != null || cfg.workspace.lookAndFeel != null
                );
                kdeglobals.Icons.Theme.persistent = lib.mkDefault (cfg.workspace.iconTheme != null);
                kdeglobals.KDE.LookAndFeelPackage.persistent = lib.mkDefault (cfg.workspace.lookAndFeel != null);
                plasmarc.Theme.name.persistent = lib.mkDefault (cfg.workspace.theme != null);
              }
              colorSchemeIgnore
            ])
          ))
        ]
      );

      # We create a script which applies the different theme settings using
      # kde tools. We then run this using an autostart script, where this is
      # run only on the first login (unless overrideConfig is enabled),
      # granted all the commands succeed (until we change the settings again).
      programs.plasma.startup = {
        startupScript."apply_themes" = (
          lib.mkIf anyThemeSet {
            text = ''
              ${
                if cfg.workspace.lookAndFeel != null then
                  "plasma-apply-lookandfeel -a ${cfg.workspace.lookAndFeel}"
                else
                  ""
              }
              ${if cfg.workspace.theme != null then "plasma-apply-desktoptheme ${cfg.workspace.theme}" else ""}
              ${
                if (cfg.workspace.cursor != null && cfg.workspace.cursor.theme != null) then
                  "plasma-apply-cursortheme ${cfg.workspace.cursor.theme}"
                  + (
                    if cfg.workspace.cursor.size != null then
                      " --size ${builtins.toString cfg.workspace.cursor.size}"
                    else
                      ""
                  )
                else
                  ""
              }
              ${
                if cfg.workspace.colorScheme != null then
                  "plasma-apply-colorscheme ${cfg.workspace.colorScheme}"
                else
                  ""
              }
              ${
                if cfg.workspace.iconTheme != null then
                  "${pkgs.kdePackages.plasma-workspace}/libexec/plasma-changeicons ${cfg.workspace.iconTheme}"
                else
                  ""
              }
            '';
            priority = 1;
          }
        );

        desktopScript."wallpaper_picture" = (
          lib.mkIf (cfg.workspace.wallpaper != null) {
            text = ''
              let allDesktops = desktops();
              for (const desktop of allDesktops) {
                  desktop.wallpaperPlugin = "org.kde.image";
                  desktop.currentConfigGroup = ["Wallpaper", "org.kde.image", "General"];
                  desktop.writeConfig("Image", "file://${toString cfg.workspace.wallpaper}");
                  ${
                    lib.optionalString (cfg.workspace.wallpaperFillMode != null)
                      ''desktop.writeConfig("FillMode", "${
                        toString wallpaperFillModeTypes.${cfg.workspace.wallpaperFillMode}
                      }");''
                  }
                  ${
                    lib.optionalString (cfg.workspace.wallpaperBackground != null)
                      ''desktop.writeConfig("${
                        if cfg.workspace.wallpaperBackground ? blur && cfg.workspace.wallpaperBackground.blur != null then
                          "Blur"
                        else if
                          cfg.workspace.wallpaperBackground ? color && cfg.workspace.wallpaperBackground.color != null
                        then
                          "Color"
                        else
                          throw "plasma-manager: wallpaperBackground is not null and has no option set"
                      }", "${
                        if cfg.workspace.wallpaperBackground ? blur && cfg.workspace.wallpaperBackground.blur != null then
                          lib.boolToString cfg.workspace.wallpaperBackground.blur
                        else if
                          cfg.workspace.wallpaperBackground ? color && cfg.workspace.wallpaperBackground.color != null
                        then
                          cfg.workspace.wallpaperBackground.color
                        else
                          throw "plasma-manager: wallpaperBackground is not null and has no option set"
                      }");''
                  }
              }
            '';
            priority = 3;
          }
        );

        desktopScript."wallpaper_potd" = (
          lib.mkIf (cfg.workspace.wallpaperPictureOfTheDay != null) {
            text = ''
              // Wallpaper POTD
              let allDesktops = desktops();
              for (const desktop of allDesktops) {
                  desktop.wallpaperPlugin = "org.kde.potd";
                  desktop.currentConfigGroup = ["Wallpaper", "org.kde.potd", "General"];
                  desktop.writeConfig("Provider", "${cfg.workspace.wallpaperPictureOfTheDay.provider}");
                  desktop.writeConfig("UpdateOverMeteredConnection", "${
                    if (cfg.workspace.wallpaperPictureOfTheDay.updateOverMeteredConnection) then "1" else "0"
                  }");
                  ${
                    lib.optionalString (cfg.workspace.wallpaperFillMode != null)
                      ''desktop.writeConfig("FillMode", "${
                        toString wallpaperFillModeTypes.${cfg.workspace.wallpaperFillMode}
                      }");''
                  }
                  ${
                    lib.optionalString (cfg.workspace.wallpaperBackground != null)
                      ''desktop.writeConfig("${
                        if cfg.workspace.wallpaperBackground ? blur && cfg.workspace.wallpaperBackground.blur != null then
                          "Blur"
                        else if
                          cfg.workspace.wallpaperBackground ? color && cfg.workspace.wallpaperBackground.color != null
                        then
                          "Color"
                        else
                          throw "plasma-manager: wallpaperBackground is not null and has no option set"
                      }", "${
                        if cfg.workspace.wallpaperBackground ? blur && cfg.workspace.wallpaperBackground.blur != null then
                          lib.boolToString cfg.workspace.wallpaperBackground.blur
                        else if
                          cfg.workspace.wallpaperBackground ? color && cfg.workspace.wallpaperBackground.color != null
                        then
                          cfg.workspace.wallpaperBackground.color
                        else
                          throw "plasma-manager: wallpaperBackground is not null and has no option set"
                      }");''
                  }
              }
            '';
            priority = 3;
          }
        );

        desktopScript."wallpaper_plaincolor" = (
          lib.mkIf (cfg.workspace.wallpaperPlainColor != null) {
            text = ''
              // Wallpaper plain color
              let allDesktops = desktops();
              for (var desktopIndex = 0; desktopIndex < allDesktops.length; desktopIndex++) {
                  var desktop = allDesktops[desktopIndex];
                  desktop.wallpaperPlugin = "org.kde.color";
                  desktop.currentConfigGroup = Array("Wallpaper", "org.kde.color", "General");
                  desktop.writeConfig("Color", "${cfg.workspace.wallpaperPlainColor}");
              }
            '';
            priority = 3;
          }
        );

        desktopScript."wallpaper_slideshow" = (
          lib.mkIf (cfg.workspace.wallpaperSlideShow != null) {
            text = ''
              // Wallpaper slideshow
              let allDesktops = desktops();
              for (var desktopIndex = 0; desktopIndex < allDesktops.length; desktopIndex++) {
                  var desktop = allDesktops[desktopIndex];
                  desktop.wallpaperPlugin = "org.kde.slideshow";
                  desktop.currentConfigGroup = Array("Wallpaper", "org.kde.slideshow", "General");
                  desktop.writeConfig("SlidePaths", ${
                    with cfg.workspace.wallpaperSlideShow;
                    if ((builtins.isPath path) || (builtins.isString path)) then
                      "\"" + (builtins.toString path) + "\""
                    else
                      "[" + (builtins.concatStringsSep "," (map (s: "\"" + s + "\"") path)) + "]"
                  });
                  desktop.writeConfig("SlideInterval", "${builtins.toString cfg.workspace.wallpaperSlideShow.interval}");
                  ${
                    lib.optionalString (cfg.workspace.wallpaperFillMode != null)
                      ''desktop.writeConfig("FillMode", "${
                        toString wallpaperFillModeTypes.${cfg.workspace.wallpaperFillMode}
                      }");''
                  }
                  ${
                    lib.optionalString (cfg.workspace.wallpaperBackground != null)
                      ''desktop.writeConfig("${
                        if cfg.workspace.wallpaperBackground ? blur && cfg.workspace.wallpaperBackground.blur != null then
                          "Blur"
                        else if
                          cfg.workspace.wallpaperBackground ? color && cfg.workspace.wallpaperBackground.color != null
                        then
                          "Color"
                        else
                          throw "plasma-manager: wallpaperBackground is not null and has no option set"
                      }", "${
                        if cfg.workspace.wallpaperBackground ? blur && cfg.workspace.wallpaperBackground.blur != null then
                          lib.boolToString cfg.workspace.wallpaperBackground.blur
                        else if
                          cfg.workspace.wallpaperBackground ? color && cfg.workspace.wallpaperBackground.color != null
                        then
                          cfg.workspace.wallpaperBackground.color
                        else
                          throw "plasma-manager: wallpaperBackground is not null and has no option set"
                      }");''
                  }
              }
            '';
            priority = 3;
          }
        );
      };
    }
  );
}
</file>

<file path="script/rc2nix.py">
#!/usr/bin/env python

################################################################################
#
# This file is part of the package Plasma Manager.  It is subject to
# the license terms in the LICENSE file found in the top-level
# directory of this distribution and at:
#
#   https://github.com/nix-community/plasma-manager
#
# No part of this package, including this file, may be copied,
# modified, propagated, or distributed except according to the terms
# contained in the LICENSE file.
#
################################################################################

import os
import re
import sys
from pathlib import Path
from typing import Callable, Dict, List, Optional, Tuple

# The root directory where configuration files are stored.
XDG_CONFIG_HOME: str = os.path.expanduser(os.getenv("XDG_CONFIG_HOME", "~/.config"))
XDG_DATA_HOME: str = os.path.expanduser(os.getenv("XDG_DATA_HOME", "~/.local/share"))


class Rc2Nix:
    # Files that we'll scan by default.
    KNOWN_CONFIG_FILES: List[str] = [
        os.path.join(XDG_CONFIG_HOME, f)
        for f in [
            "kcminputrc",
            "kglobalshortcutsrc",
            "kactivitymanagerdrc",
            "ksplashrc",
            "kwin_rules_dialogrc",
            "kmixrc",
            "kwalletrc",
            "kgammarc",
            "krunnerrc",
            "klaunchrc",
            "plasmanotifyrc",
            "systemsettingsrc",
            "kscreenlockerrc",
            "kwinrulesrc",
            "khotkeysrc",
            "ksmserverrc",
            "kded5rc",
            "plasmarc",
            "kwinrc",
            "kdeglobals",
            "baloofilerc",
            "dolphinrc",
            "klipperrc",
            "plasma-localerc",
            "kxkbrc",
            "ffmpegthumbsrc",
            "kservicemenurc",
            "kiorc",
            "ktrashrc",
            "kuriikwsfilterrc",
            "plasmaparc",
            "spectaclerc",
            "katerc",
        ]
    ]
    KNOWN_DATA_FILES: List[str] = [
        os.path.join(XDG_DATA_HOME, f)
        for f in [
            "kate/anonymous.katesession",
            "dolphin/view_properties/global/.directory",
        ]
    ]

    class RcFile:
        # Any group that matches a listed regular expression is blocked
        GROUP_BLOCK_LIST: List[str] = [
            r"^(ConfigDialog|FileDialogSize|ViewPropertiesDialog|KPropertiesDialog)$",
            r"^\$Version$",
            r"^ColorEffects:",
            r"^Colors:",
            r"^DoNotDisturb$",
            r"^LegacySession:",
            r"^MainWindow$",
            r"^PlasmaViews",
            r"^ScreenConnectors$",
            r"^Session:",
            r"^Recent (Files|URLs)",
        ]

        # Similar to the GROUP_BLOCK_LIST but for setting keys.
        KEY_BLOCK_LIST: List[str] = [
            r"^activate widget \d+$",  # Depends on state :(
            r"^ColorScheme(Hash)?$",
            r"^History Items",
            r"^LookAndFeelPackage$",
            r"^Recent (Files|URLs)",
            r"^Theme$i",
            r"^Version$",
            r"State$",
            r"Timestamp$",
        ]

        # List of functions that get called with a group name and a key name.
        BLOCK_LIST_LAMBDA: List[Callable[[str, str], bool]] = [
            lambda group, key: group == "org.kde.kdecoration2" and key == "library"
        ]

        def __init__(self, file_name: str):
            self.file_name: str = file_name
            self.settings: Dict[str, Dict[str, str]] = {}
            self.last_group: Optional[str] = None

        def parse(self):

            def is_group_line(line: str) -> bool:
                return re.match(r"^\s*(\[[^\]]+\])+\s*$", line) is not None

            def is_setting_line(line: str) -> bool:
                return re.match(r"^\s*([^=]+)=?(.*)\s*$", line) is not None

            def parse_group(line: str) -> str:
                return re.sub(
                    r"\s*\[([^\]]+)\]\s*", r"\1/", line.replace("/", "\\\\/")
                ).rstrip("/")

            def parse_setting(line: str) -> Tuple[str, str]:
                match = re.match(r"^\s*([^=]+)=?(.*)\s*$", line)
                if match:
                    return match.groups()  # type: ignore
                raise Exception(f"{self.file_name}: can't parse setting line: {line}")

            with open(self.file_name, "r") as file:
                for line in file:
                    line = line.strip()
                    if not line:
                        continue
                    if is_group_line(line):
                        self.last_group = parse_group(line)
                    elif is_setting_line(line):
                        key, val = parse_setting(line)
                        self.process_setting(key, val)
                    else:
                        raise Exception(f"{self.file_name}: can't parse line: {line}")

        def process_setting(self, key: str, val: str):

            def should_skip_group(group: str) -> bool:
                return any(re.match(reg, group) for reg in self.GROUP_BLOCK_LIST)

            def should_skip_key(key: str) -> bool:
                return any(re.match(reg, key) for reg in self.KEY_BLOCK_LIST)

            def should_skip_by_lambda(group: str, key: str) -> bool:
                return any(fn(group, key) for fn in self.BLOCK_LIST_LAMBDA)

            key = key.strip()
            val = val.strip()

            if self.last_group is None:
                raise Exception(
                    f"{self.file_name}: setting outside of group: {key}={val}"
                )

            if (
                should_skip_group(self.last_group)
                or should_skip_key(key)
                or should_skip_by_lambda(self.last_group, key)
            ):
                return

            if self.last_group not in self.settings:
                self.settings[self.last_group] = {}
            self.settings[self.last_group][key] = val

    class App:
        def __init__(self, args: List[str]):
            self.config_files: List[str] = Rc2Nix.KNOWN_CONFIG_FILES.copy()
            self.data_files: List[str] = Rc2Nix.KNOWN_DATA_FILES.copy()
            self.config_settings: Dict[str, Dict[str, Dict[str, str]]] = {}
            self.data_settings: Dict[str, Dict[str, Dict[str, str]]] = {}

        def run(self):
            for file in self.config_files:
                if not os.path.exists(file):
                    continue

                rc = Rc2Nix.RcFile(file)
                rc.parse()

                path = Path(file).relative_to(XDG_CONFIG_HOME)
                self.config_settings[str(path)] = rc.settings

            for file in self.data_files:
                if not os.path.exists(file):
                    continue

                rc = Rc2Nix.RcFile(file)
                rc.parse()

                path = Path(file).relative_to(XDG_DATA_HOME)
                self.data_settings[str(path)] = rc.settings

            self.print_output()

        def print_output(self):
            print("{")
            print("  programs.plasma = {")
            print("    enable = true;")
            print("    shortcuts = {")
            print(
                self.pp_shortcuts(self.config_settings.get("kglobalshortcutsrc", {}), 6)
            )
            print("    };")
            print("    configFile = {")
            print(self.pp_settings(self.config_settings, 6))
            print("    };")
            print("    dataFile = {")
            print(self.pp_settings(self.data_settings, 6))
            print("    };")
            print("  };")
            print("}")

        def pp_settings(
            self, settings: Dict[str, Dict[str, Dict[str, str]]], indent: int
        ) -> str:
            result: List[str] = []
            for file in sorted(settings.keys()):
                if file != "kglobalshortcutsrc":
                    for group in sorted(settings[file].keys()):
                        for key in sorted(settings[file][group].keys()):
                            if key != "_k_friendly_name":
                                result.append(
                                    f"{' ' * indent}\"{file}\".\"{group}\".\"{key}\" = {nix_val(settings[file][group][key])};"
                                )
            return "\n".join(result)

        def pp_shortcuts(self, groups: Dict[str, Dict[str, str]], indent: int) -> str:
            if not groups:
                return ""

            result: List[str] = []
            for group in sorted(groups.keys()):
                for action in sorted(groups[group].keys()):
                    if action != "_k_friendly_name":
                        keys = (
                            groups[group][action]
                            .split(r"(?<!\\),")[0]
                            .replace(r"\?", ",")
                            .replace(r"\t", "\t")
                            .split("\t")
                        )

                        if not keys or keys[0] == "none":
                            keys_str = "[ ]"
                        elif len(keys) > 1:
                            keys_str = (
                                f"[{' '.join(nix_val(k.rstrip(',')) for k in keys)}]"
                            )
                        else:
                            ks = keys[0].split(",")
                            k = ks[0] if len(ks) == 3 and ks[0] == ks[1] else keys[0]
                            keys_str = (
                                "[ ]"
                                if k == "" or k == "none"
                                else nix_val(k.rstrip(","))
                            )

                        result.append(
                            f"{' ' * indent}\"{group}\".\"{action}\" = {keys_str};"
                        )
            return "\n".join(result)


def nix_val(s: Optional[str]) -> str:
    if s is None:
        return "null"
    if re.match(r"^(true|false)$", s, re.IGNORECASE):
        return s.lower()
    if re.match(r"^[0-9]+(\.[0-9]+)?$", s):
        return s
    return '"' + re.sub(r'(?<!\\)"', r'\\"', s) + '"'


Rc2Nix.App(sys.argv[1:]).run()
</file>

<file path="script/rc2nix.rb">
#!/usr/bin/env ruby

################################################################################
#
# This file is part of the package Plasma Manager.  It is subject to
# the license terms in the LICENSE file found in the top-level
# directory of this distribution and at:
#
#   https://github.com/nix-community/plasma-manager
#
# No part of this package, including this file, may be copied,
# modified, propagated, or distributed except according to the terms
# contained in the LICENSE file.
#
################################################################################
require("optparse")
require("pathname")

################################################################################
module Rc2Nix

  ##############################################################################
  # The root directory where configuration files are stored.
  XDG_CONFIG_HOME = File.expand_path(ENV["XDG_CONFIG_HOME"] || "~/.config")

  ##############################################################################
  # Files that we'll scan by default.
  KNOWN_FILES = [
    "kcminputrc",
    "kglobalshortcutsrc",
    "kactivitymanagerdrc",
    "ksplashrc",
    "kwin_rules_dialogrc",
    "kmixrc",
    "kwalletrc",
    "kgammarc",
    "krunnerrc",
    "klaunchrc",
    "plasmanotifyrc",
    "systemsettingsrc",
    "kscreenlockerrc",
    "kwinrulesrc",
    "khotkeysrc",
    "ksmserverrc",
    "kded5rc",
    "plasmarc",
    "kwinrc",
    "kdeglobals",
    "baloofilerc",
    "dolphinrc",
    "klipperrc",
    "plasma-localerc",
    "kxkbrc",
    "ffmpegthumbsrc",
    "kservicemenurc",
    "kiorc",
  ].map {|f| File.expand_path(f, XDG_CONFIG_HOME)}.freeze

  ##############################################################################
  class RcFile

    ############################################################################
    # Any group that matches a listed regular expression is blocked
    # from being passed through to the settings attribute.
    #
    # This is necessary because KDE currently stores application state
    # in configuration files.
    GROUP_BLOCK_LIST = [
      /^(ConfigDialog|FileDialogSize|ViewPropertiesDialog|KPropertiesDialog)$/,
      /^\$Version$/,
      /^ColorEffects:/,
      /^Colors:/,
      /^DoNotDisturb$/,
      /^LegacySession:/,
      /^MainWindow$/,
      /^PlasmaViews/,
      /^ScreenConnectors$/,
      /^Session:/,
    ]

    ############################################################################
    # Similar to the GROUP_BLOCK_LIST but for setting keys.
    KEY_BLOCK_LIST = [
      /^activate widget \d+$/, # Depends on state :(
      /^ColorScheme(Hash)?$/,
      /^History Items/,
      /^LookAndFeelPackage$/,
      /^Recent (Files|URLs)/,
      /^Theme$/i,
      /^Version$/,
      /State$/,
      /Timestamp$/,
    ]

    ############################################################################
    # List of functions that get called with a group name and a key
    # name.  If the function returns +true+ then block that key.
    BLOCK_LIST_LAMBDA = [
      ->(group, key) { group == "org.kde.kdecoration2" && key == "library" }
    ]

    ############################################################################
    attr_reader(:file_name, :settings)

    ############################################################################
    def initialize(file_name)
      @file_name = file_name
      @settings = {}
      @last_group = nil
    end

    ############################################################################
    def parse
      File.open(@file_name) do |file|
        file.each do |line|
          case line
          when /^\s*$/
            next
          when /^\s*(\[[^\]]+\]){1,}\s*$/
            @last_group = parse_group(line.strip)
          when /^\s*([^=]+)=?(.*)\s*$/
            key = $1.strip
            val = $2.strip

            if @last_group.nil?
              raise("#{@file_name}: setting outside of group: #{line}")
            end

            # Reasons to skip this group or key:
            next if GROUP_BLOCK_LIST.any? {|re| @last_group.match(re)}
            next if KEY_BLOCK_LIST.any? {|re| key.match(re)}
            next if BLOCK_LIST_LAMBDA.any? {|fn| fn.call(@last_group, key)}
            next if File.basename(@file_name) == "plasmanotifyrc" && key == "Seen"

            @settings[@last_group] ||= {}
            @settings[@last_group][key] = val
          else
            raise("#{@file_name}: can't parse line: #{line}")
          end
        end
      end
    end

    ############################################################################
    def parse_group(line)
      line.gsub("/", "\\\\\\/").gsub(/\s*\[([^\]]+)\]\s*/) do |match|
        $1 + "/"
      end.sub(/\/$/, '')
    end
  end

  ##############################################################################
  class App

    ############################################################################
    def initialize(args)
      @files = KNOWN_FILES.dup

      OptionParser.new do |p|
        p.on("-h", "--help", "This message") {$stdout.puts(p); exit}

        p.on("-c", "--clear", "Clear the file list") do
          @files = []
        end

        p.on("-a", "--add=FILE", "Add a file to the scan list") do |file|
          @files << File.expand_path(file)
        end
      end.parse!(args)
    end

    ############################################################################
    def run
      settings = {}

      @files.each do |file|
        next unless File.exist?(file)

        rc = RcFile.new(file)
        rc.parse

        path = Pathname.new(file).relative_path_from(XDG_CONFIG_HOME)
        settings[File.path(path)] = rc.settings
      end

      puts("{")
      puts("  programs.plasma = {")
      puts("    enable = true;")
      puts("    shortcuts = {")
      pp_shortcuts(settings["kglobalshortcutsrc"], 6)
      puts("    };")
      puts("    configFile = {")
      pp_settings(settings, 6)
      puts("    };")
      puts("  };")
      puts("}")
    end

    ############################################################################
    def pp_settings(settings, indent)
      settings.keys.sort.each do |file|
        settings[file].keys.sort.each do |group|
          settings[file][group].keys.sort.each do |key|
            next if file == "kglobalshortcutsrc" && key != "_k_friendly_name"

            print(" " * indent)
            print("\"#{file}\".")
            print("\"#{group}\".")
            print("\"#{key}\" = ")
            print(nix_val(settings[file][group][key]))
            print(";\n")
          end
        end
      end
    end

    ############################################################################
    def pp_shortcuts(groups, indent)
      return if groups.nil?

      groups.keys.sort.each do |group|
        groups[group].keys.sort.each do |action|
          next if action == "_k_friendly_name"

          print(" " * indent)
          print("\"#{group}\".")
          print("\"#{action}\" = ")

          keys = groups[group][action].
            split(/(?<!\\),/).first.to_s.
            gsub(/\\?\\,/, ',').
            gsub(/\\t/, "\t").
            split(/\t/)

          if keys.empty?
            print("[ ]")
          elsif keys.size > 1
            print("[" + keys.map {|k| nix_val(k)}.join(" ") + "]")
          elsif keys.first == "none"
            print("[ ]")
          else
            print(nix_val(keys.first))
          end

          print(";\n")
        end
      end
    end

    ############################################################################
    def nix_val(str)
      case str
      when NilClass
        "null"
      when /^true|false$/i
        str.downcase
      when /^[0-9]+(\.[0-9]+)?$/
        str
      else
        '"' + str.gsub(/(?<!\\)"/, '\\"') + '"'
      end
    end
  end
end

Rc2Nix::App.new(ARGV).run
</file>

<file path="script/write_config.py">
import glob
import json
import os
import re
import sys
from dataclasses import dataclass
from typing import Any, Optional, Self


# KDE has a bespoke escape format:
# https://invent.kde.org/frameworks/kconfig/-/blob/v6.7.0/src/core/kconfigini.cpp?ref_type=tags#L880-945
def unescape(s: str) -> str:
    out: list[str] = []
    while s:
        parts = s.split("\\", 1)
        out.append(parts.pop(0))
        if not parts:
            break
        s = parts[0]
        if not s:
            out.append("\\")
            break
        symbol, s = s[0], s[1:]
        match symbol:
            case "s":
                out.append(" ")
            case "t":
                out.append("\t")
            case "n":
                out.append("\n")
            case "r":
                out.append("\r")
            case "\\":
                out.append("\\")
            case ";":
                out.append("\\;")
            case ",":
                out.append("\\,")
            case "x" if len(s) >= 2:
                num = s[0:2]
                try:
                    out.append(chr(int(num, 16)))
                    s = s[2:]
                except ValueError:
                    out.append("\\x")
            case _:
                # Invalid escape sequence
                out.append("\\" + symbol)
    return "".join(out)


def escape_bytes(c: str) -> str:
    return "".join(f"\\x{b:02x}" for b in c.encode("utf-8"))


def escape(s: str) -> str:
    if not s:
        return s
    ls: list[str] = list(s)
    for i, c in enumerate(ls):
        match c:
            case "\n":
                ls[i] = "\\n"
            case "\t":
                ls[i] = "\\t"
            case "\r":
                ls[i] = "\\r"
            case "\\":
                ls[i] = "\\\\"
            case "=" | "[" | "]":
                ls[i] = escape_bytes(c)
            case _ if ord(c) < 32:
                ls[i] = escape_bytes(c)
            case _:
                pass
    for i in (0, -1):
        if ls[i] == " ":
            ls[i] = "\\s"
    return "".join(ls)


@dataclass
class ConfigValue:
    value: Optional[str]
    immutable: bool = False
    shellExpand: bool = False

    @classmethod
    def parse_line(cls, line: str) -> tuple[str, Self]:
        line_splitted = line.split("=", 1)
        key = line_splitted.pop(0).strip()
        marking = ""
        if "[" in key:
            key, marking = key.split("[")
            marking = marking[1:-1]
        value = cls(
            value=None,
            immutable="i" in marking,
            shellExpand="e" in marking,
        )
        key = unescape(key)
        if line_splitted:
            value.value = line_splitted[0].strip()
        return key, value

    @classmethod
    def from_json(cls, value: dict[str, Any]) -> Self:
        key_value = (
            str(value["value"])
            if not isinstance(value["value"], bool)
            else str(value["value"]).lower()
        )
        return cls(
            value=escape(key_value) if value["escapeValue"] else key_value,
            immutable=value["immutable"],
            shellExpand=value["shellExpand"],
        )

    @property
    def marking(self):
        """
        Calculates the "marking" we should add to the keys, which for example may be
        [$i] if we want immutability, or [$e] if we want to expand variables. See
        https://api.kde.org/frameworks/kconfig/html/options.html for some options.
        """
        if self.immutable and self.shellExpand:
            return "[$ei]"
        elif self.immutable:
            return "[$i]"
        elif self.shellExpand:
            return "[$e]"
        else:
            return ""

    def to_line(self, key: str) -> str:
        """For keys with values (not None) we give key=value, if not just give
        the key as the line (this is useful in khotkeysrc)."""
        key = escape(key) + self.marking
        return f"{key}={self.value}" if self.value is not None else key


class KConfManager:
    def __init__(
        self,
        filepath: str,
        json_dict: dict[str, Any],
        reset: bool,
        immutable_by_default: bool,
    ):
        """
        filepath (str): The full path to the config-file to manage
        json_dict (Dict): The nix-configuration presented in a dictionary (converted from json)
        reset (bool): Whether to reset the file, i.e. remove all the lines not present in the configuration
        """
        self.data: dict[tuple[str, ...], dict[str, ConfigValue]] = {}
        self.filepath = filepath
        self.reset = reset
        self.immutable_by_default = immutable_by_default
        self._json_value_checks(json_dict)
        # The nix expressions will have / to separate groups, and \/ to escape a /.
        # This parses the groups into tuples of unescaped group names.
        self.json_dict: dict[tuple[str, ...], Any] = {
            tuple(
                g.replace("\\/", "/")
                for g in re.findall(r"(/|(?:[^/\\]|\\.)+)", group)[::2]
            ): entry
            for group, entry in json_dict.items()
        }

    def _json_value_checks(self, json_dict: dict[str, Any]):
        for group, entry in json_dict.items():
            for key, value in entry.items():
                non_default_immutability = (
                    value["immutable"] != self.immutable_by_default
                )
                if (
                    value["value"] is None
                    and not value["persistent"]
                    and (non_default_immutability or value["shellExpand"])
                ):
                    raise Exception(
                        f'Plasma-manager: No value or persistency set for key "{key}" in group "{group}" in configfile "{self.filepath}"'
                        ", but one of immutability/persistency takes a non-default value. This is not supported"
                    )
                elif value["persistent"]:
                    base_msg = f'Plasma-manager: Persistency enabled for key "{key}" in group "{group}" in configfile "{self.filepath}"'
                    if value["value"] is not None:
                        raise Exception(
                            f"{base_msg} with non-null value \"{value['value']}\". "
                            "A value cannot be given when persistency is enabled"
                        )
                    elif non_default_immutability:
                        raise Exception(
                            f"{base_msg} with non-default immutability. Persistency with non-default immutability is not supported"
                        )
                    elif value["shellExpand"]:
                        raise Exception(
                            f"{base_msg} with shell-expansion enabled. Persistency with shell-expansion enabled is not supported"
                        )

    def key_is_persistent(self, group: tuple[str, ...], key: str) -> bool:
        """
        Checks if a key in a group in the nix config is persistent.
        """
        try:
            is_persistent = (
                self.json_dict[group][key]["persistent"]
                and self.json_dict[group][key]["value"] is None
            )
        except KeyError:
            is_persistent = False

        return is_persistent

    def read(self):
        """
        Read the config from the path specified on instantiation. If the
        path doesn't exist, do nothing.
        """
        try:
            with open(self.filepath, "r", encoding="utf-8") as f:
                current_group = ()  # default group
                for l in f:
                    # Checks if the current line indicates a group.
                    if re.match(r"^\[.*\]\s*$", l):
                        current_group = l.rstrip()[1:-1].split("][")
                        current_group = tuple(unescape(g) for g in current_group)
                        self.data[current_group] = {}
                        continue

                    # We won't bother reading empty lines.
                    if l.strip() != "":
                        key, value = ConfigValue.parse_line(l)
                        is_persistent = self.key_is_persistent(current_group, key)
                        should_keep_key = is_persistent or not self.reset
                        if should_keep_key:
                            self.set_value(
                                current_group,
                                key,
                                value,
                            )
        except FileNotFoundError:
            pass

    def run(self):
        self.read()
        for group, entry in self.json_dict.items():
            for key, value in entry.items():
                # If the nix expression is null, resulting in the value None here,
                # we remove the key/option (and the group/section if it is empty
                # after removal, and persistency is disabled).
                if value["value"] is None and not value["persistent"]:
                    self.remove_value(group, key)
                    continue

                # Again values from the nix json are not escaped, so we need to
                # escape them here (in case it includes \t \n and so on). We
                # also don't set the keys if the key is persistent, as we want
                # to leave that key unchanged from the read() method.
                if not value["persistent"]:
                    self.set_value(group, key, ConfigValue.from_json(value))

    def set_value(self, group: tuple[str, ...], key: str, value: ConfigValue):
        """Adds an entry to the config. Creates necessary groups if needed."""
        if not group in self.data:
            self.data[group] = {}

        self.data[group][key] = value

    def remove_value(self, group: tuple[str, ...], key: str):
        """Removes an entry from the config. Does nothing if the entry isn't there."""
        if group in self.data and key in self.data[group]:
            del self.data[group][key]

    def save(self):
        """Save to the filepath specified on instantiation."""
        # If the directory we want to save to doesn't exist we will allow this,
        # and just create the directory before.
        dir = os.path.dirname(self.filepath)
        if not os.path.exists(dir):
            os.makedirs(dir)

        with open(self.filepath, "w", encoding="utf-8") as f:
            # We skip a newline before the first category
            skip_newline = True

            for group in sorted(self.data):
                if not self.data[group]:
                    # We skip over groups with no keys, they don't need to be written
                    continue

                if not skip_newline:
                    f.write("\n")
                else:
                    # Only skip the newline once of course.
                    skip_newline = False

                if group:
                    key = "][".join(escape(g) for g in group)
                    f.write(f"[{key}]\n")
                for key, value in self.data[group].items():
                    f.write(f"{value.to_line(key)}\n")


def remove_config_files(d: dict[str, Any], reset_files: set[str]):
    """
    Removes files which doesn't have any configuration entries in d and which is
    in the list of files to be reset by overrideConfig.
    """
    for del_path in reset_files - set(d.keys()):
        for file_to_del in glob.glob(del_path, recursive=True):
            if os.path.isfile(file_to_del):
                os.remove(file_to_del)


def write_configs(d: dict[str, Any], reset_files: set[str], immutable_by_default: bool):
    for filepath, c in d.items():
        config = KConfManager(
            filepath, c, filepath in reset_files, immutable_by_default
        )
        config.run()
        config.save()


def main():
    if len(sys.argv) != 4:
        raise ValueError(
            f"Must receive exactly four arguments, got: {len(sys.argv) - 1}"
        )

    json_path = sys.argv[1]
    with open(json_path, "r") as f:
        json_str = f.read()

    reset_files: set[str] = set(sys.argv[2].split(" ")) if sys.argv[2] != "" else set()
    immutable_by_default = bool(sys.argv[3])
    d = json.loads(json_str)
    remove_config_files(d, reset_files)
    write_configs(d, reset_files, immutable_by_default)


if __name__ == "__main__":
    main()
</file>

<file path="test/rc2nix/test_data/kcminputrc">
[Keyboard]
KeyboardRepeating=0
NumLock=2
RepeatDelay=250
RepeatRate=30

[Mouse]
X11LibInputXAccelProfileFlat=true
XLbInptPointerAcceleration=1
cursorTheme=Oxygen_White

[Tmp]
update_info=delete_cursor_old_default_size.upd:DeleteCursorOldDefaultSize,kcminputrc_repeat.upd:kcminputrc_migrate_repeat_value

[Libinput][2][14][ETPS/2 Elantech Touchpad]
NaturalScroll=true
</file>

<file path="test/rc2nix/test_data/kglobalshortcutsrc">
[kwin]
Switch to Desktop 1=Meta+1,,
Switch to Desktop 2=Meta+2,,
Switch to Desktop 3=Meta+3,,
Switch to Desktop 4=Meta+4,,
Switch to Desktop 5=Meta+5,,
Switch to Desktop 6=Meta+6,,
Switch to Desktop 7=Meta+7,,
Switch to Desktop 8=Meta+8,,
</file>

<file path="test/rc2nix/test_data/krunnerrc">
[General]
FreeFloating=true
</file>

<file path="test/rc2nix/test_data/kscreenlockerrc">
[Greeter]
WallpaperPlugin=org.kde.potd

[Greeter][Wallpaper][org.kde.potd][General]
Provider=bing
UpdateOverMeteredConnection=0
</file>

<file path="test/rc2nix/test_data/kwinrc">
[Desktops]
Number=8
Rows=2

[Effect-overview]
BorderActivate=9

[Plugins]
shakecursorEnabled=true
</file>

<file path="test/rc2nix/test_rc2nix.py">
#!/usr/bin/env nix
#! nix shell nixpkgs#python3Packages.python nixpkgs#ruby -c python3
import os
import subprocess
import unittest


def red(s: str) -> str:
    return "\033[91m" + s + "\033[0m"


def green(s: str) -> str:
    return "\033[32m" + s + "\033[0m"


def gray(s: str) -> str:
    return "\033[90m" + s + "\033[0m"


current_dir = os.path.dirname(os.path.abspath(__file__))


def path(relative_path: str) -> str:
    return os.path.abspath(os.path.join(current_dir, relative_path))


rc2nix_py = path("../../script/rc2nix.py")
rc2nix_rb = path("../../script/rc2nix.rb")


class TestRc2nix(unittest.TestCase):

    def test(self):
        def run_script(*command: str) -> str:
            rst = subprocess.run(
                command,
                env={
                    "XDG_CONFIG_HOME": path("./test_data"),
                    "PATH": os.environ["PATH"],
                },
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
            )
            print(red(rst.stderr))
            rst.check_returncode()
            return rst.stdout

        rst_py = run_script(rc2nix_py)
        rst_rb = run_script(rc2nix_rb)

        self.assertEqual(rst_py.splitlines(), rst_rb.splitlines())


if __name__ == "__main__":  # pragma: no cover
    _ = unittest.main()
</file>

<file path="test/basic.nix">
{
  testers,
  home-manager-module,
  plasma-module,
  writeShellScriptBin,
  kdePackages,
}:
let
  script = writeShellScriptBin "plasma-basic-test" ''
    set -eu

    export XDG_CONFIG_HOME=''${XDG_CONFIG_HOME:-$HOME/.config}
    export PATH=${kdePackages.kconfig}/bin:$PATH

    kread_global() {
      kreadconfig6 --file $XDG_CONFIG_HOME/kdeglobals "$@"
    }

    assert_eq() {
      want=$1
      shift
      actual=$(kread_global "$@")

      if [ "$actual" != "$want" ]; then
        echo >&2 "ERROR: $@: expected $want but got $actual"
        exit 1
      fi
    }

    assert_eq false --group KDE --key SingleClick
    # Set with shorthand
    assert_eq 1 --group group --key key1
    # Set with longhand and immutable
    assert_eq 2 --group group --key key2
    # Nested groups, with group containing /
    assert_eq 3 --group escaped/nested --group group --key key3
    # Value and key have leading space
    assert_eq " leading space" --group group --key " leading space"
    # Set outside plasma-manager, value has leading space, group contains /
    assert_eq " value" --group escaped/nested --group group --key untouched
    # Escaped key with shell expansion
    assert_eq "/home/fake" --group group --key 'escaped[$i]'
  '';
in
testers.nixosTest {
  name = "plasma-basic";

  nodes.machine = {
    environment.systemPackages = [ script ];
    imports = [ home-manager-module ];

    users.users.fake = {
      createHome = true;
      isNormalUser = true;
    };

    home-manager.users.fake =
      { lib, ... }:
      {
        home.stateVersion = "23.11";
        imports = [ plasma-module ];
        programs.plasma = {
          enable = true;
          workspace.clickItemTo = "select";
          # Test a variety of weird keys and groups
          configFile.kdeglobals = {
            group = {
              " leading space" = " leading space";
              key1 = 1;
              key2 = {
                value = 2;
                immutable = true;
              };
              "escaped[$i]" = {
                value = "\${HOME}";
                shellExpand = true;
              };
            };
            "escaped\\/nested/group" = {
              key3 = 3;
            };
          };
        };
        home.activation.preseed = lib.hm.dag.entryBefore [ "configure-plasma" ] ''
          mkdir -p ~/.config
          cat <<EOF >> ~/.config/kdeglobals
          [escaped/nested][group]
          untouched = \svalue
          EOF
        '';
      };
  };

  testScript = ''
    # Boot:
    start_all()
    machine.wait_for_unit("multi-user.target")
    machine.wait_for_unit("nix-daemon.socket")

    machine.wait_until_succeeds(
        "systemctl show -p ActiveState --value home-manager-fake.service | grep -q 'inactive' && " +
        "systemctl show -p Result --value home-manager-fake.service | grep -q 'success'"
    )

    # Run tests:
    machine.succeed("test -e /home/fake/.config/kdeglobals")
    machine.succeed("su - fake -c plasma-basic-test")
  '';
}
</file>

<file path="test/demo.nix">
{ home-manager-module, plasma-module }:

{ modulesPath, ... }:
{
  imports = [
    (modulesPath + "/profiles/qemu-guest.nix")
    (modulesPath + "/virtualisation/qemu-vm.nix")
    home-manager-module
  ];

  config = {
    networking.hostName = "plasma-demo";

    fileSystems."/" = {
      device = "/dev/disk/by-label/nixos";
      fsType = "ext4";
      autoResize = true;
    };

    boot = {
      growPartition = true;
      loader.timeout = 5;
      kernelParams = [
        "console=ttyS0"
        "boot.shell_on_fail"
      ];
    };

    virtualisation.forwardPorts = [
      {
        from = "host";
        host.port = 2222;
        guest.port = 22;
      }
    ];

    services.xserver.enable = true;
    services.displayManager = {
      autoLogin.user = "fake";
      autoLogin.enable = true;
      defaultSession = "plasma";
      sddm.enable = true;
    };
    services.desktopManager.plasma6.enable = true;

    system.stateVersion = "23.11";

    users.users.fake = {
      createHome = true;
      isNormalUser = true;
      password = "password";
      group = "users";
    };

    home-manager.users.fake = {
      home.stateVersion = "22.05";
      imports = [ plasma-module ];
    };
  };
}
</file>

<file path=".envrc">
# -*- sh -*-

use flake
</file>

<file path=".gitignore">
result-*
result
.direnv
</file>

<file path="default.nix">
{
  pkgs ? import <nixpkgs> { },
}:
{
  docs = import ./docs {
    inherit pkgs;
    lib = pkgs.lib;
  };
}
</file>

<file path="flake.lock">
{
  "nodes": {
    "home-manager": {
      "inputs": {
        "nixpkgs": [
          "nixpkgs"
        ]
      },
      "locked": {
        "lastModified": 1740494361,
        "narHash": "sha256-Dd/GhJ9qKmUwuhgt/PAROG8J6YdU2ZjtJI9SQX5sVQI=",
        "owner": "nix-community",
        "repo": "home-manager",
        "rev": "74f0a8546e3f2458c870cf90fc4b38ac1f498b17",
        "type": "github"
      },
      "original": {
        "owner": "nix-community",
        "repo": "home-manager",
        "type": "github"
      }
    },
    "nixpkgs": {
      "locked": {
        "lastModified": 1740367490,
        "narHash": "sha256-WGaHVAjcrv+Cun7zPlI41SerRtfknGQap281+AakSAw=",
        "owner": "NixOS",
        "repo": "nixpkgs",
        "rev": "0196c0175e9191c474c26ab5548db27ef5d34b05",
        "type": "github"
      },
      "original": {
        "owner": "NixOS",
        "ref": "nixos-unstable",
        "repo": "nixpkgs",
        "type": "github"
      }
    },
    "root": {
      "inputs": {
        "home-manager": "home-manager",
        "nixpkgs": "nixpkgs"
      }
    }
  },
  "root": "root",
  "version": 7
}
</file>

<file path="flake.nix">
{
  description = "Manage KDE Plasma with Home Manager";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";

    home-manager.url = "github:nix-community/home-manager";
    home-manager.inputs.nixpkgs.follows = "nixpkgs";
  };

  outputs =
    inputs@{ self, ... }:
    let
      # Systems that can run tests:
      supportedSystems = [
        "aarch64-linux"
        "i686-linux"
        "x86_64-linux"
      ];

      # Function to generate a set based on supported systems:
      forAllSystems = inputs.nixpkgs.lib.genAttrs supportedSystems;

      # Attribute set of nixpkgs for each system:
      nixpkgsFor = forAllSystems (system: import inputs.nixpkgs { inherit system; });
    in
    {
      homeManagerModules.plasma-manager =
        { ... }:
        {
          imports = [ ./modules ];
        };

      packages = forAllSystems (
        system:
        let
          pkgs = nixpkgsFor.${system};
          docs = import ./docs {
            inherit pkgs;
            lib = pkgs.lib;
          };
        in
        {
          default = self.packages.${system}.rc2nix;

          demo =
            (inputs.nixpkgs.lib.nixosSystem {
              inherit system;
              modules = [
                (import test/demo.nix {
                  home-manager-module = inputs.home-manager.nixosModules.home-manager;
                  plasma-module = self.homeManagerModules.plasma-manager;
                })
                (_: { environment.systemPackages = [ self.packages.${system}.rc2nix ]; })
              ];
            }).config.system.build.vm;

          docs-html = docs.html;
          docs-json = docs.json;

          rc2nix = pkgs.writeShellApplication {
            name = "rc2nix";
            runtimeInputs = with pkgs; [ python3 ];
            text = ''python3 ${script/rc2nix.py} "$@"'';
          };
        }
      );

      apps = forAllSystems (system: {
        default = self.apps.${system}.rc2nix;

        demo = {
          type = "app";
          program = "${self.packages.${system}.demo}/bin/run-plasma-demo-vm";
        };

        rc2nix = {
          type = "app";
          program = "${self.packages.${system}.rc2nix}/bin/rc2nix";
        };
      });

      checks = forAllSystems (system: {
        default = nixpkgsFor.${system}.callPackage ./test/basic.nix {
          home-manager-module = inputs.home-manager.nixosModules.home-manager;
          plasma-module = self.homeManagerModules.plasma-manager;
        };
      });

      formatter = forAllSystems (system: nixpkgsFor.${system}.treefmt);

      devShells = forAllSystems (system: {
        default = nixpkgsFor.${system}.mkShell {
          buildInputs = with nixpkgsFor.${system}; [
            nixfmt-rfc-style
            ruby
            ruby.devdoc
            (python3.withPackages (pyPkgs: [
              pyPkgs.python-lsp-server
              pyPkgs.black
              pyPkgs.isort
            ]))
          ];
        };
      });
    };
}
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2022 Plasma Manager contributors

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="README.md">
# Manage KDE Plasma with Home Manager

This project aims to provide [Home Manager][home-manager] modules which allow you
to configure KDE Plasma using Nix.

## Table of contents
- [Manage KDE Plasma with Home Manager](#manage-kde-plasma-with-home-manager)
- [Table of contents](#table-of-contents)
- [Supported versions](#supported-versions)
- [What's supported](#whats-supported)
- [What's not well supported (at the moment)](#whats-not-well-supported-at-the-moment)
- [What will not be supported](#what-will-not-be-supported)
- [Getting started](#getting-started)
- [Make your configuration more declarative with overrideConfig](#make-your-configuration-more-declarative-with-overrideconfig)
- [Capturing Your Current Configuration with rc2nix](#capturing-your-current-configuration-with-rc2nix)
- [Contributions and Maintenance](#contributions-and-maintenance)
- [Special Thanks](#special-thanks)

## Supported versions
`plasma-manager` supports both plasma 5 and plasma 6. The `trunk` branch is the
most up-to-date branch and is mainly focused on plasma 6, but may still work on
plasma 5. If you are running plasma 5, it's recommended to use the `plasma-5`
branch, which is designed to have better compatibility with plasma 5. To do this
with flakes you can use "github:nix-community/plasma-manager/plasma-5" as your
flake url, or if you are using nix-channels you can set the channel url to
"https://github.com/nix-community/plasma-manager/archive/plasma-5.tar.gz". It's
worth noting that the plasma 5 branch, due to the extra work required for
maintaining, may lag behind a bit in features, but in general it should be less
broken when used with plasma 5. If you want the best experience with
`plasma-manager` it's recommended running plasma 6.

## What's supported
At the moment `plasma-manager` supports configuring the following:
- KDE configuration files (via the `files` module)
- Global themes, colorschemes, icons, cursortheme, wallpaper (via the `workspace` module)
- Desktop icons, widgets, and mouse actions (via the `desktop` module)
- Configuration of spectacle shortcuts (via the `spectacle` module)
- Shortcuts (via the `shortcuts` module)
- Hotkeys (via the `hotkeys` module)
- Panels and Extra Widgets (via the `panels` module)
- Keyboards, Touchpads and Mice (via the `input` module)
- KRunner (via the `krunner` module)
- Screen locker (via the `kscreenlocker` module)
- Fonts (via the `fonts` module)
- Window Rules (via the `window-rules` module)
- Session (via the `session` module)
- KDE apps (via the `apps` module). In particular the following kde apps have
  modules in `plasma-manager`:
  - ghostwriter
  - kate
  - konsole
  - okular

Additionally there are more functionality than just listed above, and more
functionality to come in the future!

## What's not well supported (at the moment)
There also are some things which at the moment isn't very well supported, in
particular:
- Real-time updates of configuration without having to log out and back in
- Usage of high-level modules in the configuration generated by `rc2nix`
- Keybindings to some key combinations (`Ctrl+Alt+T` and `Print` for example, see https://github.com/nix-community/plasma-manager/issues/109 and https://github.com/nix-community/plasma-manager/issues/136)

There may also be more things we aren't aware of. If you find some other
limitations don't hesitate to open an issue or submit a pr.

## What will not be supported
There are some things which are out of bounds for this project due to technical
reasons. For example
- SDDM configuration (requires root-privileges and thus not suited for a `home-manager` module)

## Getting started
We provide some examples to help you get started. These are located in the
[examples](./examples/) directory. Here you in particular can find:
- [An example home-manager configuration](./examples/homeManager/home.nix) [with instructions](./examples/homeManager/README.md)
- [An example flake.nix for usage with home-manager only](./examples/homeManagerFlake//flake.nix)
- [An example flake.nix for usage with the system configuration](./examples/systemFlake/flake.nix)
- [An example home.nix showing some of the capabilities of plasma-manager](./examples/home.nix)

With more to come! These should give you some idea how to get started with
`plasma-manager`.

Additionally,
[the manual section containing all the supported plasma-manager options](https://nix-community.github.io/plasma-manager/options.xhtml)
may come in handy.

## Make your configuration more declarative with overrideConfig
By default `plasma-manager` will simply write the specified configurations to
various config-files and leave all other options alone. This way settings not
specified in `plasma-manager` will be left alone, meaning that configurations
made outside `plasma-manager` will still be set. This can lead to different
settings on different machines even with the same `plasma-manager`
configuration. If you like a declarative approach better consider enabling
`overrideConfig`. This makes it so all options not set by `plasma-manager` will
be set to the default on login. In practice this then becomes a declarative
setup, much like what you would expect from most `home-manager` options/modules.

One thing to keep in mind is that enabling this option will delete all the KDE
config-files on `home-manager` activation, and replace them with config-files
generated by `plasma-manager`. Therefore make sure you backup your KDE
config-files before enabling this option if you don't want to lose them.

## Capturing Your Current Configuration with rc2nix

To make it easier to migrate to `plasma-manager`, and to help maintain your Nix
configuration when not using `overrideConfig`, this project includes a tool
called `rc2nix`.

This tool will read KDE configuration files and translate them to Nix.  The
translated configuration is written to standard output.  This makes it easy to:

- Generate an initial Plasma Manager configuration file.
- See what settings are changed by a GUI tool by capturing a file
  before and after using the tool and then using `diff`.

Keep in mind that the `rc2nix` module isn't perfect and often will give somewhat
suboptimal configurations (it will in some cases prefer using the `files` module
when better configurations can be achieved using higher-level modules). However,
it is still a useful tool to quickly get your configuration up and running or
converting config-files generated by the gui settings app to nix expressions.

To run the `rc2nix` tool without having to clone this repository run
the following shell command:

```sh
nix run github:nix-community/plasma-manager
```

## Contributions and Maintenance

This is a community project and we welcome all contributions. KDE plasma and its
apps consists of a lot of configuration options, and if you find that some
options are missing and have the skills to implement this, PRs are very welcome.
Issues are also welcome for everything from feature-requests to bug-reports or
just general suggestions for improving the project.

## Special Thanks

`plasma-manager` started off it's development under
[pjones](https://github.com/pjones), whose contributions have laid the
foundation of the project to this day. The project was otherwise inspired by the
suggestions on [Home Manager Issue
#607][hm607] by people such as [bew](https://github.com/bew) and
[kurnevsky](https://github.com/kurnevsky). Thank you.

[home-manager]: https://github.com/nix-community/home-manager
[hm607]: https://github.com/nix-community/home-manager/issues/607
[nix-community]: https://github.com/nix-community
</file>

<file path="treefmt.toml">
[formatter.nixfmt-rfc-style]
command = "nixfmt"
includes = ["*.nix"]

[formatter.black]
command = "black"
includes = ["*.py", "*.pyi"]

[formatter.isort]
command = "isort"
includes = ["*.py", "*.pyi"]
</file>

</files>
